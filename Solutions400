// ======== Start 代码随想录 c++ ========

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <optional>
using namespace std;

/*
    数组题1:  二分法查找元素位置， 非递归实现，时间复杂度为 n
*/
class Solution {
public:
    int search(vector<int>& nums, int target) {
        
        int left = 0;
        int right = nums.size() - 1;

        while (left <= right)
        {
            int mid = (left + right) / 2;
            if (target < nums[mid])
            {
                right = mid - 1;
            }else if (target > nums[mid])
            {
                left = mid + 1;
            }else{
                return mid;
            }
            
        }
        
        return -1;

    }
};

/*
 数组题2：快慢指针  解决两个for循环问题（时间复杂度为 n2）   ->   时间复杂度为  n    
 原地查找给定目标元素，并将其删掉，非目标元素前移
*/
class Solution2 {
public:
    int removeElement(vector<int>& nums, int val) {
        
      int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size();  fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;

    }
};


/*
数组题3：将给定非递减数组元素平方后按照非递减排列
1、有序数组的平方   暴力解法    时间复杂度  n + n*logn    ->   n*logn
2、双指针法   首尾指针解决大小比较问题
*/

class Solution3
{
private:
    /* data */
public:
    Solution3
(/* args */);
    ~Solution3
();

    // 暴力解法
    vector<int> sortedSquares(vector<int>& nums) {
        
        for (auto i = nums.begin(); i != nums.end(); i++)
        {
        *i = (*i) * (*i);
        }

        sort(nums.begin(), nums.end());

        return nums;

    }

    // 双指针实现
    vector<int> sortedSquares2(vector<int> &nums) {
        
        int i = 0;
        int j = nums.size() - 1;
        int k = nums.size() - 1;

        vector <int> res(nums.size(), 0);
        
        while (i <= j)
        {
            
            if (nums[i] * nums[i] > nums[j] * nums[j])
            {
                res[k--] = nums[i] * nums[i];
                i++;
            }else{
                res[k--] = nums[j] * nums[j];
                j--;
            }
            
        }

        return res;

    }
};

Solution3::Solution3(/* args */)
{
}

Solution3::~Solution3()
{
}


template <typename E>
void Print(const vector <E> nums){

    for (auto i = nums.begin(); i != nums.end(); i++)
    {
        cout << *i << endl;
    }

}


/*
    数组题4：长度最小的子数组     回溯思想   递归解决     "注意"  ：   大于等于目标值    连续子数组   所以利用 “滑动窗口” 方法  
    1、暴力解法  时间复杂度   n2
    2、滑动窗口  时间复杂度   2n
*/
class Solution4
{
private:
    /* data */
public:
    Solution4(/* args */);
    ~Solution4();


    int minSubArrayLen(int target, vector<int>& nums) {
        
        if (nums.size() == 1 && nums[0] != target)
        {
            return 0;
        }
        
        if (nums.size() == 1 && nums[0] == target)
        {
            return 1;
        }


        int sum = 0;
        int res = 0;
        int index = 0;
        vector<int> temp;
        vector<int> result;


        dfs(target, nums, temp, sum, result, index);
        
        sort(result.begin(), result.end());

        if ( result.size() == 0)
        {
            return 0;
        }
        
        res = result[0];

        cout << result.size() << endl;
        return res;

    }

    void dfs(int target, vector<int>& nums, vector<int> &temp, int sum, vector<int> &result, int index){

      
       
        if ( sum == target)
        { 
            
            result.push_back(temp.size());
            cout << "----------------------" << endl;
            Print <int> (temp);
            return;
        }
        


        for (auto i = index; i < nums.size(); i++)
        {
            temp.push_back(nums[i]);
            index += 1;
            sum += nums[i];


            dfs(target, nums, temp, sum, result, index);

            temp.pop_back();
            sum -= nums[i];


            
        }


    }



};

Solution4::Solution4(/* args */)
{
}

Solution4::~Solution4()
{
}


/*
    数组题5：螺旋矩阵   
    给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 


    1、可以尝试回溯   顺时针 定义  移动顺序优先级    右 -> 下 -> 左  -> 上    定义一个矩阵标记 该位置是否已有元素  或者 是否是边界  （回溯实现）
    2、本方法实现
*/
class Solution5
{
private:
    /* data */
public:
    Solution5(/* args */);
    ~Solution5();

    vector<vector<int>> generateMatrix(int n) {

        // 初始化二维vector   方法一
        // vector<vector<int>> res(n);

        // for (int i = 0; i < res.size(); i++)
        // {
        //     res[i].resize(n);
        // }


        // 初始化二维vector   方法二
        vector<vector<int>> res(n, vector<int>(n, 0));

        

        int l = 0, r = n - 1, t = 0, b = n - 1;
        int start = 1;
        int end = n * n;


        while (start <= end)
        {
            
            for (int i = l; i <= r; i++)
            {
                res[t][i] = start ++;
            }
            t ++;

            for (int i = t; i <= b; i++)
            {
                res[i][r] = start ++; 
            }
            
            r --;

            for (int i = r; i >= l; i--)
            {
                res[b][i] = start ++;
            }
            
            b --;


            for (int i = b; i >= t; i--)
            {
                res[i][l] = start ++;
            }
            
            l ++;

        }
        


        return res;
    }

};

Solution5::Solution5(/* args */)
{
}


Solution5::~Solution5()
{
 
}


/*
    链表题1 ： （简单类型)   移除链表元素   
    给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

    可以采用递归实现，也可以采用while循环实现
*/

/*
 Definition for singly-linked list.
 */
struct ListNode {
int val;
ListNode *next;
ListNode() : val(0), next(nullptr) {}
ListNode(int x) : val(x), next(nullptr) {}
ListNode(int x, ListNode *next) : val(x), next(next) {}

};

class Solution6
{
private:
    /* data */
public:
    Solution6();
    ~Solution6();

    // 非递归实现
    ListNode* removeElements(ListNode* head, int val);

};

ListNode* Solution6 ::removeElements(ListNode* head, int val){
        

        while (head != NULL && head->val == val)
        {
            ListNode* temp = head;
            head = head->next;
            delete temp;
        }
        

        ListNode* temp = head;
        while (temp != NULL && temp->next != NULL)
        {
            if (temp->next->val == val)
            {
                ListNode* temp2 = temp->next;
                temp->next = temp->next->next;
                delete temp2;
            }else{
                temp = temp->next;
            }
            
        }
        
        return head;
}

Solution6::Solution6(){};
Solution6::~Solution6(){};



/*
    链表题2：设计链表，实现查询  首插  尾插   中间插入   删除  功能

*/


class MyLinkedList
{
private:
    /* data */
    ListNode* head;
public:
    MyLinkedList();
    ~MyLinkedList();

    int get(int index);
    
    void addAtHead(int val);
    
    void addAtTail(int val);
    
    void addAtIndex(int index, int val);
    void deleteAtIndex(int index);

    ListNode* getData();

};

ListNode* MyLinkedList::getData(){
    return head;
}

MyLinkedList::MyLinkedList()
{   
    head = new ListNode();

    // int arr[0] = {};

    // ListNode* temp = head;

    // for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    // {
    //     while (true)
    //     {
    //         if (temp->next == NULL)
    //         {
    //             temp->next = new ListNode(arr[i]);
    //             break;
    //         }else{
    //             temp = temp->next;
    //         }
            
    //     }
        
    // }
    
}

MyLinkedList::~MyLinkedList()
{
}


int MyLinkedList::get(int index){
    ListNode* temp = head;

    int count = 0;
    while (temp != NULL)
    {   
        
        if (count == index)
        {   
            return temp->val;
        }
        temp = temp->next;
        count ++;
    }

    return -1;

}

void MyLinkedList::addAtHead(int val) {
    
    if (head != NULL)
    {
        ListNode* newHead = new ListNode(val);
        newHead->next = head;
        head = newHead;
    }else{
        head->val = val;
    }
    
}


void MyLinkedList::addAtTail(int val) {
    
    ListNode* temp = head;

    if (temp == NULL)
    {
        head->val = val;
    }
    

    while (temp->next != NULL)
    {
        
        temp = temp->next;
    }

    temp->next = new ListNode(val);

    
}


void MyLinkedList::addAtIndex(int index, int val) {
    ListNode* temp = head;

    if (index <= 0)
    {
        if (head != NULL)
        {
            ListNode* newHead = new ListNode(val);
            newHead->next = head;
            head = newHead;
            return;
        }else{
            head->val = val;
        }
    }
    
    int count = 0;

    bool flag = false;
    while (temp->next != NULL)
    {   
        if (count == index - 1)
        {   
            ListNode* addNode = new ListNode(val);
            ListNode* tt = temp->next;
            temp->next = addNode;
            addNode->next = tt;
            flag = true;
            return;
        }
        temp = temp->next; 
        count ++;
    }

   temp->next = new ListNode(val);

}


void MyLinkedList::deleteAtIndex(int index) {

    ListNode* temp = head;

    if (index == 0 && temp != NULL)
    {
        ListNode* temp2 = head;
        head = head->next;
        delete temp2;
    }

    int count = 1;
    while (temp->next != NULL) 
    {
       
        if (count == index)
        {   
            ListNode* ss = temp->next;
            temp->next = temp->next->next;
            delete ss;
        }else{
            temp = temp->next;
        }
         count ++;
        
    }
    
    
}



/*
    打印单链表
*/

static void printLinkedList(ListNode* head){

    if (head == NULL)
    {
        return;
    }

    ListNode* temp = head;

    while (temp != NULL)
    {
        std::cout << temp->val << "    ";
        temp = temp->next;
    }
    std::cout << endl;

} 


class Solution7
{
private:
    ListNode* head;
public:
    Solution7(/* args */);
    ~Solution7();

    ListNode* reverseList(ListNode* head);

    ListNode* getDate();

};

ListNode* Solution7::getDate(){
    return head;
}
Solution7::Solution7(/* args */)
{   
    head = new ListNode();


    int arr[5] = {1, 2, 3, 4, 5};

    ListNode* temp = head;

    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        while (true)
        {
            if (temp->next == NULL)
            {
                temp->next = new ListNode(arr[i]);
                break;
            }else{
                temp = temp->next;
            }
            
        }
        
    }
}

Solution7::~Solution7()
{

}


/*
    链表题3：反转链表
*/
ListNode* Solution7::reverseList(ListNode* head) {
    
    ListNode* pre = NULL;
    ListNode* cur = head;
    ListNode* temp = NULL;
    while (cur != NULL)
    {
        temp = cur->next;
        cur->next = pre;

        pre = cur;
        cur = temp;
    }
    
        
    return pre;
    
}


/*
    链表题4：两两交换链表中的节点
*/

class Solution8
{
private:
    ListNode* head;
public:
    Solution8(/* args */);
    ~Solution8();


    ListNode* swapPairs(ListNode* head);

    ListNode* setDate();
};

ListNode* Solution8::setDate(){
    return head;
}



Solution8::Solution8(/* args */)
{
    head = new ListNode();

    ListNode* temp = head;

    int  arr [4] = {1, 2, 3, 4};
    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        while (true)
        {
            if (temp->next == NULL)
            {
                temp->next = new ListNode(arr[i]);
                break;
            }else{
                temp = temp->next;
            }
            
        }
        
    }
    head = head->next;

}

Solution8::~Solution8()
{
}

ListNode* Solution8::swapPairs(ListNode* head){
    
    ListNode* virtualHeadNode = new ListNode(0);

    virtualHeadNode->next = head;

    ListNode* cur = virtualHeadNode;
    
    while (cur->next != NULL && cur->next->next != NULL)
    {   
        ListNode* temp = cur->next;

        ListNode* temp2 = cur->next->next->next;

        cur->next = cur->next->next;

        cur->next->next = temp;

        cur->next->next->next = temp2;
        

        cur = cur->next->next;
    }
    
    printf("--------------");
    printLinkedList(head);
    head = virtualHeadNode->next;
    return virtualHeadNode->next;
}

/*
    链表题5：删除链表的倒数第 N 个节点， 并返回链表头节点
*/
class Solution9
{
private:
    ListNode* head;
public:
    Solution9(/* args */);
    ~Solution9();

    ListNode* removeNthFromEnd(ListNode* head, int n);
    ListNode* removeNthFromEnd2(ListNode* head, int n);

    ListNode* getDate();
};

Solution9::Solution9(/* args */)
{
    head = new ListNode();

    ListNode* temp = head;

    int  arr [5] = {1, 2, 3, 4, 5};
    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        while (true)
        {
            if (temp->next == NULL)
            {
                temp->next = new ListNode(arr[i]);
                break;
            }else{
                temp = temp->next;
            }
            
        }
        
    }
    head = head->next;
}

Solution9::~Solution9()
{
}

/*
    思路一： 先遍历一遍链表，获取链表长度，再遍历一次删除指定的节点

    思路二： 定义fast指针和slow指针，初始值为虚拟头节点
*/
ListNode* Solution9::removeNthFromEnd(ListNode* head, int n){
    
    // 思路一：  加入头节点
    if (head == nullptr)
    {
        return head;
    }
    
    ListNode* nullHead = new ListNode(0);

    nullHead->next = head;
    
    ListNode* temp = nullHead;

    int count = 0;
    while (temp->next != nullptr)
    {
        count ++;
        temp = temp->next;
    }

    temp = nullHead;

    int c = 0;
    while (temp->next != nullptr)
    {
        if (n > count)
        {
            break;
        }

        if (c == count - n)
        {
            temp->next = temp->next->next;
            break;
        }
        
        temp = temp->next;
        c ++;

    }
    
    return nullHead->next;
 
};

ListNode* Solution9::removeNthFromEnd2(ListNode* head, int n){

    // 思路二： 双指针
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;
    ListNode* slow = dummyHead;
    ListNode* fast = dummyHead;
    while(n-- && fast != NULL) {
        fast = fast->next;
    }
    fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点
    while (fast != NULL) {
        fast = fast->next;
        slow = slow->next;
    }
    slow->next = slow->next->next; 
    
    return dummyHead->next;
}


ListNode* Solution9::getDate(){
    return head;
}


/*
    链表题6：链表相交
*/
class Solution10
{
private:
    ListNode* headA;
    ListNode* headB;
public:
    Solution10(/* args */);
    ~Solution10();

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB);

    pair<ListNode*, ListNode*> getData();



};
pair<ListNode*, ListNode*> Solution10::getData(){
    return make_pair(this->headA, this->headB);
};

static void printPairLinkedList(pair<ListNode*, ListNode*> res){

    if (res.first == NULL)
    {
        return;
    }

    ListNode* temp = res.first;

    while (temp != NULL)
    {
        std::cout << temp->val << "    ";
        temp = temp->next;
    }
    std::cout << endl;
    std::cout << "===========================" << endl;


    if (res.second == NULL)
    {
        return;
    }

    temp = res.second;

    while (temp != NULL)
    {
        std::cout << temp->val << "    ";
        temp = temp->next;
    }
   
}

Solution10::Solution10(/* args */)
{
    headA = new ListNode();

    ListNode* temp = headA;

    int  arr [5] = {4, 1, 8, 4, 5};
    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        while (true)
        {
            if (temp->next == NULL)
            {
                temp->next = new ListNode(arr[i]);
                break;
            }else{
                temp = temp->next;
            }
            
        }
        
    }
    headA = headA->next;

    headB = new ListNode();

    temp = headB;

    int  arr2 [6] = {5, 0, 1, 8, 4, 5};
    for (int i = 0; i < sizeof(arr2) / sizeof(arr2[0]); i++)
    {
        while (true)
        {
            if (temp->next == NULL)
            {
                temp->next = new ListNode(arr2[i]);
                break;
            }else{
                temp = temp->next;
            }
            
        }
        
    }
    headB = headB->next;

}

Solution10::~Solution10()
{
}

ListNode* Solution10::getIntersectionNode(ListNode *headA, ListNode *headB){

        // 添加头节点
        ListNode* newHeadA = new ListNode(0);
        newHeadA->next = headA;
        ListNode* newHeadB = new ListNode(0);
        newHeadB->next = headB;
        
        ListNode* temp1 = newHeadA;
        ListNode* temp2 = newHeadB;

        int lenA = 0;
        int lenB = 0;
        while (temp1->next != nullptr)
        {
            temp1 = temp1->next;
            lenA ++;
        }

        while (temp2->next != nullptr)
        {
            temp2 = temp2->next;
            lenB ++;
        }
        std:: cout << endl;
        temp1 = newHeadA;
        temp2 = newHeadB;
        if (lenA == lenB)
        {
            while (temp1->next != nullptr && temp2->next != nullptr)
            {
                if (temp1->next->val == temp2->next->val)
                {
                    return temp1->next;
                }else{
                    temp1 = temp1->next;
                    temp2 = temp2->next;
                }  
            }
            
        }else if (lenA < lenB)
        {    
            
            int count = 0;
            // 移动到相等位置
            while (temp2->next != nullptr)
            {
                if (count == lenB - lenA)
                {
                    break;
                }else{
                    temp2 = temp2->next;
                }
                count ++;
            }

            // 判断相交点
            ListNode* temp3 = temp2;
            while (temp1->next != nullptr && temp3->next != nullptr)
            {
                if (temp1->next->val == temp3->next->val)
                {   
                    return temp1->next;
                }else{
                    temp1 = temp1->next;
                    temp3 = temp3->next;
                }
            }

            
        }else{
            int count = 0;
            while (temp1->next != nullptr)
            {
                if (count == lenA - lenB)
                {
                    break;
                }else{
                    temp1 = temp1->next;
                }
                count ++;
            }

            ListNode* temp4 = temp1;
            while (temp2->next != nullptr && temp4->next != nullptr)
            {
                if (temp2->next->val == temp4->next->val)
                {
                    return temp2->next;
                }else{
                    temp2 = temp2->next;
                    temp4 = temp4->next;
                }
                
            }

        }
    
        return nullptr;

};

class Solution11
{
private:
    ListNode* head;
public:
    Solution11(/* args */);
    ~Solution11();

    ListNode *detectCycle(ListNode *head);
    
    ListNode* getData();

};

ListNode* Solution11::getData(){
    return head;
}

Solution11::Solution11(/* args */)
{
    head = new ListNode();

    ListNode* temp = head;

    int  arr [4] = {3, 2, 0, -4};
    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        while (true)
        {
            if (temp->next == NULL)
            {
                temp->next = new ListNode(arr[i]);
                break;
            }else{
                temp = temp->next;
            }
        } 
    }
    temp->next = head->next->next;
    
}

Solution11::~Solution11()
{

}

ListNode * Solution11::detectCycle(ListNode *head){
    head = head->next;
    ListNode* fast = head;
    ListNode* slow = head;

    while (fast != nullptr && fast->next != nullptr)
    {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast)
        {
            ListNode* index1 = fast;
            ListNode* index2 = head;

            while (index1 != index2)
            {
                index1 = index1->next;
                index2 = index2->next;
            }
            
            return index2;
        }
        
    }
    return nullptr;
}


/*

    哈希表题1：有效的字母异位词
*/


class Solution12
{
private:
    /* data */
public:
    Solution12(/* args */);
    ~Solution12();

    bool isAnagram(string s, string t);

};

/*
    需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，
    所以字符a映射为下标0，相应的字符z映射为下标25。
    再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，
    只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。
*/
bool Solution12::isAnagram(string s, string t){
    
    int record[26] = {0};

    for (int i = 0; i < s.size(); i++)
    {
        record[s[i] - 'a'] ++;
    }

    for (int i = 0; i < t.size(); i++)
    {
        record[t[i] - 'a'] --;
    }
    
    for (int i = 0; i < sizeof(record) / sizeof(record[0]); i++)
    {
        if (record[i] != 0)
        {
            return false;
        }
        
    }
    
    return true;
}
Solution12::Solution12(/* args */)
{
}

Solution12::~Solution12()
{
}

/*
    哈希表题2：两个数组的交集
*/
#include <set>
class Solution13
{
private:
    /* data */
public:
    Solution13(/* args */);
    ~Solution13();
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2);

};

vector<int> Solution13::intersection(vector<int>& nums1, vector<int>& nums2){
    vector<int> res;

    set<int> temp(nums1.begin(), nums1.end());
    set<int> temp2(nums2.begin(), nums2.end());
    // res.resize(std::min(temp.size(), temp2.size()));      使用 back_inserter 不用resize 调用 back_inserter，返回一个插入迭代器，这个迭代器会调用push_back添加元素到容器中
    std::set_intersection(temp.begin(), temp.end(), temp2.begin(), temp2.end(), std::back_inserter(res));
     
    return vector<int>(res.begin(), res.end());


};
Solution13::Solution13(/* args */)
{
}

Solution13::~Solution13()
{
}

/*
    哈希表题3：快乐数

*/

class Solution14
{
private:
    /* data */
public:
    Solution14(/* args */);
    ~Solution14();

    bool isHappy(int n);
};

#include <unordered_set>
bool Solution14::isHappy(int n){


    // 创建一个hash表，如果存在一个已经记录的数字则存在循环，则返回false
    unordered_set<int> judge; 

    while (true)
    {   
        if (judge.find (n) != judge.end())
        {
            return false;
        }else{
            
            judge.insert(n);
        }
        
        // 针对单个数字
        if (n == 1)
        {
            return true;
        }

        // 针对多个数字，取出每一个数字
        vector<int> temp;
        while ( n / 10 != 0 )
        {   
            int temp2 = n % 10; 
            temp.push_back(temp2);
            n = n / 10;
        }
        temp.push_back(n);
        
        int res = 0;  // 计算每次的结果，更新n值
        for (auto i = temp.begin(); i != temp.end(); i++)
        {
            res += (*i) * (*i);
        }
    
        if (res == 1)
        {
            return true;
        }
        
        n = res;

    }

    return false;

}

Solution14::Solution14(/* args */)
{
}

Solution14::~Solution14()
{
}

/*
    哈希表题4：四数相加2
*/
class Solution15
{
private:
    /* data */
public:
    Solution15(/* args */);
    ~Solution15();

    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4);
    
};

Solution15::Solution15(/* args */)
{
}

Solution15::~Solution15()
{
}

# include<unordered_map>
int Solution15::fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4){
    int res = 0;

    unordered_map<int, int> m; 
    for (int i = 0; i < nums1.size(); i++)
    {
        for (int j = 0; j < nums2.size(); j++)
        {
            m[nums1[i] + nums2[j]] ++;
        }
        
    }
    
    for (int i = 0; i < nums3.size(); i++)
    {
        for (int j = 0; j < nums4.size(); j++)
        {
            if (m.find(0 - (nums3[i] + nums4[j])) != m.end())  // find这里找取key的值是否存在，若存在获取其key出现的次数
            {
                res += m[0 - (nums3[i] + nums4[j])];
            }
            
        }
        
    }
    
    return res;
}


class Solution16
{
private:
    /* data */
public:
    Solution16(/* args */);
    ~Solution16();

    bool canConstruct(string ransomNote, string magazine);
};

Solution16::Solution16(/* args */)
{
}

Solution16::~Solution16()
{
}

/*
   哈希表题5：赎金信
   给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

    如果可以，返回 true ；否则返回 false 。

    magazine 中的每个字符只能在 ransomNote 中使用一次。
*/
bool Solution16::canConstruct(string ransomNote, string magazine){

    // 记录magazine里每个字符使用情况，若使用则该位置为1，否则该位置为0
    unordered_map<int, int> record;
    int count = 0;
    for (int i = 0; i < ransomNote.length(); i++)
    {
        for (int j = 0; j < magazine.length(); j++)
        {
            if (magazine[j] == ransomNote[i] && record[j] != 1)
            {
                record[j] = 1;
                count ++;
                break;
            }else{
                record[j] = 0;
            }
            
        }
        
    }
    if (count == ransomNote.length())
    {
        return true;
    }
    
    return false;
}

/*
    哈希表题6： 三数之和，   排序+双指针
*/

class Solution17
{
private:
    /* data */
public:
    Solution17(/* args */);
    ~Solution17();

    vector<vector<int>> threeSum(vector<int>& nums);
    vector<vector<int>> threeSum2(vector<int>& nums);
};

Solution17::Solution17(/* args */)
{
}

Solution17::~Solution17()
{
}

/*
    思路一：排序+双指针  思路： 暴力for循环  要用三重for循环  如果使用排序+双指针  则时间复杂度 n2
    时间复杂度分析：
    循环数组  n   第一个元素
    排序时间复杂度 nlogn    
    双指针时间复杂度 n
    所以时间复杂度：nlogn + n * n
    思路二: 哈希表解法   
*/
vector<vector<int>> Solution17::threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    
    if (nums.size() == 3)
    {
        if (nums[0] + nums[1] + nums[2] == 0)
        {   
            vector<int> temp;
            temp.push_back(nums[0]);
            temp.push_back(nums[1]);
            temp.push_back(nums[2]);
            res.push_back(temp);
            return res;
        }else{
            return res;
        }
        
    }
    
    sort(nums.begin(), nums.end());

    // 循环数组
    for (int i = 0; i < nums.size() - 2; i++)
    {

        if (i > 0 && nums[i] == nums[i - 1]){
            continue;
        }

        // 剪枝
        if (nums[i] + nums[i+1] + nums[i+2] > 0){
            break;
        }
        if (nums[i] + nums[nums.size() - 2] + nums[nums.size() - 1] < 0){
            continue;
        }

        int left = i+1;
        int right = nums.size() - 1;

        while (left < right)
        {   

            if (nums[i] + nums[left] + nums[right] == 0){
                vector<int> temp;
                temp.push_back(nums[i]);
                temp.push_back(nums[left]);
                temp.push_back(nums[right]);
                res.push_back(temp);
                
                while (left < right && nums[left] == nums[left+1]){
                    left ++;
                }
                left ++;
                while (left < right && nums[right] == nums[right-1]){
                    right --;
                }
                right --;

            }else if (nums[i] + nums[left] + nums[right] < 0)
            {
                left ++;
            }else{
                right --;
            }

        }
        
    }
    
    return res;
}

// 思路二：哈希表
vector<vector<int>> Solution17::threeSum2(vector<int>& nums) {
    vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[j], c = -(a + b)
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组
            if (nums[i] > 0) {
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重
                continue;
            }
            unordered_set<int> set;
            for (int j = i + 1; j < nums.size(); j++) {
                if (j > i + 2
                        && nums[j] == nums[j-1]
                        && nums[j-1] == nums[j-2]) { // 三元组元素b去重
                    continue;
                }
                int c = 0 - (nums[i] + nums[j]);
                if (set.find(c) != set.end()) {
                    result.push_back({nums[i], nums[j], c});
                    set.erase(c);// 三元组元素c去重
                } else {
                    set.insert(nums[j]);
                }
            }
        }
    return result;
}

/*
    哈希表题7：四数之和
*/
class Solution18
{
private:
    /* data */
public:
    Solution18(/* args */);
    ~Solution18();

    vector<vector<int>> fourSum(vector<int>& nums, int target);

};

Solution18::Solution18(/* args */)
{
}

Solution18::~Solution18()
{
}

// 类比于三数之和: 可以两个for循环遍历数组 + 双指针    n3 时间复杂度 
vector<vector<int>> Solution18::fourSum(vector<int>& nums, int target) {
    vector<vector<int>> res;

    if (nums.size() == 4)
    {
        
       if ((long)(nums[0] + nums[1] + nums[2] + nums[3]) == target)
       {
            vector<int> temp;
            temp.push_back(nums[0]);
            temp.push_back(nums[1]);
            temp.push_back(nums[2]);
            temp.push_back(nums[3]);
            res.push_back(temp);
            return res;
       }else{
            return res;
       }
    }
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size() - 3; i++)
    {   

        // 剪枝
        if ((long)(nums[i] + nums[i+1] + nums[i+2] + nums[i+3]) > target){
            break;
        }
        if ((long)(nums[i] + nums[nums.size() - 3] + nums[nums.size() - 2] + nums[nums.size() - 1]) < target){
            continue;
        }

        if (i > 0 && nums[i] == nums[i-1])
        {
            continue;
        }

        for (int j = i+1; j < nums.size() - 2; j++)
        {
            
            if (j > i + 1 && nums[j] == nums[j-1])
            {
                continue;
            }
            
            int left = j + 1;
            int right = nums.size() - 1;
            
            while (left < right)
            {
                if ((long)(nums[i] + nums[j] + nums[left] + nums[right]) == target)
                {
                    vector <int> temp;
                    temp.push_back(nums[i]);
                    temp.push_back(nums[j]);
                    temp.push_back(nums[left]);
                    temp.push_back(nums[right]);

                    res.push_back(temp);
                    while (left < right && nums[left] == nums[left + 1])
                    {
                       left ++;
                    }
                    
                    while (left < right && nums[right] == nums[right - 1])
                    {
                       right --;
                    }
                    left ++;
                    right --;

                }else if ((long)(nums[i] + nums[j] + nums[left] + nums[right]) <= target)
                {
                    left ++;
                }else{
                    right --;
                }
                
            }
            
        }
        
    }
    
    return res;
}

/*
    字符串题1：反转字符串
*/
class Solution19
{
private:
    /* data */
public:
    Solution19(/* args */);
    ~Solution19();

    void reverseString(vector<char>& s);
};

Solution19::Solution19(/* args */)
{
}

Solution19::~Solution19()
{
}

void Solution19::reverseString(vector<char>& s) {

    int size = s.size();

    // 交换
    for (int i = 0; i < size / 2; i++)
    {
        char temp = s[i];
        s[i] = s[size - i - 1];
        s[size - i - 1] = temp;
    }
    
    for (int i = 0; i < size; i++)
    {
        cout << s[i] << endl;
    }
    
}

/*
    字符串题2：反转字符串2
    给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

    如果剩余字符少于 k 个，则将剩余字符全部反转。
    如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
*/

class Solution20
{
private:
    /* data */
public:
    Solution20(/* args */);
    ~Solution20();

    string reverseStr(string s, int k);

};

Solution20::Solution20(/* args */)
{
}

Solution20::~Solution20()
{
}

string Solution20::reverseStr(string s, int k) {
    
     for (int i = 0; i < s.size(); i += (2 * k)) {
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k <= s.size()) {
                reverse(s.begin() + i, s.begin() + i + k );
            } else {
                // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                reverse(s.begin() + i, s.end());
            }
        }
        return s;
}

/*
    字符串题3：替换空格
    请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
*/
class Solution21
{
private:
    /* data */
public:
    Solution21(/* args */);
    ~Solution21();

    string replaceSpace(string s);
};

/*
如果想把这道题目做到极致，就不要只用额外的辅助空间了！
首先扩充数组到每个空格替换成"%20"之后的大小。
然后从后向前替换空格，也就是双指针法，过程如下：
i指向新长度的末尾，j指向旧长度的末尾。
其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。
1、不用申请新数组。
2、从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。
*/
string Solution21::replaceSpace(string s) {

    int count = 0; // 统计空格的个数
    int sOldSize = s.size();
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == ' ') {
            count++;
        }
    }
    // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小
    s.resize(s.size() + count * 2);
    int sNewSize = s.size();
    // 从后向前将空格替换为"%20"
    for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
        if (s[j] != ' ') {
            s[i] = s[j];
        } else {
            s[i] = '0';
            s[i - 1] = '2';
            s[i - 2] = '%';
            i -= 2;
        }
    }
    return s;
    
}

Solution21::Solution21(/* args */)
{
}

Solution21::~Solution21()
{
}

/*
    字符串题4：反转字符串中单词
    思路：
*/
class Solution22
{
private:
    /* data */
public:
    Solution22(/* args */);
    ~Solution22();

    string reverseWords(string s);
};

string Solution22::reverseWords(string s) {
    // 反转整个字符串
        reverse(s.begin(), s.end());

        int n = s.size();
        int idx = 0;
        for (int start = 0; start < n; ++start) {
            if (s[start] != ' ') {
                // 填一个空白字符然后将idx移动到下一个单词的开头位置
                if (idx != 0) s[idx++] = ' ';

                // 循环遍历至单词的末尾
                int end = start;
                while (end < n && s[end] != ' ') s[idx++] = s[end++];

                // 反转整个单词
                reverse(s.begin() + idx - (end - start), s.begin() + idx);

                // 更新start，去找下一个单词
                start = end;
            }
        }
        s.erase(s.begin() + idx, s.end());
        return s;
}

Solution22::Solution22(/* args */)
{
}

Solution22::~Solution22()
{
}

// 字符串题5：左旋转字符串
class Solution23
{
private:
    /* data */
public:
    Solution23(/* args */);
    ~Solution23();

    string reverseLeftWords(string s, int n);
};


/*
    reverse(s.begin(), s.begin() + n);
    reverse(s.begin() + n, s.end());
    reverse(s.begin(), s.end());
*/
string Solution23::reverseLeftWords(string s, int n) {
    string res = "";
    string temp = "";

    if (n > s.size())
    {
        return s;
    }
    
    int sizeofS = s.size();
    for (int i = 0; i < sizeofS; i++)
    {
        if (i == n)
        {   
            res += s;
            res += temp;
            return res;
        }else{
            temp += s[0];
            s.erase(s.begin());
        }
        
    }
    
    return res;
}

Solution23::Solution23(/* args */)
{
}

Solution23::~Solution23()
{
}

// 字符串题6：找出字符串中第一个匹配项的下标     KMP 算法
    // 本题是KMP经典题目

// 需要总结算法思路
/*
    KMP算法 解决字符串匹配问题

    部分匹配表： 每一个子串（包括模式串本身）最长相等前后缀长度

*/

class Solution24
{
private:
    /* data */
public:
    Solution24(/* args */);
    ~Solution24();

    int strStr(string haystack, string needle);
};

// KMP 算法对 重要的一步 求next数组，即部分匹配表
void getNext(int* next, string s){

    int j = 0;
    next[0] = 0;
    for(int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
            j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
      
};
int Solution24::strStr(string haystack, string needle) {
    if (needle.size() == 0) {
            return 0;
        }
    int next[needle.size()];
    getNext(next, needle);
    int j = 0;
    for (int i = 0; i < haystack.size(); i++) {
        while(j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        if (haystack[i] == needle[j]) {
            j++;
        }
        if (j == needle.size() ) {
            return (i - needle.size() + 1);
        }
    }
    return -1;
}

Solution24::Solution24(/* args */)
{
}

Solution24::~Solution24()
{
}

/*
    字符串题7：重复的子字符串

    思路一：移动循环法
    思路二：KMP算法
*/

class Solution25
{
private:
    /* data */
public:
    Solution25(/* args */);
    ~Solution25();

    bool repeatedSubstringPattern1(string s);
    bool repeatedSubstringPattern2(string s);
};

// 判断大字符串是否可以由其子串构造（重复构成）
bool Solution25::repeatedSubstringPattern1(string s) {
    
    string s2 = s + s;

    s2.erase(s2.begin());
    s2.erase(s2.end() - 1);

    if (s2.find(s) != std::string::npos)  // std::string::npos 它实际上意味着直到字符串的末尾。
    {
        return true;
    }
    
    return false;
}

void getNext2(int * next, string s){

    int j = 0;
    next[0] = j;

    for (int i = 1; i < s.size(); i++)
    {
        while (j > 0 && s[i] != s[j])
        {
            j = next[j - 1];
        }
        if (s[i] == s[j])
        {
            j++;
        }
        next[i] = j;
    }
  
}
bool Solution25::repeatedSubstringPattern2(string s) {
    if (s.size() == 0)
    {
        return false;
    }
    

    int next[s.size()];
    getNext2(next, s);

    if (next[s.size() - 1] != 0 && s.size() % (s.size() - next[s.size() - 1]) == 0)
    {
        return true;
    }
    
    return false;

}

Solution25::Solution25(/* args */)
{
}

Solution25::~Solution25()
{
}


/*
    双指针法题1：移除元素
    通过快慢指针将暴力解法的 n2 时间复杂度降为 n
*/

class Solution26
{
private:
    /* data */
public:
    Solution26(/* args */);
    ~Solution26();

    int removeElement(vector<int>& nums, int val);
};
int Solution26::removeElement(vector<int>& nums, int val) {

    int slow = 0;
    for (int fast = 0; fast < nums.size(); fast++)
    {
        if (nums[fast] == val)
        {
            nums[slow++] = nums[fast];   // 这里其实nums数组里大小没有改变，只是将数组前面的元素变成了新的元素
        }
        
    }
    
    return slow;

}

Solution26::Solution26(/* args */)
{
}

Solution26::~Solution26()
{
}

/*
    双指针法题2：反转字符串，该题已在字符串专题中解决 
    通过快慢指针解决时间复杂度为 n2 的问题 将时间复杂度降为 n
    解决思路是通过前后指针指向数组首尾元素         终点是 size() / 2       所以双指针分为快慢指针和首尾指针  此题为首尾指针，上题为快慢指针

    主要是交换首尾指针的值
*/

/*
    双指针法题3：替换空格
    思路：一个指针指向新数组，一个指针指向旧数组     简称：新旧指针
    步骤：1、先循环遍历获取空格个数
         2、按照空格个数，扩容新数组大小
         3、利用双指针产生新数组
*/

class Solution27
{
private:
    /* data */
public:
    Solution27(/* args */);
    ~Solution27();

    string replaceSpace(string s);
};

string Solution27::replaceSpace(string s) {

    int count = 0;
    int sOldSize = s.size();
    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == ' ')
        {
            count ++;
        }
        
    }
    
    s.resize(s.size() + count * 2);
    int sNewSize = s.size();
    // 从后往前   因为扩容原因
    for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i --, j--)   // j < i   最终 i=j=0  跳出循环
    {
        if (s[j] != ' ')
        {
            s[i] = s[j];
        }else{
            s[i] = '0';
            s[i - 1] = '2';
            s[i - 2] = '%';
            i -= 2;

        }        
        
    }
    return s;
    // return s.replace(" ","%20");
}

Solution27::Solution27(/* args */)
{
}

Solution27::~Solution27()
{
}

/*
    双指针法题4：翻转字符串里的单词
    本题未解决
*/
class Solution28
{
private:
    /* data */
public:
    Solution28(/* args */);
    ~Solution28();


};

Solution28::Solution28(/* args */)
{
}

Solution28::~Solution28()
{
}


/*
    双指针法题5：反转链表    cur  和 pre 指针     前后指针的用法
    在链表题中已解决
*/

/*
    双指针法题6：删除链表的第N个节点    快慢指针的用法
    在链表题中已解决
*/

/*
    双指针法题7：链表相交      
    在链表题中已解决
*/

/*
    双指针法题8：环形链表2     快慢指针的用法
    在链表题中已解决
*/


/*
    双指针法题9：三数之和     双指针法  和   哈希表法    排序 + 剪枝  减少时间复杂度
    在链表题中已解决
*/

/*
    双指针法题10：四数之和     双指针法  和  哈希表法
    在链表题中已解决
*/

/*
    栈与队列题1：用栈实现队列   
    已用 python 实现

*/
class Solution29
{
private:
    
public:
    Solution29(/* args */);
    ~Solution29();

    void push(int x);
    int pop();
    int peek();
    bool empty();
};

void Solution29::push(int x){

}
int Solution29::pop(){

    return 0;
}
int Solution29::peek(){

    return 0;
}
bool Solution29::empty(){
    return 0;
}

Solution29::Solution29(/* args */)
{
}

Solution29::~Solution29()
{
}


/*
    栈与队列题2：队列模拟栈    思路：采用双队列模拟栈
*/
#include <queue>
class Solution30
{
private:
    queue<int> qMain;
    queue<int> qAssist;
public:
    Solution30(/* args */);
    ~Solution30();

    void push(int x);
    
    int pop();
    
    int top();
    
    bool empty();
};

void Solution30::push(int x) {
    qMain.push(x);
}

int Solution30::pop() {
    int size = qMain.size();

    int count = 0;   // 这里拿到了size  可以在while里使用 size --  去掉count 减少代码量  while（size -- ）
    while (count != size - 1)
    {
        qAssist.push(qMain.front());  // 这里需要拿到头部  再pop  因为pop 不反悔pop掉的元素
        qMain.pop();
        count ++;
    }

    int res = qMain.front();
    qMain.pop();

    while (qAssist.size() != 0)
    {
        qMain.push(qAssist.front());
        qAssist.pop();
    }
    
    return res;
    
}

int Solution30::top() {
    return qMain.back();
}

bool Solution30::empty() {
    return qMain.empty();
}

Solution30::Solution30(/* args */)
{   
}

Solution30::~Solution30()
{
}

/*
    栈与队列题3：有效的括号    括号不匹配分三种情况： 左括号多余、左右括号不匹配、右括号多余
    只要处理完这三种情况，则可以判定。
    巧妙在于，栈顶元素刚好是最里左括号需要的右括号
*/
#include<stack>
class Solution31
{
private:
    /* data */
public:
    Solution31(/* args */);
    ~Solution31();

    bool isValid(string s);
};

bool Solution31::isValid(string s) {
    stack<char> stack;

    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == '(')
        {
            stack.push(')');
        }else if (s[i] == '[')
        {
            stack.push(']');
        }else if (s[i] == '{')
        {
            stack.push('}');
        }else if (stack.empty() || stack.top() != s[i])   // 第三中情况 !stack.empty()      第二种情况 stack.top() != s[i]
        { 
            return false;
        }else{
            stack.pop();
        }
        
    }
    // 第一种情况
    return stack.empty();
}
Solution31::Solution31(/* args */)
{
}

Solution31::~Solution31()
{
}

/*
    栈与队列题4：
    题目描述：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
            在 S 上反复执行重复项删除操作，直到无法继续删除。
            在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
*/
class Solution32
{
private:
    /* data */
public:
    Solution32(/* args */);
    ~Solution32();

    string removeDuplicates(string s);
};

/*
    思路： 依次入栈，将即将入栈的元素和栈顶元素比较，如果元素相等，则出栈，如不相等则入栈
*/
string Solution32::removeDuplicates(string s) {

    stack<char> res;

    for (int i = 0; i < s.size(); i++)
    {
        if (!res.empty() && res.top() == s[i])
        {
            res.pop();
        }else{
            res.push(s[i]);
        }
        
    }
    string result = "";
    result.resize(res.size());
    while (!res.empty())
    {
        result += res.top();
        res.pop();
    }
    reverse(result.begin(), result.end());
    return result;

}
Solution32::Solution32(/* args */)
{
}

Solution32::~Solution32()
{
}

/*
    栈与队列题5：逆波兰表达式求值
*/
class Solution33
{
private:
    /* data */
public:
    Solution33(/* args */);
    ~Solution33();

    int evalRPN(vector<string>& tokens);
};
/*
    思路：可以使用两个栈，一个存放数字栈，一个存放运算符栈
    输入：tokens = ["2","1","+","3","*"]
    输出：9
    解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9


    // 逆波兰表达式 (也即后缀表达式) 不用考虑优先级问题

    去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。

    适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中
*/
int Solution33::evalRPN(vector<string>& tokens) {
    stack<int> numStack;
    // stack<int> signStack;

    for (int i = 0; i < tokens.size(); i++)
    {
        
        if (tokens[i] == "+")
        {
            if (numStack.size() >= 2)
            {
                int b = numStack.top();
                numStack.pop();
                int a = numStack.top();
                numStack.pop();
                int c = a + b;
                numStack.push(c);
            }
            
        }else if (tokens[i] == "-")
        {
            int b = numStack.top();
            numStack.pop();
            int a = numStack.top();
            numStack.pop();
            int c = a - b;
            numStack.push(c);
        }else if (tokens[i] == "*")
        {
            int b = numStack.top();
            numStack.pop();
            int a = numStack.top();
            numStack.pop();
            int c = a * b;
            numStack.push(c);
        }else if (tokens[i] == "/")
        {
            int b = numStack.top();
            numStack.pop();
            int a = numStack.top();
            numStack.pop();
            int c = a / b;
            numStack.push(c);
        }else{
            numStack.push(atoi(tokens[i].c_str()));    // int a = atoi(s.c_str());  将string转换成int
        } 
        
    }
    
    return numStack.top();
}

Solution33::Solution33(/* args */)
{
}

Solution33::~Solution33()
{
}

/*
    栈与队列题6：滑动窗口最大值（困难）
    输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
    输出：[3,3,5,5,6,7]
*/
class Solution34
{
private:
    /* data */
public:
    Solution34(/* args */);
    ~Solution34();

    vector<int> maxSlidingWindow(vector<int>& nums, int k);
};

// 需要实现一个单调栈  具体是单调递减栈  使用deque实现

class MyQueue
{
private:
    /* data */
public:
    deque<int> queue;

    MyQueue(/* args */);
    ~MyQueue();


    void pop(int value);

    void push(int value);

    int front(); // 拿到最大值，出口元素即最大值
};

void MyQueue::pop(int value){

    if (!queue.empty() && value == queue.front())
    {
        queue.pop_front();
    }     

}

void MyQueue::push(int value){

    // 保证单调性
    while (!queue.empty() && value > queue.back())
    {
        queue.pop_back();
    }
    
    queue.push_back(value);

}

int MyQueue::front(){

    return queue.front();

}

MyQueue::MyQueue(/* args */)
{
}

MyQueue::~MyQueue()
{
}


vector<int> Solution34::maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> res;

    MyQueue mq;
    for (int i = 0; i < k; i++)
    {
        mq.push(nums[i]);
    }
    
    res.push_back(mq.front());
    for (int i = k; i < nums.size(); i++)
    {
        mq.pop(nums[i - k]);
        mq.push(nums[i]);
        res.push_back(mq.front());
    }
    
    return res;
}

Solution34::Solution34(/* args */)
{
}

Solution34::~Solution34()
{
}

/*
    栈与队列题7：前 K 个高频元素
    给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

    思路一：优先级队列
    思路二: python字典
*/

class Solution35
{
private:
    /* data */
public:
    Solution35(/* args */);
    ~Solution35();

    vector<int> topKFrequent(vector<int>& nums, int k);
};

vector<int> Solution35::topKFrequent(vector<int>& nums, int k) {
    vector<int> ret;
    unordered_map<int, int> mp;   // unordered_map 底层又哈希表实现  无序  
    priority_queue<pair<int, int>> pq; // 优先队列   如果元素为 pair  则按照 first 排序， 默认为大顶堆，所以first取反  top 元素最小
    for (auto i : nums) mp[i]++;  // 字典获取元素及频次
    for (auto p : mp) {
        pq.push(pair<int, int>(-p.second, p.first));  // 优先队列在push时自动按照first排序
        if (pq.size() > k) pq.pop();  // 不用将全部元素放入，减少时间消耗
    }
    while (k--) {
        ret.push_back(pq.top().second);  // 放入结果集
        pq.pop();
    }
    return ret;

}

Solution35::Solution35(/* args */)
{
}

Solution35::~Solution35()
{
}

/*
    二叉树题1：前序遍历
*/

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution36
{
private:
    /* data */
public:
    Solution36(/* args */);
    ~Solution36();

    vector<int> preorderTraversal(TreeNode* root);
};
/*
    两种遍历方法：递归法和迭代法（非递归法）
*/
void preOrder(TreeNode* root, vector<int>& v){
    if (root == NULL)
    {
        return;
    }
    
    v.push_back(root->val);
    preOrder(root->left, v);
    preOrder(root->right, v);


}
vector<int> Solution36::preorderTraversal(TreeNode* root) {
    
    // 先使用递归实现
    vector<int> res;
    
    preOrder(root, res);

    return res;
} 

Solution36::Solution36(/* args */)
{
    
}

Solution36::~Solution36()
{
}

/*
    二叉树题2：中序遍历
*/
class Solution37
{
private:
    /* data */
public:
    Solution37(/* args */);
    ~Solution37();

    vector<int> midorderTraversal(TreeNode* root);
};

void midOrder(TreeNode* root, vector<int>& v){
    if (root == NULL)
    {
        return;
    }
    
    midOrder(root->left, v);
    v.push_back(root->val);
    midOrder(root->right, v);


}
vector<int> Solution37::midorderTraversal(TreeNode* root) {
    
    // 先使用递归实现
    vector<int> res;
    
    midOrder(root, res);

    return res;
} 

Solution37::Solution37(/* args */)
{
}

Solution37::~Solution37()
{
}

/*
    二叉树题3：后序遍历
*/
class Solution38
{
private:
    /* data */
public:
    Solution38(/* args */);
    ~Solution38();
    vector<int> postorderTraversal(TreeNode* root);
};


void postOrder(TreeNode* root, vector<int>& v){
    if (root == NULL)
    {
        return;
    }
    
    postOrder(root->left, v);
    postOrder(root->right, v);
    v.push_back(root->val);


}
vector<int> Solution38::postorderTraversal(TreeNode* root) {
    
    // 先使用递归实现
    vector<int> res;
    
    postOrder(root, res);

    return res;
} 

Solution38::Solution38(/* args */)
{
}

Solution38::~Solution38()
{
}

/*
    二叉树题4：  迭代遍历（非递归遍历二叉树） 以及迭代法的统一写法    未实现
*/

/*
    二叉树题5：二叉树的层序遍历   广度优先思想
*/

class Solution39
{
private:
    /* data */
public:
    Solution39(/* args */);
    ~Solution39();

    vector<vector<int>> levelOrder(TreeNode* root);
};

vector<vector<int>> Solution39::levelOrder(TreeNode* root) {

    vector<vector<int>> res;
    if (root == nullptr) return res;
    
    // 使用队列实现
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty())
    {
        
        int size = q.size();
        vector<int> temp;
        for (int i = 0; i < size; i++)
        {   
            TreeNode* node = q.front();
            temp.push_back(node->val);
            q.pop();
            if (node->left) q.push(node->left); 
            if (node->right) q.push(node->right); 
        }
        res.push_back(temp);
    }
    
    return res;
}

Solution39::Solution39(/* args */)
{
}

Solution39::~Solution39()
{
}

/*
    二叉树题5：翻转二叉树
*/

class Solution40
{
private:
    /* data */
public:
    Solution40(/* args */);
    ~Solution40();

    TreeNode* invertTree(TreeNode* root);
};

TreeNode* Solution40::invertTree(TreeNode* root) {
    if (root == nullptr) return root;
    stack<TreeNode*> s;
    s.push(root);
    while (!s.empty())
    {
        TreeNode* temp = s.top();
        s.pop();
        swap(temp->left, temp->right);
        if (root->right) s.push(root->right);
        if (root->left) s.push(root->left);
    }
    return root;
    
}

Solution40::Solution40(/* args */)
{
}

Solution40::~Solution40()
{
}
/*
    二叉树题6: 二叉树的最大深度
*/

class Solution41
{
private:
    /* data */
public:
    Solution41(/* args */);
    ~Solution41();

    int maxDepth(TreeNode* root);
};

Solution41::Solution41(/* args */)
{
}

Solution41::~Solution41()
{
}
// 思路一，二叉树的最大深度可以使用层序遍历去实现，记录层数个数就行
// 思路二，使用递归实现
/*
    int getdepth(treenode* node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);       // 左
        int rightdepth = getdepth(node->right);     // 右
        int depth = 1 + max(leftdepth, rightdepth); // 中
        return depth;
    }
    int maxdepth(treenode* root) {
        return getdepth(root);
    }
*/
int Solution41::maxDepth(TreeNode* root) {

    if (root == NULL) return 0;
    
    queue<TreeNode*> q;
    q.push(root);
    int depth = 0;   // int 需要初始化为 0   如果不初使化int变量,将得到一个随机值。
    while (!q.empty())
    {
        int size = q.size();

        for (int i = 0; i < size; i++)
        {
            TreeNode* node = q.front();
            q.pop();
            if (node->left) q.push(node->left); 
            if (node->right) q.push(node->right); 
        }
         
        depth ++;

    }
     
    return depth;
}

/*
    二叉树题7：二叉树的最小深度
*/

class Solution42
{
private:
    /* data */
public:
    Solution42(/* args */);
    ~Solution42();

    int minDepth(TreeNode* root);
};
// 思路一：
// 思路二：参照求二叉树的最大深度，可以使用递归法求最小深度, 但要注意还是有很大区别的
int getDepth(TreeNode* node){
    int leftDepth = getDepth(node->left);           // 左
    int rightDepth = getDepth(node->right);         // 右
    // 当一个左子树为空，右不为空，这时并不是最低点
    if (node->left == NULL && node->right != NULL) { 
        return 1 + rightDepth;
    }   
    // 当一个右子树为空，左不为空，这时并不是最低点
    if (node->left != NULL && node->right == NULL) { 
        return 1 + leftDepth;
    }
    int result = 1 + min(leftDepth, rightDepth);
    return result;

}

int Solution42::minDepth(TreeNode* root) {

    return getDepth(root);
}

Solution42::Solution42(/* args */)
{
}

Solution42::~Solution42()
{
}

/*
    二叉树题8：完全二叉树的节点个数
*/

class Solution43
{
private:
    /* data */
public:
    Solution43(/* args */);
    ~Solution43();

    int countNodes(TreeNode* root);
};

// 思路 借助层序遍历的思想实现
int Solution43::countNodes(TreeNode* root) {

    if (root == NULL)
    {
        return 0;
    }
    
    int count = 0;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty())
    {
        int size = q.size();

        for (int i = 0; i < size; i++)
        {
            TreeNode* node = q.front();

            q.pop();

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);

            count ++;    
        }
   
    }
    
    return count;
}

Solution43::Solution43(/* args */)
{
}

Solution43::~Solution43()
{
}

/*
    二叉树题9：平衡二叉树      定义：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

    求二叉树的深度需要从上至下，所以可以用前序遍历
    求二叉树的高度需要从下至上，所以可以用后续遍历

    前序遍历求深度（递归）   最大深度（高度） 也可以用层序遍历（非递归）    最大高度和最大深度一样，但是平衡二叉树要求每个节点高度满足条件，就不同于求深度问题
    int result;
    void getDepth(TreeNode* node, int depth) {
        result = depth > result ? depth : result; // 中
        if (node->left == NULL && node->right == NULL) return ;
        if (node->left) { // 左
            getDepth(node->left, depth + 1);
        }
        if (node->right) { // 右
            getDepth(node->right, depth + 1);
        }
        return ;
    }
    int maxDepth(TreeNode* root) {
        result = 0;
        if (root == 0) return result;
        getDepth(root, 1);
        return result;
    }

*/
class Solution44
{
private:
    /* data */
public:
    Solution44(/* args */);
    ~Solution44();

    bool isBalanced(TreeNode* root);
};
// 1、递归后续遍历求高度（左右中）   2、迭代法     未实现

int getHight(TreeNode* root){
    if (root == NULL) return 0;

    int leftHight = getHight(root->left);
    if (leftHight == -1) return -1;
    int rightHight = getHight(root->right);
    if (rightHight == -1) return -1;
    
    return abs(leftHight - rightHight) > 1? -1: 1+max(leftHight, rightHight);

}

bool Solution44::isBalanced(TreeNode* root) {
    return getHight(root) == -1? false : true;
}

Solution44::Solution44(/* args */)
{
}

Solution44::~Solution44()
{
}

/*
    二叉树题10：二叉树的所有路径

    给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
*/
class Solution45
{
private:
    /* data */
public:
    Solution45(/* args */);
    ~Solution45();

    vector<string> binaryTreePaths(TreeNode* root);
};

// 思路：从上往下 前序遍历  递归实现
void getPath(TreeNode* root, vector<string> &res, vector<int> &temp){
    temp.push_back(root->val);
    if (root->left == NULL && root->right == NULL){
        string sPath = "";
        for(int i = 0; i < temp.size() - 1; i ++){
            sPath += std::to_string(temp[i]);
            sPath += "->";
        };
        sPath += to_string(temp[temp.size() - 1]); // 记录最后一个节点（叶子节点）
        res.push_back(sPath);
        return;
    } 

    if (root->left) {
        getPath(root->left, res, temp);
        temp.pop_back();  // 回溯
    }
    if (root->right){
        getPath(root->right, res, temp);  
        temp.pop_back();  // 回溯
    } 
}

vector<string> Solution45::binaryTreePaths(TreeNode* root) {
    vector<string> res;
    vector<int> temp;

    getPath(root, res, temp);

    return res;
}

Solution45::Solution45(/* args */)
{
}

Solution45::~Solution45()
{
}
/*
    二叉树题11：左叶子之和
    给定二叉树的根节点，返回所有左叶子之和
*/

class Solution46
{
private:
    /* data */
public:
    Solution46(/* args */);
    ~Solution46();

    int sumOfLeftLeaves(TreeNode* root);
};

int Solution46::sumOfLeftLeaves(TreeNode* root) {

    if (root == NULL) return 0;
    if (root->left == NULL && root->right== NULL) return 0;

    int leftValue = sumOfLeftLeaves(root->left);    // 左

    if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况
        leftValue = root->left->val;
    }
    int rightValue = sumOfLeftLeaves(root->right);  // 右

    int sum = leftValue + rightValue;               // 中
    return sum;
}

Solution46::Solution46(/* args */)
{
}

Solution46::~Solution46()
{
}

/*
    二叉树题12：找树左下角的值

    给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

    假设二叉树中至少有一个节点。
*/

class Solution47
{
private:
    
public:
    Solution47(/* args */);
    ~Solution47();
    int maxDepth = INT_MIN;
    int result = 0;
    int findBottomLeftValue(TreeNode* root);
    void getLeftValue(TreeNode* root, int deepth);
};

Solution47::Solution47(/* args */)
{
}

Solution47::~Solution47()
{
}

// 递归实现   思路：先找到最大深度（即最底层)  然后回去左子节点的值

/*
    递归三部曲
    1、确定参数和返回值
    2、终止条件
    3、确定单层递归（注意，如果有回溯，应该先递归在回溯，写在一起）

*/
// 1、确定参数和返回值
void Solution47::getLeftValue(TreeNode* root, int deepth){

    // 2、终止条件
    if (root->left == NULL && root->right == NULL) {   // 目的是找到最底层（即叶子节点）
        if (deepth > maxDepth) {  // 不断更新值，当然最后会找到深度最深的叶子节点，并且拿到节点值       因为在同一级不会进入这个 if 判断
            maxDepth = deepth;  // 这里因为递归的时候是 先左后右   所以当拿到左子节点的时候就返回了
            result = root->val;
        }
        return;
    }
    
    // 3、单层递归条件
    if (root->left)
    {
        deepth ++;
        getLeftValue(root->left, deepth);
        deepth --;
    }
    
    if (root->right)
    {
        deepth ++;
        getLeftValue(root->right, deepth);
        deepth --;
    }
    
}
int Solution47::findBottomLeftValue(TreeNode* root) {

    getLeftValue(root, 0);
    return 0;
}


/*
    二叉树题13：路径总和     这道题和求所有路径题一个思路
*/

class Solution48
{
public:
    Solution48(/* args */);
    ~Solution48();

    bool hasPathSum(TreeNode* root, int targetSum);
};

void getPath(TreeNode* root, vector<int> &res, vector<int> &temp){
        temp.push_back(root->val);
        if (root->left == NULL && root->right == NULL){
            int sPath = 0;
            for(int i = 0; i < temp.size(); i ++){
                sPath += temp[i];
            };
            res.push_back(sPath);
            return;
        } 

        if (root->left) {
            getPath(root->left, res, temp);
            temp.pop_back();
        }
        if (root->right){
            getPath(root->right, res, temp);  
            temp.pop_back();
        } 
    }


bool Solution48::hasPathSum(TreeNode* root, int targetSum) {
    if(root == NULL) return false;

    vector<int> res;
    vector<int> temp;
    getPath(root, res, temp);

    bool res2 = false;

    for(int i = 0; i < res.size(); i++){

        if(res[i] == targetSum){
            res2 = true;
        }
    }

    return res2;
}

Solution48::Solution48(/* args */)
{
}

Solution48::~Solution48()
{
}

/*
    二叉树题14：路径总和2

    给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
    叶子节点 是指没有子节点的节点。


    找出所有满足目标值的路径    这道题的思路和上一道一样

*/

class Solution49
{
private:
    /* data */
public:
    Solution49(/* args */);
    ~Solution49();

    vector<vector<int>> pathSum(TreeNode* root, int targetSum);
};

void getPathTarget(TreeNode* root, vector<vector<int>> &res, vector<int> &temp, int targetSum){

    temp.push_back(root->val);

    if (root->left == NULL && root->right == NULL)
    {
        int sum = 0;
        for (int i = 0; i < temp.size(); i++)
        {
            sum += temp[i];
        }

        if (sum == targetSum)
        {
            res.push_back(temp);
        }
        
    }
    
    if (root->left)
    {
        getPathTarget(root->left, res, temp, targetSum);
        temp.pop_back();
    }
    
    if (root->right)
    {
        getPathTarget(root->right, res, temp, targetSum);
        temp.pop_back();
    }

}

vector<vector<int>> Solution49::pathSum(TreeNode* root, int targetSum) {

    vector<vector<int>> res;
    if(root == NULL) return res;
    vector<int> temp;
    getPathTarget(root, res, temp, targetSum);
    return res;
    
}

Solution49::Solution49(/* args */)
{
}

Solution49::~Solution49()
{
}

/*
    二叉树题15：从中序与后序遍历序列构造二叉树
*/


class Solution50
{
private:
    /* data */
public:
    Solution50(/* args */);
    ~Solution50();

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder);
};
/*
    中序后序遍历二叉树：
    思路：
    1、当根节点为空（无节点），则返回null
    2、当只有一个节点，则返回节点
    3、根据后序数组，获取父节点
    4、根据父节点切割中序数组
    5、根据中序数组前后长度切割后序数组
    6、递归处理切割后的前后区间
*/
TreeNode* Solution50::buildTree(vector<int>& inorder, vector<int>& postorder) {

   
    if (postorder.size() == 0)
    {
        return NULL;
    }
   
    // 后序遍历数组最后一个元素，就是当前的中间节点
    int rootValue = postorder[postorder.size() - 1];
    TreeNode* root = new TreeNode(rootValue);

    // 叶子节点
    if (postorder.size() == 1) return root;

    // 使用左闭右开
    int index = 0;
    for (index = 0; index < inorder.size(); index++)
    {
        if (inorder[index] == rootValue)
        {
            break;
        }
        
    }
    
    vector<int> leftInorder(inorder.begin(), inorder.begin() + index); // 拷贝构造
    vector<int> rightInorder(inorder.begin() + index + 1, inorder.end()); // 拷贝构造

    postorder.resize(postorder.size() - 1);

    vector<int> leftPostorder(postorder.begin(), inorder.begin() + leftInorder.size()); // 拷贝构造
    vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()); // 拷贝构造

    // 处理前区间
    root->left = buildTree(leftInorder, leftPostorder);
    // 处理后区间
    root->right = buildTree(rightInorder, rightPostorder);

    return root;
}

Solution50::Solution50(/* args */)
{
}

Solution50::~Solution50()
{
}

/*
    二叉树题16：从中序与前序遍历序列构造二叉树     注意：前序和后序不能唯一确定一棵二叉树
*/

class Solution51
{
private:
    /* data */
public:
    Solution51(/* args */);
    ~Solution51();

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder);
};
// 这道题思想和中序后序遍历一样，不再是按后序切割，而是按前序切割
TreeNode* traval(vector<int>& preorder, vector<int>& inorder) {
    if (preorder.size() == 0)
    {
        return NULL;
    }
    
    int val = preorder[0];
    TreeNode* root = new TreeNode(val);
    
    if (preorder.size() == 1)
    {
        return root;
    }
    

    // 切割
    int index = 0;
    for (index = 0; index < inorder.size(); index++)
    {
        if (inorder[index] == val)
        {
            break;
        }
        
    }
    
    vector<int> leftInorder(inorder.begin(), inorder.begin() + index);
    vector<int> rightInorder(inorder.begin() + index + 1, inorder.end());

    preorder.erase(preorder.begin());  // 这里需要将第一个元素去掉

    vector<int> leftPreorder(preorder.begin(), preorder.begin() + leftInorder.size());
    vector<int> rightPreorder(preorder.begin() + leftInorder.size(), preorder.end());


    root->left = traval(leftPreorder, leftInorder);
    root->right = traval(rightPreorder, rightInorder);

    return root;
}

TreeNode* Solution51::buildTree(vector<int>& preorder, vector<int>& inorder) {

    if (preorder.size() == 0 || inorder.size() == 0)
    {
        return NULL;
    }
    

    return traval(preorder, inorder);
}

Solution51::Solution51(/* args */)
{
}

Solution51::~Solution51()
{
}

/*
    二叉树题17：最大二叉树

    给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

    创建一个根节点，其值为 nums 中的最大值。
    递归地在最大值 左边 的 子数组前缀上 构建左子树。
    递归地在最大值 右边 的 子数组后缀上 构建右子树。
    返回 nums 构建的 最大二叉树 。

*/

class Solution52
{
private:
    
public:
    Solution52(/* args */);
    ~Solution52();

    TreeNode* constructMaximumBinaryTree(vector<int>& nums);
};

// 递归构建最大二叉树
    int findMax(vector<int> vec) {
    int max = -999;
    for (auto v : vec) {
        if (max < v) max = v;
    }
    return max;
}

// 递归构建最大二叉树
TreeNode* travalBuildTree(vector<int> &nums){
    
    if (nums.size() == 0)
    {
        return NULL;
    }

    int maxValue = findMax(nums);
    TreeNode* root = new TreeNode(maxValue);
    
    if (nums.size() == 1)
    {
        return root;
    }
    

    int index = 0;
    for ( index = 0; index < nums.size(); index++)
    {
        if (nums[index] == maxValue)
        {
            break;
        }
        
    }
    
    vector<int> leftNums(nums.begin(), nums.begin() + index);
    vector<int> rightNums(nums.begin() + index + 1, nums.end());

    root->left = travalBuildTree(leftNums);
    root->right = travalBuildTree(rightNums);


    return root;

}

TreeNode* Solution52::constructMaximumBinaryTree(vector<int>& nums) {

    if (nums.size() == 0)
    {
        return NULL;
    }
    
    return travalBuildTree(nums);

}

Solution52::Solution52(/* args */)
{
    
}

Solution52::~Solution52()
{
}

/*
    二叉树题18：合并二叉树

    思路：
    可以先前（中或后）序遍历第一棵二叉树，从根节点开始，判断该节点是否有左右孩子，都有则相加合并，没有则将有的加上去
*/
class Solution53
{
private:
    
public:
    Solution53(/* args */);
    ~Solution53();
    TreeNode* root1;
    TreeNode* root2;
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2);
};

// 选择前序遍历
TreeNode* Solution53::mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == NULL) return root2;
    if (root2 == NULL) return root1;
    
    root1->val += root2->val;

    root1->left = mergeTrees(root1->left, root2->left);
    root1->right = mergeTrees(root1->right, root2->right);
    
    return root1;
}

Solution53::Solution53(/* args */)
{
    root1 = new TreeNode(1);
    root1->left = new TreeNode(3);
    root1->right = new TreeNode(2);
    root1->left->left = new TreeNode(5);

    root2 = new TreeNode(2);
    root2->left = new TreeNode(1);
    root2->right = new TreeNode(3);
    root2->left->right = new TreeNode(4);
    root2->right->right = new TreeNode(7);
}

Solution53::~Solution53()
{
}


// 遍历二重vector
template <typename E>
void ShowTowVector(vector<vector<E>> res){
    cout << "[";
    for(auto i : res){
        cout << "[ ";
        for(auto j: i){
            cout << j << " ";
        }
        cout << "],";
    }
    cout << "]" << endl;
    
}

/*
    二叉树题19：二叉树中的搜索

    给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

    你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

*/

class Solution54
{
private:
    /* data */
public:
    Solution54(/* args */);
    ~Solution54();

    TreeNode* searchBST(TreeNode* root, int val);
};


// 思路：通过前中后遍历找到等于目标值的节点
TreeNode* Solution54::searchBST(TreeNode* root, int val) {

    if(root == NULL || root->val == val) return root;
    TreeNode* result;
    if(root->val > val) result = searchBST(root->left, val);
    if(root->val < val) result = searchBST(root->right, val);
    return result;

}

Solution54::Solution54(/* args */)
{
}

Solution54::~Solution54()
{
}

/*
    二叉树题20：验证二叉搜索树


    给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

    有效 二叉搜索树定义如下：

    节点的左子树只包含 小于 当前节点的数。
    节点的右子树只包含 大于 当前节点的数。
    所有左子树和右子树自身必须也是二叉搜索树。
 
*/
class Solution55
{
private:
    /* data */
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    Solution55(/* args */);
    ~Solution55();

    bool isValidBST(TreeNode* root);
};
/*
    要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。

    有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。
*/


// 思路：1、转换成数组

    // private:
    //     vector<int> vec;
    //     void traversal(TreeNode* root) {
    //         if (root == NULL) return;
    //         traversal(root->left);
    //         vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    //         traversal(root->right);
    //     }
    // public:
    //     bool isValidBST(TreeNode* root) {
    //         vec.clear(); // 不加这句在leetcode上也可以过，但最好加上
    //         traversal(root);
    //         for (int i = 1; i < vec.size(); i++) {
    //             // 注意要小于等于，搜索树里不能有相同元素
    //             if (vec[i] <= vec[i - 1]) return false;
    //         }
    //         return true;
    //     }



//      2、递归实现
bool Solution55::isValidBST(TreeNode* root) {
    
    if (root == NULL)
    {
        return true;
    }
    
    bool left = isValidBST(root->left);

    if ( maxVal < root->val) 
    {
        maxVal = root->val;
    }else{
        return false;
    }
    

    bool right = isValidBST(root->right);

    return left && right;
}

Solution55::Solution55(/* args */)
{
}

Solution55::~Solution55()
{
}

/*
    二叉树题21：二叉搜索树的最小绝对值

*/
class Solution56
{
private:
    
public:
    vector<int> vec;
    Solution56(/* args */);
    ~Solution56();

    int getMinimumDifference(TreeNode* root);
    void traversal(TreeNode* root);
};


void Solution56::traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}

int Solution56::getMinimumDifference(TreeNode* root) {

        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
}

Solution56::Solution56(/* args */)
{
}

Solution56::~Solution56()
{
}

/*
    二叉树题22：二叉搜索树中的众数
*/

class Solution57
{
private:
    /* data */
public:
    vector<int> vec;
    Solution57(/* args */);
    ~Solution57();

    vector<int> findMode(TreeNode* root);
    void traversal2(TreeNode* root);
};

void Solution57::traversal2(TreeNode* root) {
    if (root == NULL) return;
    traversal2(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal2(root->right);
}
// 思路：转换成序列，使用undered_map 获取频次  最后获得众数
vector<int> Solution57::findMode(TreeNode* root) {

        vec.clear();
        traversal2(root);
        if (vec.size() < 2) return vec;
        vector<int> res;
        unordered_map<int, int> map;
        int maxCount = 0;
        for (int i = 0; i < vec.size(); i++) { // 统计有序数组的最小差值
            map[vec[i]] ++;
            if (maxCount < map[vec[i]])
            {
                maxCount = map[vec[i]];
            }
            
        }
        for (auto i = map.begin(); i != map.end(); i++)
        {
            if ((*i).second == maxCount)
            {
                res.push_back((*i).first);
            }
            
        }
        
        return res;
}


Solution57::Solution57(/* args */)
{
}

Solution57::~Solution57()
{
}

/*
    二叉树题23：二叉树的最近公共祖先     未解决
*/
class Solution58
{
private:
    /* data */
public:
    Solution58(/* args */);
    ~Solution58();

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);
};

TreeNode* Solution58::lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {


    return NULL;   
}

Solution58::Solution58(/* args */)
{
}

Solution58::~Solution58()
{
}

/*
    二叉树题24：二叉搜索树的最近公共祖先    未解决
*/

class Solution59
{
private:
    /* data */
public:
    Solution59(/* args */);
    ~Solution59();

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);
};

TreeNode* Solution59::lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    

    return NULL;
}


Solution59::Solution59(/* args */)
{
}

Solution59::~Solution59()
{
}
/*
    二叉树题25：二叉搜索树中的插入操作
*/

class Solution60
{
private:
    /* data */
public:
    Solution60(/* args */);
    ~Solution60();

    TreeNode* insertIntoBST(TreeNode* root, int val);
};

// 思路：可采用递归前序遍历方式，其实对于二叉搜索树，只需要再最底层插入即可，即找到空节点即可
TreeNode* Solution60::insertIntoBST(TreeNode* root, int val) {

    if (root == NULL)
    {   
        TreeNode* node = new TreeNode(val);
        return node;
    }

    if (val < root->val)
    {
        root->left = insertIntoBST(root->left, val);
    }
    
    if (val > root->val)
    {
        root->right = insertIntoBST(root->right, val);
    }
    

    return root;

}

Solution60::Solution60(/* args */)
{
}

Solution60::~Solution60()
{
}

/*
    二叉树题26：删除二叉搜索树中的节点
*/

class Solution61
{
private:
    /* data */
public:
    Solution61(/* args */);
    ~Solution61();

    TreeNode* deleteNode(TreeNode* root, int key);
};

// 思路，就是找到目标值节点后，比较其孩子节点大小，调整关系，再将其删除
TreeNode* Solution61::deleteNode(TreeNode* root, int key) {

    if (root == NULL)
    {
        return root;
    }
    
    if (root->val == key && !root->left && !root->right)
    {
        return NULL;
    }
    
    if (root->val == key && root->left && !root->right)
    {
        return root->left;
    }
    
    if (root->val == key && !root->left && root->right) 
    {
        return root->right;
    }
    
    // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。
    if (root->val == key && root->left && root->right)
    {
        TreeNode* cur = root->right;
        while (cur->left)
        {
            cur = cur->left;
        }

        cur->left = root->left;
        TreeNode* temp = root;
        root = root->right;
        delete temp;
        return root;
        
    }

    if (root->val > key)
    {
        root->left = deleteNode(root->left, key);
    }
    
    if (root->val < key)
    {
        root->right = deleteNode(root->right, key);
    }
    

    return root;
}

Solution61::Solution61(/* args */)
{
    
}

Solution61::~Solution61()
{
}

/*
    二叉树题27：修剪二叉搜索树                这道题很绕，建议多看看

    给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，
    使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 
    (即，如果没有被移除，原有的父代子代关系都应当保留)。
*/
class Solution62
{
private:
    /* data */
public:
    Solution62(/* args */);
    ~Solution62();

    TreeNode* trimBST(TreeNode* root, int low, int high);
};

// 
TreeNode* Solution62::trimBST(TreeNode* root, int low, int high) {
    if (root == nullptr ) return nullptr;
    if (root->val < low) {
        TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
        return right;
    }
    if (root->val > high) {
        TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
        return left;
    }
    root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
    root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
    return root;

}

Solution62::Solution62(/* args */)
{
}

Solution62::~Solution62()
{
}

/*
    二叉树题28：将有序数组转化为二叉搜索树

*/

class Solution63
{
private:
    /* data */
public:
    Solution63(/* args */);
    ~Solution63();

    TreeNode* sortedArrayToBST(vector<int>& nums);
};

// 思路：二叉搜索树的中序遍历就是递增序列， 而此时有序数组的中间元素就是二叉树的根节点，按照此元素进行分割，再递归就能构造完毕
TreeNode* Solution63::sortedArrayToBST(vector<int>& nums) {

    if (nums.size() == 0)
    {
        return NULL;
    }

    TreeNode* root = new TreeNode(nums[nums.size() / 2]);

    if (nums.size() == 1)
    {
        TreeNode* node = new TreeNode(nums[0]);
        return node;
    }
    
    // 分割
    vector<int> leftnums(nums.begin(), nums.begin() + nums.size() / 2);
    vector<int> rightnums(nums.begin() + nums.size() / 2 + 1, nums.end());
    
    root->left = sortedArrayToBST(leftnums);
    root->right = sortedArrayToBST(rightnums);
    
    return root;
}
Solution63::Solution63(/* args */)
{
}

Solution63::~Solution63()
{
}

/*
    二叉树题29：把二叉搜索树转换为累加树                建议多看看

    给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
    使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

*/

class Solution64
{
private:
    /* data */
public:
    Solution64(/* args */);
    ~Solution64();

    TreeNode* convertBST(TreeNode* root);
};

int pre = 0; // 记录前一个节点的数值
void traversal(TreeNode* cur) { // 右中左遍历
    if (cur == NULL) return;
    traversal(cur->right);
    cur->val += pre;
    pre = cur->val;
    traversal(cur->left);
}
// 思路：计算每个节点的右子树之和，作为该节点的新值
TreeNode* Solution64::convertBST(TreeNode* root) {

    pre = 0;
    traversal(root);
    
    return root;
}
Solution64::Solution64(/* args */)
{
}

Solution64::~Solution64()
{
}


/*
    回溯算法题1：组合
*/

class Solution65
{
private:
    /* data */
public:
    Solution65(/* args */);
    ~Solution65();

    vector<vector<int>> combine(int n, int k);
    void backtracking(vector<vector<int>> &res, vector<int> &temp, int k, int n, int index);
};

/*
    给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
    你可以按 任何顺序 返回答案。
*/

void Solution65::backtracking(vector<vector<int>> &res, vector<int> &temp, int k, int n, int index){
    
    if (temp.size() == k)
    {
        res.push_back(temp);
        return;
    }
    
    for (int i = index; i < n; i++)   // for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置  “优化剪枝”
    {
        temp.push_back(i);
        backtracking(res, temp, k, n, ++index);
        temp.pop_back();
    }
    
}

vector<vector<int>> Solution65::combine(int n, int k) {
    vector<vector<int>> res;
    vector<int> temp;
    int index = 1;
    backtracking(res, temp, k, n+1, index);

    return res;
}

Solution65::Solution65(/* args */)
{
}

Solution65::~Solution65()
{
}

// int main(){

//     Solution65 s65;

//     int k = 2;

//     int n = 4;

//     auto res = s65.combine(n, k);

//     ShowTowVector(res);

//     return 0;
// }

/*
    回溯算法题2：组合总和3

    找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

    只使用数字1到9
    每个数字 最多使用一次 
    返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

*/
class Solution66
{
private:
    /* data */
public:
    Solution66(/* args */);
    ~Solution66();

    vector<vector<int>> combinationSum3(int k, int n);
    void backtracking(vector<vector<int>> &res, vector<int> &temp, int k, int n, int index, int sum);
};

void Solution66::backtracking(vector<vector<int>> &res, vector<int> &temp, int k, int n, int index, int sum){

    
    if (sum > n) { // 剪枝操作
        return;
    }

    if (sum == n && temp.size() == k)
    {
        res.push_back(temp);
        return;
    }
    

    for (int i = index; i < 10; i++)
    {
        temp.push_back(i);
        sum += i;
        backtracking(res, temp, k, n, ++index, sum);
        sum -= i;
        temp.pop_back();
    }
    
}

vector<vector<int>> Solution66::combinationSum3(int k, int n) {
    vector<vector<int>> res;
    vector<int> temp;
    int index = 1;
    int sum = 0;
    backtracking(res, temp, k, n, index, sum);

    return res;
}

Solution66::Solution66(/* args */)
{
}

Solution66::~Solution66()
{
}
// int main(){

//     Solution66 s66;

//     int k = 3;

//     int n = 9;

//     auto res = s66.combinationSum3(k, n);

//     ShowTowVector(res);

//     return 0;
// }


/*
    回溯算法题3：电话号码的字母组合

    给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

    给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

*/
#include <unordered_map>
#include <map>
class Solution67
{
private:
    /* data */
public:
    vector<string> result;
    string s;
    Solution67(/* args */);
    ~Solution67();
    
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
    vector<string> letterCombinations(string digits);
    void backtracking(const string& digits, int index);

};


void Solution67::backtracking(const string& digits, int index) {
    if (index == digits.size()) {
        result.push_back(s);
        return;
    }
    int digit = digits[index] - '0';        // 将index指向的数字转为int
    string letters = letterMap[digit];      // 取数字对应的字符集
    cout << letters << endl;
    for (int i = 0; i < letters.size(); i++) {
        s.push_back(letters[i]);            // 处理
        cout << letters[i] << " ";
        backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
        s.pop_back();                       // 回溯
    }
}

vector<string> Solution67::letterCombinations(string digits) {
    s.clear();
    result.clear();
    if (digits.size() == 0) {
        return result;
    }
    backtracking(digits, 0);
    return result;
}



Solution67::Solution67(/* args */)
{
}

Solution67::~Solution67()
{
}

// int main(){

//     Solution67 s67;

//     string s = "23";

//     auto res = s67.letterCombinations(s);

//     for (int i = 0; i < res.size(); i++)
//     {
//         cout << res[i] << "  ";
//     }
//     cout << endl;

//     return 0;
// }


/*
    回溯算法题4：组合总和

    给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，
    并以列表形式返回。你可以按 任意顺序 返回这些组合。

    candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

    对于给定的输入，保证和为 target 的不同组合数少于 150 个。

*/
class Solution68
{
private:
    /* data */
public:
    Solution68(/* args */);
    ~Solution68();

    vector<vector<int>> combinationSum(vector<int>& candidates, int target);
    void backtracking(vector<int>& candidates, vector<vector<int>> &res, vector<int> &temp, int target, int sum, int index);
};
void Solution68::backtracking(vector<int>& candidates, vector<vector<int>> &res, vector<int> &temp, int target, int sum, int index){
    // if (sum > target)   // 当可以重复选取的时候，必须加入该判断，否则会进入无限循环    若剪枝，则可以不要该判断
    // {
    //     return;
    // }
    

    if (sum == target)
    {
        res.push_back(temp);

        return;
    }
    for (int i = index; i < candidates.size(); i++)
    {   
        cout << index << "..." << endl;     // 这里 index 的值不是很理解，既然没有增减，为啥不能是 0
        // 剪枝   若要加入剪枝，则需要先排序
        if (sum + candidates[i] > target)
        {
            break;
        }

        temp.push_back(candidates[i]);
        sum += candidates[i];
        backtracking(candidates, res, temp, target, sum, i);
        temp.pop_back();
        sum -= candidates[i];
    }
    

}

// 注意这道题，元素是可重复选取的
vector<vector<int>> Solution68::combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> res;

    if (candidates.size() == 0)
    {
        return res;
    }
    
    vector<int> temp;
    sort(candidates.begin(), candidates.end());
    backtracking(candidates, res, temp, target, 0, 0);

    return res;

}
 
Solution68::Solution68(/* args */)
{
}

Solution68::~Solution68()
{
}


// int main(){

//     Solution68 s68;
//     vector<int> candidates = {2, 3, 6, 7};
//     int target = 7;
//     auto res = s68.combinationSum(candidates, target);
//     ShowTowVector(res);
//     return 0;
// }

/*
    回溯算法题5：组合总和2
*/
class Solution69
{
private:
    /* data */
public:
    Solution69(/* args */);
    ~Solution69();

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target);
    void backtracking(vector<int>& candidates, set<vector<int>> &res, vector<int> &temp, int target, int index, int sum);

};
// 因为 candidates 里存在重复元素，所以会出现相同的 temp  所以可以使用 set 去重  
void Solution69::backtracking(vector<int>& candidates, set<vector<int>> &res, vector<int> &temp, int target, int index, int sum){

    if (sum == target)   // 加入剪枝，这里可以少加判断条件
    {   
        res.insert(temp);
        return;
    }
    

    for (int i = index; i < candidates.size(); i++)
    {
        if (sum + candidates[i] > target)
        {
            break;
        }

        if (i > index && candidates[i] == candidates[i - 1]){
            continue;
        }
        temp.push_back(candidates[i]);
        sum += candidates[i];
        backtracking(candidates, res, temp, target, i+1, sum);
        temp.pop_back();
        sum -= candidates[i];
    
    }
    
}

vector<vector<int>> Solution69::combinationSum2(vector<int>& candidates, int target) {
    set<vector<int>> res;
    
    vector<int> temp;
    sort(candidates.begin(), candidates.end());
    backtracking(candidates, res, temp, target, 0, 0);

    vector<vector<int>> result(res.begin(), res.end());

    return result;
}

Solution69::Solution69(/* args */)
{
}

Solution69::~Solution69()
{
}


// int main(){

//     Solution69 s69;
//     vector<int> candidates = {10,1,2,7,6,1,5};
//     int target = 8;
//     auto res = s69.combinationSum2(candidates, target);
//     ShowTowVector(res);
//     return 0;
// }


/*
    回溯算法题6：分割回文串 


    对回溯有了些理解，将回溯和 N 叉树结合便于理解    回溯操作数组   二叉树的递归操作二叉树   如果将二叉树转换成数组，那么就变成了这里的回溯，
    由于二叉树本身的结构性质，因此二叉树的遍历分左右递归（左右子树）  但其实道理都是一样的
*/

class Solution70
{
private:
    /* data */
public:
    Solution70(/* args */);
    ~Solution70();

    vector<vector<string>> partition(string s);
    // 回溯
    void backtracking(vector<vector<string>> &res, vector<string> &temp, string s, int index);
    // 判断字符串是否为回文子串
    bool judge(const string& s, int start, int end);

};


bool Solution70::judge(const string& s, int start, int end){
    for (int i = start, j = end; i < j; i++, j--) {
         if (s[i] != s[j]) {
             return false;
         }
     }
     return true;
}


void Solution70::backtracking(vector<vector<string>> &res, vector<string> &temp, string s, int index){

    if (index >= s.size())   // 这里和组合问题不同  
    {
        res.push_back(temp);
        return;
    }
    
    for (int i = index; i < s.size(); i++) {
        
        cout << index << " index" << " ";
        cout << i << " i" << endl;
        if (judge(s, index, i)) { // 是回文子串
            // 获取[index,i]在s中的子串
            string str = s.substr(index, i - index + 1);
            temp.push_back(str);

        } else {                // 如果不是则直接跳过
            continue;
        }
        backtracking(res, temp, s, i + 1); // 寻找i+1为起始位置的子串
        cout << index << ",,," << endl;
        temp.pop_back();        // 回溯过程，弹出本次已经填在的子串

    }
    
}

vector<vector<string>> Solution70::partition(string s) {
    vector<vector<string>> res;
    vector<string> temp;
    if (s.size() == 1)
    {
        temp.push_back(s);
        res.push_back(temp);
        return res;
    }

    backtracking(res, temp, s, 0);

    return res;
}

Solution70::Solution70(/* args */)
{
}

Solution70::~Solution70()
{
}


// int main(){

//     Solution70 s70;
//     string des = "aab";
//     auto res = s70.partition(des);
//     ShowTowVector<string>(res);
//     return 0;
// }


/*
    回溯算法题7：复原Ip地址
*/
class Solution71
{
private:
    /* data */
public:
    Solution71(/* args */);
    ~Solution71();

    vector<string> restoreIpAddresses(string s);

    void backtracking(vector<string> &res, string& s, int startIndex, int pointNum);

    bool judge(const string &s, int start, int end);
};

bool Solution71::judge(const string &s, int start, int end){
    if (start > end) {
            return false;
    }
    if (s[start] == '0' && start != end) { // 0开头的数字不合法
            return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
            return false;
        }
        num = num * 10 + (s[i] - '0');
        if (num > 255) { // 如果大于255了不合法
            return false;
        }
    }
    return true;

}

// 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
void Solution71::backtracking(vector<string> &res, string& s, int startIndex, int pointNum) {
    if (pointNum == 3) { // 逗点数量为3时，分隔结束
        // 判断第四段子字符串是否合法，如果合法就放进result中
        if (judge(s, startIndex, s.size() - 1)) {
            res.push_back(s);
        }
        return;
    }
    for (int i = startIndex; i < s.size(); i++) {
        if (judge(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
            s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
            pointNum++;
            backtracking(res, s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2
            pointNum--;                         // 回溯
            s.erase(s.begin() + i + 1);         // 回溯删掉逗点
        } else break; // 不合法，直接结束本层循环
    }
}

vector<string> Solution71::restoreIpAddresses(string s) {
    vector<string> res;
    if (s.size() < 4 || s.size() > 12) return res; 

    backtracking(res, s, 0, 0);
    
    return res;

}
Solution71::Solution71(/* args */)
{
}

Solution71::~Solution71()
{
}



// int main(){

//     Solution71 s71;
//     string des = "25525511135";
//     auto res = s71.restoreIpAddresses(des);
//     for (int i = 0; i < res.size(); i++)
//     {
//         cout << res[i] << " ";
//     }
    
//     cout << endl;
//     return 0;
// }



/*
    回溯算法题8：子集问题
*/

class Solution72
{
private:
    /* data */
public:
    Solution72(/* args */);
    ~Solution72();

    vector<vector<int>> subsets(vector<int>& nums);

    void backtracking(vector<int>& nums, vector<vector<int>> &res, vector<int> &temp, int index);
};

void Solution72::backtracking(vector<int>& nums, vector<vector<int>> &res, vector<int> &temp, int index){
    res.push_back(temp);
    if (index >= nums.size())
    {
        return;
    }
    
    for (int i = index; i < nums.size(); i++)
    {   
        // 获得子串
        // 将子串放入 temp
        temp.push_back(nums[i]);
        backtracking(nums, res, temp, i+1);
        temp.pop_back();
    }
    
    return;
}

// 思考：能不能当作切割处理
vector<vector<int>> Solution72::subsets(vector<int>& nums) {

    vector<vector<int>> res;
    vector<int> temp;
    
    backtracking(nums, res, temp, 0);

    return res;
}

Solution72::Solution72(/* args */)
{
}

Solution72::~Solution72()
{
}



// int main(){

//     Solution72 s72;
//     vector<int> des = {1, 2, 3};
//     auto res = s72.subsets(des);
//     ShowTowVector(res);
//     return 0;
// }



/*
    回溯算法题9：子集问题2
*/
class Solution73
{
private:
    /* data */
public:
    Solution73(/* args */);
    ~Solution73();

    vector<vector<int>> subsetsWithDup(vector<int>& nums);

    void backtracking(vector<int>& nums, vector<vector<int>> &res, vector<int> &temp, int index);
};

void Solution73::backtracking(vector<int>& nums, vector<vector<int>> &res, vector<int> &temp, int index){
    res.push_back(temp);
    if (index >= nums.size())
    {
        return;
    }
    
    for (int i = index; i < nums.size(); i++)
    {   
        // 与上一题不同的是，当遇到相同元素，则 continue
        if (i > index && nums[i] == nums[i- 1] )
        {
            continue;
        }
        
        // 获得子串
        // 将子串放入 temp
        temp.push_back(nums[i]);
        backtracking(nums, res, temp, i+1);
        temp.pop_back();
    }
    
    return;

}

vector<vector<int>> Solution73::subsetsWithDup(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> temp;
    int index = 0;
    sort(nums.begin(), nums.end());
    backtracking(nums, res, temp, index);

    return res;

}


Solution73::Solution73(/* args */)
{
}

Solution73::~Solution73()
{
}


// int main(){

// Solution73 s73;
//     vector<int> des = {1, 2, 2};
//     auto res = s73.subsetsWithDup(des);
//     ShowTowVector(res);
//     return 0;
// }

/*
    回溯算法题10：递增子序列                  不能排序！！！
*/
#include<set>
class Solution74
{
private:
    /* data */
public:
    Solution74(/* args */);
    ~Solution74();

    vector<vector<int>> findSubsequences(vector<int>& nums);

    void backtracking(vector<int>& nums, vector<vector<int>> &res, vector<int> &temp, int index, set<vector<int>> &uset);

    // 判断是否递增序列
    bool judge(const vector<int> &v);
};
bool Solution74::judge(const vector<int> &v){

    for (int i = 1; i < v.size(); i++)
    {
        if (v[i] < v[i - 1])
        {
            return false;
        }
        
    }
    
    return true;
}

// 这道题完全可以先排序，达到递增序列条件，再按照上一条求子集问题2的方式进行即可
void Solution74::backtracking(vector<int>& nums, vector<vector<int>> &res, vector<int> &temp, int index, set<vector<int>> &uset){

    if (temp.size() >= 2)   // 当元素大于等于 2 的时候 检查该数组是否递增    需要加入set去重，因为重复元素不一定挨在一起了？（没有排序）
    {   
        if (judge(temp) && uset.find(temp) == uset.end())
        {   
            res.push_back(temp);
        }
        
        if (judge(temp))
        {
            uset.insert(temp);
        }
        
        
    }
    
    if (index >= nums.size())
    {
        return;
    }
    

    for (int i = index; i < nums.size(); i++)
    {
        if (i > index && nums[i] == nums[i - 1]) continue;
        
        temp.push_back(nums[i]);
        backtracking(nums, res, temp, i+1, uset);
        temp.pop_back();
    }
    
}

vector<vector<int>> Solution74::findSubsequences(vector<int>& nums) {

    vector<vector<int>> res;

    vector<int> temp;
    set<vector<int>> uset;
    int index = 0;

    backtracking(nums, res, temp, index, uset);


    return res;

}

Solution74::Solution74(/* args */)
{
}

Solution74::~Solution74()
{
}


// int main(){

// Solution74 s74;
//     vector<int> des = {4, 7, 6, 7};
//     auto res = s74.findSubsequences(des);
//     ShowTowVector(res);
//     return 0;
// }


/*
    回溯算法题10：全排列

    给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
*/

class Solution75
{
private:
    /* data */
public:
    Solution75(/* args */);
    ~Solution75();

    vector<vector<int>> permute(vector<int>& nums);

    void backtracking(vector<int> &nums, vector<vector<int>> &res, vector<int> &temp, vector<bool> &used);
};
// 与组合问题最大的区别是  需要从零开始
void Solution75::backtracking(vector<int> &nums, vector<vector<int>> &res, vector<int> &temp, vector<bool> &used){

    if (temp.size() == nums.size())
    {
        res.push_back(temp);
        return;
    }
    

    for (int i = 0; i < nums.size(); i++)
    {   
        if (used[i])
        {
            continue;
        }
        temp.push_back(nums[i]);
        used[i] = true;
        backtracking(nums, res, temp, used);
        temp.pop_back();
        used[i] = false;
    }
    
}

vector<vector<int>> Solution75::permute(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> temp;
    vector<bool> used(nums.size(), false);

    backtracking(nums, res, temp, used);

    return res;


}

Solution75::Solution75(/* args */)
{
}

Solution75::~Solution75()
{
}



// int main(){

//     Solution75 s75;
//     vector<int> des = {1, 2, 3};
//     auto res = s75.permute(des);
//     ShowTowVector(res);
//     return 0;
// }

/*
    回溯算法题11：全排列2
*/
class Solution76
{
private:
    /* data */
public:
    Solution76(/* args */);
    ~Solution76();

    vector<vector<int>> permuteUnique(vector<int>& nums);

    void backtracking(vector<int> &nums, vector<vector<int>> &res, vector<int> &temp, vector<bool> &used);
};

void Solution76::backtracking(vector<int> &nums, vector<vector<int>> &res, vector<int> &temp, vector<bool> &used){
    if (temp.size() == nums.size())
    {
        res.push_back(temp);
        return;
    }
    

    for (int i = 0; i < nums.size(); i++)
    {   
        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {  // 不好理解    总结：同一树枝上有两个相同元素可以重复选取，同一树层上有两个相同元素不可重复选取
            continue;
        }
        if (used[i] == false)
        {
            temp.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, res, temp, used);
            temp.pop_back();
            used[i] = false;
        }
        
    }


}

vector<vector<int>> Solution76::permuteUnique(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> temp;
    vector<bool> used(nums.size(), false);
    sort(nums.begin(), nums.end());
    backtracking(nums, res, temp, used);

    return res;


}

Solution76::Solution76(/* args */)
{
}

Solution76::~Solution76()
{
}



// int main(){

//     Solution76 s76;
//     vector<int> des = {1, 1, 2};
//     auto res = s76.permuteUnique(des);
//     ShowTowVector(res);
//     return 0;
// }




/*
    贪心算法题1：分发饼干

    假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
    对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，
    都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
    你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

*/

class Solution77
{
private:
    /* data */
public:
    Solution77(/* args */);
    ~Solution77();

    int findContentChildren(vector<int>& g, vector<int>& s);
};

// g 代表胃口   s 代表饼干尺寸   
int Solution77::findContentChildren(vector<int>& g, vector<int>& s) {
    //1、排序后，从后向前遍历 ------> 这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。
    //2、考虑使用双指针 ------> 降低时间复杂度
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());

    int res = 0;
    int index = s.size() - 1;  // 最大一块饼干的索引

    for (int i = g.size() - 1; i >= 0; i--)
    {   
        if (index >= 0 && s[index] >= g[i]) {
            res++;
            index--;
        }
          
    }
    
    return res;

}

Solution77::Solution77(/* args */)
{
}

Solution77::~Solution77()
{
}



// int main(){

//     Solution77 s77;
//     vector<int> g = {1, 2};
//     vector<int> s = {1, 2, 3};
    
//     int res = s77.findContentChildren(g, s);

//     cout << res << endl;
//     return 0;
// }



/*
    贪心算法题2：摆动序列
*/

class Solution78
{
private:
    /* data */
public:
    Solution78(/* args */);
    ~Solution78();

    int wiggleMaxLength(vector<int>& nums);
};

int Solution78::wiggleMaxLength(vector<int>& nums) {
    
    int res = 1;
    if (nums.size() == 1) return res;

    vector<int> record(nums.size() - 1, -1);  // 使用 record 记录上一次查找为正还是负  1 表示正  0 表示负

    if (nums[1] - nums[0] > 0) record[0] = 1;
    if (nums[1] - nums[0] < 0) record[0] = 0;
    
    for (int i = 2; i < nums.size(); i++)
    {
        if ((nums[i] - nums[i - 1] > 0 && record[i - 2] == 0) || (nums[i] - nums[i - 1] < 0 && record[i - 2] == 1))
        {
            res ++;
        }
        if (nums[i] - nums[i - 1] > 0)
        {
            record[i-1] = 1;
        }else if (nums[i] - nums[i - 1] < 0)
        {
            record[i-1] = 0;
        }
    }
    
    return res;
}

Solution78::Solution78(/* args */)
{
}

Solution78::~Solution78()
{
}


// int main(){

//     Solution78 s78;
//     vector<int> des = {0, 0, 0, 0};
    
//     int res = s78.wiggleMaxLength(des);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题3：最大子数组和
*/

class Solution79
{
private:
    /* data */
public:
    Solution79(/* args */);
    ~Solution79();

    int maxSubArray(vector<int>& nums);
};

int Solution79::maxSubArray(vector<int>& nums) {
    int res = INT32_MIN;

    int count = 0;
    for (int i = 0; i < nums.size(); i++)
    {
        count += nums[i];
        if (count > res)
        {
            res = count;
        }
        if (count <= 0) count = 0;
        
    }
    
    return res;
}

Solution79::Solution79(/* args */)
{
}

Solution79::~Solution79()
{
}



// int main(){

//     Solution79 s79;
//     vector<int> des = {-2,1,-3,4,-1,2,1,-5,4};
    
//     int res = s79.maxSubArray(des);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题4：买卖股票的最佳时机

    输入：prices = [7,1,5,3,6,4]
    输出：7
    解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
         随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
        总利润为 4 + 3 = 7 。
*/


class Solution80
{
private:
    /* data */
public:
    Solution80(/* args */);
    ~Solution80();

    int maxProfit(vector<int>& prices);
};

int Solution80::maxProfit(vector<int>& prices) {
    int res = 0;
    for (int i = 1; i < prices.size(); i++)
    {
        res += max(prices[i] - prices[i - 1], 0);
    }
    

    return res;
}

Solution80::Solution80(/* args */)
{
}

Solution80::~Solution80()
{
}


// int main(){

//     Solution80 s80;
//     vector<int> des = {-2,1,-3,4,-1,2,1,-5,4};
    
//     int res = s80.maxProfit(des);

//     cout << res << endl;
//     return 0;
// }

/*
    贪心算法题5：跳跃游戏

    输入：nums = [2,3,1,1,4]
    输出：true
    解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
*/
class Solution81
{
private:
    /* data */
public:
    Solution81(/* args */);
    ~Solution81();

    bool canJump(vector<int>& nums);
};


bool Solution81::canJump(vector<int>& nums) {
    int cover = 0;
    if (nums.size() == 1)
    {
        return true;
    }
    
    for (int i = 0; i <= cover; i++)
    {
        cover = max(i + nums[i], cover);
        if (cover >= nums.size() - 1)
        {
            return true;
        }
        
    }
    
    return false;
}

Solution81::Solution81(/* args */)
{
}

Solution81::~Solution81()
{
}



// int main(){

//     Solution81 s81;
//     vector<int> des = {2, 3, 1, 1, 4};
    
//     bool res = s81.canJump(des);

//     cout << res << endl;
//     return 0;
// }



/*
    贪心算法题6：跳跃游戏2

    
*/
class Solution82
{
private:
    /* data */
public:
    Solution82(/* args */);
    ~Solution82();

    int jump(vector<int>& nums);
};

int Solution82::jump(vector<int>& nums) {
    if (nums.size() == 1)
    {
        return 0;
    }
    

    int res = 0; // 记录步数

    int cur = 0; // 当前最大覆盖范围下标
    int next = 0; // 下一步最大覆盖范围下标

    for (int i = 0; i < nums.size(); i++)
    {
        next = max(nums[i] + i, next); // 更新下一步最大覆盖范围下标
        if (i == cur)
        {
            if (cur != nums.size() - 1)
            {
                
                res ++;
                cur = next;
                if (next >= nums.size() - 1)
                {
                    break;
                }
                
            }else{
                break;
            }
        }
        
    }
    
    return res;
}

Solution82::Solution82(/* args */)
{
}

Solution82::~Solution82()
{
}


// int main(){

//     Solution82 s82;
//     vector<int> des = {2, 3, 1, 1, 4};
    
//     int res = s82.jump(des);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题7：K 次取反后最大化的数组和
*/

class Solution83
{
private:
    /* data */
public:
    Solution83(/* args */);
    ~Solution83();

    int largestSumAfterKNegations(vector<int>& nums, int k);
};

// 写一个按照绝对值从大到小排序的仿函数  
bool sortFunc(int a, int b){

    return abs(a) > abs(b);

}


// 思路  单数就取 负数绝对值最大的   双数就取一个负的绝对值最大的 一个 0   全正数就取最小的数
int Solution83::largestSumAfterKNegations(vector<int>& nums, int k) {
    int res = 0;

    sort(nums.begin(), nums.end(), sortFunc);

    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] < 0 && k > 0)
        {
            nums[i] *= -1;
            k--;
        }
        
    }
    
    if (k > 0 && k % 2 == 1)
    {
        nums[nums.size() - 1] *= -1;
    }

    for(auto i: nums){

        res += i;
    }

    return res;
}
Solution83::Solution83(/* args */)
{
}

Solution83::~Solution83()
{
}


// int main(){

//     Solution83 s83;
//     vector<int> des = {4, 2, 3};
//     int k = 1;
//     int res = s83.largestSumAfterKNegations(des, k);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题8：加油站
*/

class Solution84
{
private:
    /* data */
public:
    Solution84(/* args */);
    ~Solution84();

    int canCompleteCircuit(vector<int>& gas, vector<int>& cost);
};
// 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
// 输出: 3
int Solution84::canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
     int curSum = 0;
    int min = INT_MAX; // 从起点出发，油箱里的油量最小值
    for (int i = 0; i < gas.size(); i++) {
        int rest = gas[i] - cost[i];
        curSum += rest;
        if (curSum < min) {
            min = curSum;
        }
    }
    if (curSum < 0) return -1;  // 情况1
    if (min >= 0) return 0;     // 情况2
                                // 情况3
    for (int i = gas.size() - 1; i >= 0; i--) {
        int rest = gas[i] - cost[i];
        min += rest;
        if (min >= 0) {
            return i;
        }
    }
    return -1;
}

Solution84::Solution84(/* args */)
{
}

Solution84::~Solution84()
{
}


// int main(){

//     Solution84 s84;
//     vector<int> des = {1, 2, 3, 4, 5};
//     vector<int> des2 = {3, 4, 5, 1, 2};

//     int res = s84.canCompleteCircuit(des, des2);

//     cout << res << endl;
//     return 0;
// }



/*
    贪心算法题9：柠檬水找零
*/

class Solution85
{
private:
    /* data */
public:
    Solution85(/* args */);
    ~Solution85();

    bool lemonadeChange(vector<int>& bills);
};

bool Solution85::lemonadeChange(vector<int>& bills) {

    int five = 0, ten = 0, twenty = 0;
    for (int bill : bills) {
        // 情况一
        if (bill == 5) five++;
        // 情况二
        if (bill == 10) {
            if (five <= 0) return false;
            ten++;
            five--;
        }
        // 情况三
        if (bill == 20) {
            // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
            if (five > 0 && ten > 0) {
                five--;
                ten--;
                twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
            } else if (five >= 3) {
                five -= 3;
                twenty++; // 同理，这行代码也可以删了
            } else return false;
        }
    }
    return true;
}

Solution85::Solution85(/* args */)
{
}

Solution85::~Solution85()
{
}



// int main(){

//     Solution85 s85;
//     vector<int> des = {5, 5, 5, 10, 20};

//     int res = s85.lemonadeChange(des);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题10：根据身高重建队列
*/
class Solution86
{
private:
    /* data */
public:
    Solution86(/* args */);
    ~Solution86();

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people);
};

static bool cmp(const vector<int>& a, const vector<int>& b) {
    if (a[0] == b[0]) return a[1] < b[1];
    return a[0] > b[0];
}
vector<vector<int>> Solution86::reconstructQueue(vector<vector<int>>& people) {
    sort (people.begin(), people.end(), cmp);
    vector<vector<int>> que;
    for (int i = 0; i < people.size(); i++) {
        int position = people[i][1];
        que.insert(que.begin() + position, people[i]);
    }
    return que;

}

Solution86::Solution86(/* args */)
{
}

Solution86::~Solution86()
{
}



// int main(){

//     Solution86 s86;
//     vector<vector<int>> des = {{7,0},{4,4},{7,1},{5,0},{6,1},{5,2}};

//     auto res = s86.reconstructQueue(des);

//     ShowTowVector(res);
//     return 0;
// }


/*
    贪心算法题11：用最小数量的剪引爆气球           未解决
*/

class Solution87
{
private:
    /* data */
public:
    Solution87(/* args */);
    ~Solution87();

    int findMinArrowShots(vector<vector<int>>& points);
};

int Solution87::findMinArrowShots(vector<vector<int>>& points) {

    return 0;
}

Solution87::Solution87(/* args */)
{
}

Solution87::~Solution87()
{
}



// int main(){

//     Solution87 s87;
//     vector<vector<int>> des = {{7,0},{4,4},{7,1},{5,0},{6,1},{5,2}};

//     int res = s87.findMinArrowShots(des);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题12：无重叠区间

    输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
    输出: 1
    解释: 移除 [1,3] 后，剩下的区间没有重叠。
*/

class Solution88
{
private:
    /* data */
public:
    Solution88(/* args */);
    ~Solution88();

    int eraseOverlapIntervals(vector<vector<int>>& intervals);
};

// 按照区间右边界排序
bool cmp2(const vector<int>& a, const vector<int>& b) {
    return a[1] < b[1];
}
int Solution88::eraseOverlapIntervals(vector<vector<int>>& intervals) {
    if (intervals.size() == 0) return 0;
    sort(intervals.begin(), intervals.end(), cmp2);
    int count = 1; // 记录非交叉区间的个数
    int end = intervals[0][1]; // 记录区间分割点
    for (int i = 1; i < intervals.size(); i++) {
        if (end <= intervals[i][0]) {
            end = intervals[i][1];
            count++;
        }
    }
    return intervals.size() - count;

}

Solution88::Solution88(/* args */)
{
}

Solution88::~Solution88()
{
}


// int main(){

//     Solution88 s88;
//     vector<vector<int>> des = {{1,2},{2,3},{3,4},{1,3}};

//     int res = s88.eraseOverlapIntervals(des);

//     cout << res << endl;
//     return 0;
// }


/*
    贪心算法题13：划分字母区间

*/

class Solution89
{
private:
    /* data */
public:
    Solution89(/* args */);
    ~Solution89();

    vector<int> partitionLabels(string s);
};

vector<int> Solution89::partitionLabels(string s) {
    vector<int> res;
    
    int hash[27] = {0}; // 初始化数组

    for (int i = 0; i < s.size(); i++)  // 找到了每个字符的最远边际
    {
        hash[s[i] - 'a'] = i;
    }
    int right = 0;
    int left = 0;
    for (int i = 0; i < s.size(); i++)
    {
        right = max(hash[s[i] - 'a'], right);
        if (i == right)
        {
            res.push_back(right - left + 1);
            left = i + 1;
        }
        
    }
    
    return res;
}

Solution89::Solution89(/* args */)
{
}

Solution89::~Solution89()
{
}


// int main(){

//     Solution89 s89;
//     string des = "ababcbacadefegdehijhklij";

//     vector<int> res = s89.partitionLabels(des);

//     for (int i = 0; i < res.size(); i++)
//     {
//         cout << res[i] << endl;
//     }
    
//     return 0;
// }



/*
    贪心算法题14：合并区间

*/
class Solution90
{
private:
    /* data */
public:
    Solution90(/* args */);
    ~Solution90();

    vector<vector<int>> merge(vector<vector<int>>& intervals);
};

vector<vector<int>> Solution90::merge(vector<vector<int>>& intervals) {
    vector<vector<int>> result;
    if (intervals.size() == 0) return result;
    // 排序的参数使用了lambda表达式
    sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0];});

    result.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++) {
        if (result.back()[1] >= intervals[i][0]) { // 合并区间
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        } else {
            result.push_back(intervals[i]);
        }
    }
    return result;


}

Solution90::Solution90(/* args */)
{
}

Solution90::~Solution90()
{
}



// int main(){

//     Solution90 s90;
//     vector<vector<int>> des = {{1,3},{2,6},{8,10},{15,18}};
//     auto res = s90.merge(des);
//     ShowTowVector(res);
    
//     return 0;
// }



/*
    贪心算法题15：合并区间

*/
class Solution91
{
private:
    /* data */
public:
    Solution91(/* args */);
    ~Solution91();

    int monotoneIncreasingDigits(int n);
};


int Solution91::monotoneIncreasingDigits(int n) {
    string strNum = to_string(n);
    // flag用来标记赋值9从哪里开始
    // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
    int flag = strNum.size();
    for (int i = strNum.size() - 1; i > 0; i--) {
        if (strNum[i - 1] > strNum[i] ) {
            flag = i;
            strNum[i - 1]--;
        }
    }
    for (int i = flag; i < strNum.size(); i++) {
        strNum[i] = '9';
    }
    return stoi(strNum);
}

Solution91::Solution91(/* args */)
{
}

Solution91::~Solution91()
{
}


// int main(){

//     Solution91 s91;
//     int des = 10;
//     auto res = s91.monotoneIncreasingDigits(des);
//     cout << res << endl;
    
//     return 0;
// }


/*
    贪心算法题16：买卖股票的最佳时机，含手续费
*/

class Solution92
{
private:
    /* data */
public:
    Solution92(/* args */);
    ~Solution92();

    int maxProfit(vector<int>& prices, int fee);
};

int Solution92::maxProfit(vector<int>& prices, int fee) {
    int result = 0;
    int minPrice = prices[0]; // 记录最低价格
    for (int i = 1; i < prices.size(); i++) {
        // 情况二：相当于买入
        if (prices[i] < minPrice) minPrice = prices[i];

        // 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）
        if (prices[i] >= minPrice && prices[i] <= minPrice + fee) {
            continue;
        }

        // 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出
        if (prices[i] > minPrice + fee) {
            result += prices[i] - minPrice - fee;
            minPrice = prices[i] - fee; // 情况一，这一步很关键
        }
    }
    return result;

}

Solution92::Solution92(/* args */)
{
}

Solution92::~Solution92()
{
}

// int main(){

//     Solution92 s92;
//     vector<int> des = {1, 3, 2, 8, 4, 9};
//     int n = 2;
//     auto res = s92.maxProfit(des, n);
//     cout << res << endl;
    
//     return 0;
// }



/*
    动规是由前一个状态推导出来的，而贪心是局部直接选最优的。

    动态规划算法题1：斐波那契数列
*/


class Solution93
{
private:
    /* data */
public:
    Solution93(/* args */);
    ~Solution93();

    int fib(int n);
};


int Solution93::fib(int n) {

    if (n <= 1) return n;
    
    vector<int> dp(n+1);

    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++)
    {   
       dp[i] = dp[i-1] + dp[i-2];
       cout << dp[i] << endl;
    }


    return dp[n];
}

Solution93::Solution93(/* args */)
{
}

Solution93::~Solution93()
{
}


// int main(){

//     Solution93 s93;

//     int res = s93.fib(4);

//     cout << res << endl;
//     return 0;
// }




/*
    动态规划算法题2：爬楼梯       这道题的本质就是斐波那契数列  dp[i] = dp[i - 1] + dp[i - 2]   i代表第几层楼梯
*/

class Solution94
{
private:
    /* data */
public:
    Solution94(/* args */);
    ~Solution94();

    int climbStairs(int n);
};


int Solution94::climbStairs(int n) {
    // 1、确定递推公式
    // 2、初始化动归数组
    int dp[n+1];
    dp[1] = 1;
    dp[2] = 2;
    // 3、遍历
    for (int i = 3; i <= n; i++)
    {
        dp[i] =  dp[i - 1] + dp[i - 2]; 
    }
    

    return dp[n];

}

Solution94::Solution94(/* args */)
{
}

Solution94::~Solution94()
{
}


// int main(){
//     Solution94 s94;

//     int res = s94.climbStairs(4);
//     cout << res << endl;
//     return 0;
// }




/*
    动态规划算法题3：使用最小花费爬楼梯
*/

class Solution95
{
private:
    /* data */
public:
    Solution95(/* args */);
    ~Solution95();
    
    int minCostClimbingStairs(vector<int>& cost);
};

Solution95::Solution95(/* args */)
{
}

Solution95::~Solution95()
{
}

int Solution95::minCostClimbingStairs(vector<int>& cost) {

    int res = 0;


    int dp[cost.size() + 1];
    dp[0] = 0;
    dp[1] = 0;

    for (int i = 2; i <= cost.size(); i++)
    {
        dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }

    return dp[cost.size()];
}

// int main(){
//     Solution95 s95;
//     // vector<int> cost = {10, 15, 20};
//     vector<int> cost = {1,100,1,1,1,100,1,1,100,1};
//     int res = s95.minCostClimbingStairs(cost);
//     cout << res << endl;
//     return 0;
// }



/*
    动态规划算法题4：不同路径
*/

class Solution96
{
private:
    /* data */
public:
    Solution96(/* args */);
    ~Solution96();

    int uniquePaths(int m, int n);
};

int Solution96::uniquePaths(int m, int n) {

    int dp[m][n];  // dp[m][n] 表示从 0， 0 到 dp[m][n] 的路径个数
    for (int i = 0; i < m; i++) dp[i][0] = 1;    
    for (int j = 0; j < n; j++) dp[0][j] = 1;

    for (int i = 1; i < m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
        
    }
    
    return dp[m-1][n-1];

}

Solution96::Solution96(/* args */)
{
}

Solution96::~Solution96()
{
}




// int main(){
//     Solution96 s96;
//     int m = 3;
//     int n = 7;
//     int res = s96.uniquePaths(m, n);
//     cout << res << endl;
//     return 0;
// }



/*
    动态规划算法题5：不同路径2
*/
class Solution97
{
private:
    /* data */
public:
    Solution97(/* args */);
    ~Solution97();

    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid);
};


int Solution97::uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    int m = obstacleGrid.size();
    int n = obstacleGrid[0].size();
	if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0
            return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;   // 与上一题的唯一区别，遇到障碍物则跳过该路径
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    return dp[m - 1][n - 1];
}

Solution97::Solution97(/* args */)
{
}

Solution97::~Solution97()
{
}

// int main(){
//     Solution97 s97;
//     vector<vector<int>> obstacleGrid = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
//     int res = s97.uniquePathsWithObstacles(obstacleGrid);
//     cout << res << endl;
//     return 0;
// }


/* 
   动态规划算法题6：整数拆分            未解决



   给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

    示例 1:

    输入: n = 2
    输出: 1
    解释: 2 = 1 + 1, 1 × 1 = 1。
    示例 2:

    输入: n = 10
    输出: 36
    解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。


*/

class Solution98
{
private:
    /* data */
public:
    Solution98(/* args */);
    ~Solution98();

    int integerBreak(int n);
};


int Solution98::integerBreak(int n) {
    vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
}
Solution98::Solution98(/* args */)
{
}

Solution98::~Solution98()
{
}



// int main(){


//     Solution98 s98;
    
//     int res = s98.integerBreak(6);


//     cout << res << endl;

//     return 0;
// }


//---------------------------------------------------------------------------------------------------------------------------
// int main(){

    // vector<int> nums = {0,1,2,2,3,0,4,2};
    // int target = 2;

    // Solution2 s;
    // s.removeElement(nums, target);
    // Print<int> (nums);
    


    // Solution3 s3;
    // vector <int> nums3 = {-7,-3,2,3,11};

    // auto res = s3.sortedSquares2(nums3);
    // Print<int> (res);



    // Solution4 s4;
    // int target = 7;
    // vector <int> nums = {2,3,1,2,4,3};

    // auto res = s4.minSubArrayLen(target, nums);
    // cout << "result========================" << endl;
    // cout << res << endl;


    // Solution5 s5;
    // int n = 3;
    // auto res = s5.generateMatrix(n);

    // for (auto i : res)
    // {
    //     for (auto j : i)
    //     {
    //         cout << j << endl;
    //     }
        
    // }


    // #include "Timer.h"

    // {
    // Timer timer;

    // int value = 0;
    // for (int i = 0; i < 10000; i++)
    // {   
    //     value ++;
    // }
    
    // std::cout << value << endl;

    // }

    // ListNode *head = new ListNode(1);
    // int arr[7] = {2, 6, 3, 4, 5, 7};
    // int count = 6;


    // ListNode *temp = head;
    // for (int i = 0; i < count; i++)
    // {   
    //      while (true)
    //     {   
    //         if (temp->next == NULL)
    //         {
    //             temp->next = new ListNode(arr[i]);
    //             break;
    //         }else{
    //             temp = temp->next;
    //         }
    //     }
        
    // }
    // ListNode *temp3 = head;
    // while (temp3 != NULL)
    // {
    //     std:: cout << temp3->val << endl;
    //     temp3 = temp3->next;
        

    // }
    
    // std::cout << "--------------------------------" << endl;
    // Solution6 s6;
    // s6.removeElements(head, 6);

    // ListNode *temp2 = head;
    // while (temp2 != NULL)
    // {
    //     std:: cout << temp2->val << endl;
    //     temp2 = temp2->next;
        

    // }
    
    // delete temp2;


    // MyLinkedList* obj = new MyLinkedList();

    // std::cout << "----------- 1 -------------\n";
    // printLinkedList(obj->getData());

    // int val = 1;
    // obj->addAtHead(val);

    // int val2 = 3;
    // obj->addAtTail(val2);

    // int index2 = 1;
    // int val3 = 2;
    // obj->addAtIndex(index2,val3);
    // std::cout << "------------ 2 ------------\n";
    // printLinkedList(obj->getData());

    // int index = 1;
    // int param_1 = obj->get(index);
    // std::cout << param_1 << endl;

    // obj->deleteAtIndex(1);
    // std::cout << "------------- 3 -----------\n";
    // printLinkedList(obj->getData());
    
    // int param_2 = obj->get(1);
    // std::cout << param_2 << endl;




    // Solution7 s7;

    // printLinkedList(s7.getDate());

    // ListNode* res = s7.reverseList(s7.getDate());

    // printLinkedList(res);



    // Solution8 s8;
    // printLinkedList(s8.setDate());
    // ListNode* res = s8.swapPairs(s8.setDate());
    // printLinkedList(res);



    // Solution9 s9;
    // printLinkedList(s9.getDate());
    // int n = 2;
    // ListNode* res = s9.removeNthFromEnd(s9.getDate(), n);
    // printLinkedList(s9.getDate());



    // Solution10 s10;
    // printPairLinkedList(s10.getData());
    // ListNode* res = s10.getIntersectionNode(s10.getData().first, s10.getData().second);
    // printLinkedList(res);



    // 链表里虚拟头节点  可以大大减少不必要的麻烦
    // Solution11 s11;
    // ListNode* res;
    // res = s11.detectCycle(s11.getData());
    // std::cout << endl;
    // std::cout << res->val << endl;
    


    // Solution12 s12;
    // string s = "anagram";
    // string t = "nagaram";
    // bool res = s12.isAnagram(s, t);
    // std::cout << res << endl;


    // Solution13 s13;
    // vector<int> num1 = {4, 9, 5};
    // vector<int> num2 = {9, 4, 9, 8, 4};
    // auto res = s13.intersection(num1, num2);

    // for (auto i = res.begin(); i != res.end(); i++)
    // {
    //     std::cout << *i << endl;
    // }
    


    // Solution14 s14;
    // int des = 7;
    // bool res = s14.isHappy(des);
    // cout << res << endl;



    // Solution15 s15;
    // vector<int> v1 = {1, 2};
    // vector<int> v2 = {-2, -1};
    // vector<int> v3 = {-1, 2};
    // vector<int> v4 = {0, 2};

    // int res = s15.fourSumCount(v1, v2, v3, v4);
    // cout << res << endl;



    // Solution16 s16;
    // string ransomNote = "bg";
    // string magazine = "efjbdfbdgfjhhaiigfhbaejahgfbbgbjagbddfgdiaigdadhcfcj";
    // bool  res = s16.canConstruct(ransomNote, magazine);
    // cout << res << endl; // 1



    // Solution17 s17;
    // // vector<int> des = {-1,0,1,2,-1,-4};
    // vector<int> des = {-1,0,1,2,-1,-4};
    // vector<vector<int>> res = s17.threeSum2(des);
    // for(auto out : res){

    //     for(auto  in: out){

    //         cout << in << " ";
    //     }
    //     cout << endl;
    // }



    // Solution18 s18;
    // // vector<int> des = {1, 0, -1, 0, -2, 2};
    // vector<int> des = {1000000000,1000000000,1000000000,1000000000};
    // int target = 0;
    // vector<vector<int>> res = s18.fourSum(des, target);
    // for(auto out : res){

    //     for(auto  in: out){

    //         cout << in << " ";
    //     }
    //     cout << endl;
    // }



    // Solution19 s19;
    // vector<char> des = {'h','e','l','l','o'};
    // s19.reverseString(des);



    // Solution20 s20;
    // string des = "krmyfshbspcgtesxnnljhfursyissjnsocgdhgfxubewllxzqhpasguvlrxtkgatzfybprfmmfithphckksnvjkcvnsqgsgosfxc";
    // // string des = "abcd";
    // int target = 20;
    // string res;
    // res = s20.reverseStr(des, target);
    // cout << res << endl;



    // Solution21 s21;
    // string des = "We are happy.";
    // string res = s21.replaceSpace(des);
    // cout << res << endl;



    // Solution22 s22;
    // string des = "  hello world  ";
    // string res = s22.reverseWords(des);
    // cout << res << endl;



    // Solution23 s23;
    // string des = "lrloseumgh";
    // int n = 6;
    // string res = s23.reverseLeftWords(des, n);
    // cout << res << endl;



    // Solution24 s24;
    // string des1 = "aabaabaafa";
    // string des2 = "aabaaf";

    // int res = s24.strStr(des1, des2);
    // cout << res << endl;



    // Solution25 s25;
    // string des = "abababad";
    // bool res = s25.repeatedSubstringPattern1(des);
    // bool res2 = s25.repeatedSubstringPattern2(des);
    // cout << res << endl; 
    // cout << res2 << endl; 



    // Solution27 s27;
    // string des = "We are happy.";
    // string res = s27.replaceSpace(des);
    // cout << res << endl;



    // Solution29* obj = new Solution29();
    // obj->push(x);
    // int param_2 = obj->pop();
    // int param_3 = obj->peek();
    // bool param_4 = obj->empty();
    
    // cout << param_2 << endl;
    // cout << param_3 << endl;
    // cout << param_4 << endl;



    // Solution30* obj = new Solution30();
    // obj->push(3);
    // int param_2 = obj->pop();
    // int param_3 = obj->top();
    // bool param_4 = obj->empty();
    // cout << param_2 << endl;
    // cout << param_3 << endl;
    // cout << param_4 << endl;



    // Solution31 s31;
    // string des = "()[]{}";
    // bool res = s31.isValid(des);
    // cout << res << endl;
    // Solution32 s32;
    // string des = "abbaca";
    // string res = s32.removeDuplicates(des);
    // cout << res << endl;



    // Solution33 s33;
    // vector<string> des = {"4","13","5","/","+"};
    // int res = s33.evalRPN(des);
    // cout << res << endl;



    // Solution34 s34;
    // vector<int> des = {1,3,-1,-3,5,3,6,7};
    // // vector<int> des = {1,-1};
    // // vector<int> des = {1,3,1,2,0,5};
    // int k = 3;
    // auto res = s34.maxSlidingWindow(des, k);
    
    // for(auto i: res){
    //     cout << i << endl;
    // }



    // Solution35 s35;
    // vector<int> des = {1,1,1,2,2,3};
    // int k = 2;
    // auto res = s35.topKFrequent(des, k);
    // for(auto i: res){
    //     cout << i << endl;
    // }


    // Solution53 s53;
    // Solution39 s39;
    // auto res = s53.mergeTrees(s53.root1, s53.root2);



    // // 层序遍历二叉树
    // auto res2 = s39.levelOrder(res);
    // ShowTowVector(res2);


    // return 0;
// }


// demo03.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <optional>

/*
    代码随想录之-动态规划
*/


/*
    动态规划题7：不同的二叉搜索树


*/

class Solution99
{
public:
	Solution99()
	{
	}
	int numTrees(int n);
	~Solution99()
	{
	}

private:

};

int Solution99::numTrees(int n)
{
	std::vector <int> dp(n + 1);
	dp[0] = 1;
	for (int i = 1; i <= n;i++)
	{
		for (int j = 1; j <= i; j++)
		{
			dp[i] += dp[j - 1] * dp[i - j];
		}
	}

	return dp[n];
}
/*
	动态规划：0/1背包问题                
	
	对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包

	递推公式：
	当前承重量的背包最大容纳价值 = 
	max(腾出新物品空位后的背包承重量最大价值 + 新物品的价值，不加入新物品的最大价值)
	即 与 该元素    “上方 或者 左方+该加入后价值”  相比较大小
*/

// 经典背包问题
class Solution100
{
public:
	Solution100();
	~Solution100();

	int getMaxValue(std::vector<int>& products, std::vector<int>& values, int V);
private:

};

Solution100::Solution100()
{
}

Solution100::~Solution100()
{
}

int Solution100::getMaxValue(std::vector<int>& products, std::vector<int>& values, int V)
{
	int maxValue = 0;

	// dp[i][j] 二维数组表示    行为物体重量，列为背包容量   先遍历物体重量，后遍历背包重量
	// 初始化
	std::vector < std::vector<int>> dp(products.size(), std::vector<int>(V + 1, 0));
	for (int i = 1; i < V + 1 ; i++)
	{
		if (products[0] <= i) {
			dp[0][i] = values[0];
		}
	}

	for (int i = 0; i < dp.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			std::cout << dp[i][j] << " ";
		}
		std::cout  << std::endl;
	}
	std::cout << "---------------------" << std::endl;
	// 开始遍历
	for (int i = 1; i < products.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			if (products[i] > j) {
				dp[i][j] = dp[i - 1][j];
			}
			else {
				dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - products[i]] + values[i]);
			}
		}
	}
	
	for (int i = 0; i < dp.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			std::cout << dp[i][j] << " ";
		}
		std::cout << std::endl;
	}
	return 0;
}

/*
	动态规划题8：分割等和子集

	给你一个 只包含正整数 的 非空 数组 nums 。
	请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
*/

class Solution101
{
public:
	Solution101();
	~Solution101();
	bool canPartition(std::vector<int>& nums);
private:

};

Solution101::Solution101()
{
}

Solution101::~Solution101()
{
}

/*
	思路：将其分为两个子集的话，两个子集的数值相等，平均分,个数不限
	注意：此题个数不限
	行 为从小到大排列的集合元素值，
	列 背包容量递增序列，
	背包容量为 nums.sum / 2 
*/
bool Solution101::canPartition(std::vector<int>& nums)
{
	std::sort(nums.begin(), nums.end());

	// 计算背包容量
	int V = 0;
	for (int i = 0; i < nums.size(); i++)
	{
		V += nums[i];
	}

	if (V % 2 == 1)
	{
		return false;
	}
	V /= 2;
	
	std::vector < std::vector<int>> dp(nums.size(), std::vector<int>(V + 1, 0));
	
	
	// 初始化  
	for (int i = 1; i < V + 1; i++)
	{
		if (nums[0] <= i)
		{
			dp[0][i] = nums[0];
		}
	}
	//背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值,当价值刚好等于容量，则完成分割
	// 所以最终的找到的值应该是最后一列等于容量的那个值，其中分割的元素就是那一列对应的行
	// 遍历
	for (int i = 1; i < nums.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			if (nums[i] > j )
			{
				dp[i][j] = dp[i - 1][j];
			}
			else {
				dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
				if (dp[i][j] == V)
				{	
					for (int i = 0; i < dp.size(); i++)
					{
						for (int j = 0; j < dp[i].size(); j++) {
							std::cout << dp[i][j] << " ";
						}
						std::cout << std::endl;
					}
					return true;
				}
			}
		}
	}
	
	for (int i = 0; i < dp.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			std::cout << dp[i][j] << " ";
		}
		std::cout << std::endl;
	}

	return false;
}

/*
	动态规划题9：最后一块石头的重量2
*/

class Solution102
{
public:
	Solution102()
	{
	}

	~Solution102()
	{
	}
	int lastStoneWeightII(std::vector<int>& stones);

private:

};

/*
	本题其实就是 "尽量" 让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。
 
	想到这一点，那么此题就和上题一个思路了。
*/
int Solution102::lastStoneWeightII(std::vector<int>& stones) {

	//std::sort(stones.begin(), stones.end(), [](int a, int b) { return a < b;});
	//std::sort(stones.begin(), stones.end());   // 不用排序
	// 容量
	int V = 0;

	int sum = 0;
	for (int v : stones) {
		V += v;
	}
	sum = V;
	double S = ((double) V) / 2;
	
	V /= 2;

	// 构造dp数组
	std::vector<std::vector<int>> dp(stones.size(), std::vector<int>(V + 1, 0));

	// 初始化
	for (int i = 0; i < V + 1; i++)
	{
		if (stones[0] <= i) {
			dp[0][i] = stones[0];
		}
	}

	// 遍历
	for (int i = 1; i < stones.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			if (stones[i] > j)
			{
				dp[i][j] = dp[i - 1][j];
			}
			else {
				dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);
			}
		}
	}
	
	for (int i = 0; i < dp.size(); i++)
	{
		for (int j = 0; j < dp[i].size(); j++) {
			std::cout << dp[i][j] << " ";
		}
		std::cout << std::endl;
	}

	return sum - dp[stones.size() - 1][V] - dp[stones.size() - 1][V];  // 注意这里  
}


/*
	动态规划题10：目标和
*/
class Solution103
{
public:
	Solution103()
	{
	}

	~Solution103()
	{
	}

	int findTargetSumWays(std::vector<int>& nums, int target);
	int findTargetSumWays2(std::vector<int>& nums, int target);
	void backtracking(std::vector<int>& nums, int target, std::vector<std::vector<int>>& res, std::vector<int>& temp, int index, int sum);

private:

};

/*
	思路：
	
	两个方法：
	1、回溯
	2、动态规划
*/


void Solution103::backtracking(std::vector<int>& nums, int target, std::vector<std::vector<int>>& res, std::vector<int>& temp, int index, int sum) {


}

// 1、回溯       未实现
int Solution103::findTargetSumWays(std::vector<int>& nums, int target) {
	int result = 0;
	return result;
}

// 2、动态规划
int Solution103::findTargetSumWays2(std::vector<int>& nums, int target) {
	//1、计算出容量
	int sum = 0;
	for (int i = 0; i < nums.size(); i++)
	{
		sum += nums[i];
	}
	// 2、排除极端情况
	if ((sum + target) % 2 != 0 || sum < abs(target))
	{
		return 0;
	}
	// 3、初始化背包容量
	int bagpack = (sum + target) / 2;

	// 4、使用一维数组构建dp
	std::vector<int> dp(bagpack + 1, 0);
	
	//5、初始化dp
	dp[0] = 1;

	//6、遍历dp
	for (int i = 0; i < nums.size(); i++)
	{
		for (int j = bagpack; j >= nums[i]; j--) {
			dp[j] += dp[j - nums[i]];
		}
	}
	
	//7、得出结果
	return dp[bagpack];
}


/*
	动态规划题11：一和零
*/

class Solution104
{
public:
	Solution104()
	{
	}

	~Solution104()
	{
	}

	int findMaxForm(std::vector<std::string>& strs, int m, int n);
private:

};

int Solution104::findMaxForm(std::vector<std::string>& strs, int m, int n) {

	// 1、计算容量    m , n  两个背包

	// 2、构建dp数组
	std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

	for (std::string str : strs) {

		int zeronum = 0;
		int onenum = 0;
		for (int i = 0; i < str.size(); i++)
		{
			if (str[i] == '0') {
				zeronum++;
			}
			else
			{
				onenum++;
			}
		}


		for (int i = m; i >= zeronum; i--)
		{
			for (int j = n; j >=  onenum; j--) {
				dp[i][j] = std::max(dp[i][j], dp[i - zeronum][j - onenum] + 1);
			}
		}

	}
	return dp[m][n];

}

/*
	动态规划题12：零钱兑换2

*/
class Solution105
{
public:
	Solution105()
	{
	}

	~Solution105()
	{
	}

	int change(int amount, std::vector<int>& coins);

	int change2(int amount, std::vector<int>& coins);

	void backtracking(std::vector<std::vector<int>>& res, std::vector<int>& temp, int sum, int index, int target
		, std::vector<int>& nums);
private:

};

/*
	思路：这道题就是组合问题，可以使用回溯做，也可以使用动态规划去做     不过这道题使用回溯算法会超时
*/
void Solution105::backtracking(std::vector<std::vector<int>>& res, std::vector<int>& temp, 
	int sum, int index, int target, std::vector<int> &nums) {
	if (sum == target)
	{
		res.push_back(temp);

		for (int i = 0; i < temp.size(); i++)
		{
			std::cout << temp[i] << " ";
		}
		std::cout << std::endl;

		return;
	}

	for (int i = index; i < nums.size(); i++)
	{	
		// 剪枝   若要加入剪枝，则需要先排序
		if (sum + nums[i] > target)
		{
			break;
		}
		sum += nums[i];
		temp.push_back(nums[i]);
		backtracking(res, temp, sum, i, target, nums);
		sum -= nums[i];
		temp.pop_back();
	}
}

int Solution105::change2(int amount, std::vector<int>& coins) {
	std::vector<std::vector<int>> res;
	std::vector<int> temp;
	std::sort(coins.begin(), coins.end());
	backtracking(res, temp, 0, 0, amount, coins);

	return res.size();
}

//1、背包容量：amount     遍历数组 nums
// 这道题不同与01背包问题，物品可以无限制选取， 即完全背包问题
int Solution105::change(int amount, std::vector<int>& coins) {
	
	std::vector<int>dp (amount + 1, 0);
	dp[0] = 1;

	for (int i = 0; i < coins.size(); i++)
	{
		for (int j = coins[i]; j <= amount; j++) {
			dp[j] += dp[j - coins[i]];
		}
	}

	return dp[amount];
}

/*
	动态规划题13：组合总和4       排列问题
*/
class Solution106
{
public:
	Solution106()
	{
	}

	~Solution106()
	{
	}

	int combinationSum4(std::vector<int>& nums, int target);
private:

};

int Solution106::combinationSum4(std::vector<int>& nums, int target) {
	std::vector<int> dp(target + 1, 0);
	dp[0] = 1;
	for (int j = 0; j <= target; j++)
	{
		for (int i = 0; i < nums.size(); i++) {
			if (j - nums[i] >= 0 && dp[i] < INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]];
		}
	}

	return dp[target];
}


/*
	动态规划题14：爬楼梯进阶版
*/
class Solution107
{
public:
	Solution107()
	{
	}

	~Solution107()
	{
	}

	int climbStairs(int n);
private:

};
// 进阶版可以看成排列问题，和上一题一样   nums.size = 2;    1  2
int Solution107::climbStairs(int n) {
	std::vector<int> dp(n + 1, 0);
	dp[0] = 1;
	std::vector<int> nums = { 1, 2 };

	for (int i = 0; i <= n; i++)
	{
		for (int j = 0; j < nums.size(); j++) {
			if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]])
			{
				dp[i] += dp[i - nums[j]];
			}
		}
	}
	
	return dp[n];
}

#include <algorithm>
/*
	动态规划题15：零钱兑换
*/

class Solution108
{
public:
	Solution108()
	{
	}

	~Solution108()
	{
	}

	int coinChange(std::vector<int>& coins, int amount);
private:

};


// 和组合问题的区别在于 选取的硬币“个数最少，达到目标值”
//dp[j]：凑足总额为j所需钱币的最少个数为dp[j]
//本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序
int Solution108::coinChange(std::vector<int>& coins, int amount) {

	std::vector<int> dp(amount + 1, INT_MAX);
	dp[0] = 0;
	for (int i = 1; i <= amount; i++)
	{
		for (int j = 0; j < coins.size(); j++) {
			if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX)
			{
				dp[i] = std::min(dp[i - coins[j]] + 1, dp[i]);
				std::cout << dp[i] << std::endl;
			}
		} 
	}
	if (dp[amount] == INT_MAX) return -1;
	return dp[amount];
}

/*
	动态规划题16：完全平方数
*/
class Solution109
{
public:
	Solution109()
	{
	}

	~Solution109()
	{
	}
	
	int numSquares(int n);
private:

};

/*
	给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
	完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。
	例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

	输入：n = 12
	输出：3
	解释：12 = 4 + 4 + 4
*/
// 完全背包问题 背包容量为12
int Solution109::numSquares(int n) {

	std::vector<int> dp(n + 1, INT_MAX);
	dp[0] = 0; // 无意义，因为题目要求 n >= 1
	for (int i = 1; i <=n; i++) // 遍历背包
	{
		for (int j = 1; j * j <= i; j++) {  // 遍历物品
			dp[i] = std::min(dp[i - j * j] + 1, dp[i]);
		}
	}

	return dp[n];
}


/*
	动态规划题17：单词拆分
*/

class Solution110
{
public:
	Solution110()
	{
	}

	~Solution110()
	{
	}

	bool wordBreak(std::string s, std::vector<std::string>& wordDict);
private:

};

/*
	将字典里的子串当成物品，并且可以重复利用
	将目标字符串当成背包
*/
#include<unordered_set>
bool Solution110::wordBreak(std::string s, std::vector<std::string>& wordDict) {
	std::vector<bool> dp(s.size() + 1, false);
	std::unordered_set<std::string> wordSet(wordDict.begin(), wordDict.end());
	dp[0] = true;

	for (int i = 1; i <= s.size(); i++)
	{
		for (int j = 0; j < i; j++) {
			std::string word = s.substr(j, i - j);
			if (wordSet.find(word) != wordSet.end() && dp[j])
			{
				dp[i] = true;
			}
		}
	}

	return dp[s.size()];
}

/*
	动态规划题18：打家劫舍
*/
class Solution111
{
public:
	Solution111()
	{
	}

	~Solution111()
	{
	}

	int rob(std::vector<int>& nums);
private:

};

int Solution111::rob(std::vector<int>& nums) {
	// 确定dp数组下标即dp[i]的含义  
	// i 代表打劫第几家，dp[i] 代表打劫 到第i家时获取的资金
	if (nums.size() == 0)
	{
		return 0;
	}
	if (nums.size() == 1)
	{
		return nums[0];
	}

	std::vector<int> dp(nums.size());
	dp[0] = nums[0];
	dp[1] = std::max(nums[0], nums[1]);

	for (int i = 2; i < nums.size(); i++)
	{
		dp[i] = std::max(dp[i - 2] + nums[i], dp[i - 1]);
	}

	return dp[nums.size() - 1];
}

/*
	动态规划题19：打家劫舍2
*/

class Solution112
{
public:
	Solution112()
	{
	}

	~Solution112()
	{
	}

	int rob(std::vector<int>& nums);

	int robRange(const std::vector<int>& nums, int start, int end);
private:

};


// 这道题与上一道题的区别是 该题是环状   首尾两家相连
// 多了两个逻辑
int Solution112::robRange(const std::vector<int>& nums, int start, int end) {
	if (end == start) return nums[start];
	std::vector<int> dp(nums.size());
	dp[start] = nums[start];
	dp[start + 1] = std::max(nums[start], nums[start + 1]);

	for (int i = start + 2; i <= end; i++)
	{
		dp[i] = std::max(dp[i - 2] + nums[i], dp[i - 1]);
	}

	return dp[end];
}

int Solution112::rob(std::vector<int>& nums) {

	if (nums.size() == 0)
	{
		return 0;
	}
	if (nums.size() == 1)
	{
		return nums[0];
	}

	int resultFornt = robRange(nums, 0, nums.size() - 2);
	int resultRear = robRange(nums, 1, nums.size() - 1);

	return fmax(resultFornt, resultRear);
}

/*
	动态规划题20：打家劫舍3
*/

struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Solution113
{
public:
	Solution113()
	{
	}

	~Solution113()
	{
	}

	int rob(TreeNode* root);

	std::vector<int> robTree(TreeNode *cur);
private:

};

// 本题考察 树形dp     递归三部曲 + 动规五部曲
// 1、确定递归参数及返回值类型
std::vector<int> Solution113::robTree(TreeNode* cur) {
	// 2、递归终止条件
	if (cur == NULL) return std::vector<int>{0, 0};    // dp数组就体现在返回的vector中
	// 3、开始递归
	std::vector<int> left = robTree(cur->left);
	std::vector<int> right = robTree(cur->right);

	// 后序遍历处理节点
	// 情况一：不偷                     （不偷 0  偷 1）
	int val1 = fmax(left[0], left[1]) + fmax(right[0], right[1]);     // 这里为什么要后序遍历   因为偷与不偷 依赖子节点的值
																						// 需要先拿到子节点的值，才能比较偷与不偷
	// 情况二： 偷
	int val2 = cur->val + left[0] + right[0];

	return { val1, val2 };
}

int Solution113::rob(TreeNode*root) {

	std::vector<int> result = robTree(root);
	return fmax(result[0], result[1]);
}

/*
	动态规划题21：买卖股票的最佳时机
*/
class Solution114
{
public:
	Solution114()
	{
	}

	~Solution114()
	{
	}

	int maxProfit(std::vector<int>& prices);
	int maxProfit2(std::vector<int>& prices);
private:

};
// 本提可以使用贪心，也可以使用动态规划
//1、贪心   时间复杂度 n
int Solution114::maxProfit2(std::vector<int>& prices) {
	int result = 0;
	int low = INT_MAX;

	for (int i = 0; i < prices.size(); i++)
	{
		low = fmin(low, prices[i]);  // 一直指向最小值
		result = fmax(result, prices[i] - low); // 一直指向最大值
	}

	return result;
}
//2、动态规划   动规五部曲
int Solution114::maxProfit(std::vector<int>& prices) {

	// 1、确定dp及其下标含义
	// dp[i][0] 表示第 i 天持有股票所得最多现金     dp[i][1] 表示第 i 不持有股票所得最多现金
	std::vector<std::vector<int>> dp(prices.size(), std::vector<int>(2));
	// 2、确定递推公式    dp[i][0] 分为第 i 天之前就买入 还是当天买入    dp[i][1]  分为第 i 天之前就卖出 还是当天卖出
	// dp[i][0] = fmax(dp[i - 1][0], -prices[i])     dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i])
	// 3、初始化dp    根据递推公式初始化 dp[0][0]   dp[0][1]
	dp[0][0] = -prices[0];
	dp[0][1] = 0;
	// 4、确定遍历顺序   i 状态依赖于 i - 1  ， 从前往后遍历
	for (int i = 1; i < prices.size(); i++)
	{
		dp[i][0] = fmax(dp[i - 1][0], -prices[i]);
		dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i]);
	}
	// 5、举例推导出返回值
	return dp[prices.size() - 1][1];
}

/*
	动态规划题22：买卖股票的最佳时机2
*/
class Solution115
{
public:
	Solution115()
	{
	}

	~Solution115()
	{
	}

	int maxProfit(std::vector<int>& prices);

private:

};
// 这道题可以用贪心求解，也可以使用动态规划求解                  注意！！！此题可以在某天既不买入又不卖出
int Solution115::maxProfit(std::vector<int>& prices) {
	// 1、确定dp及其下标含义
	// dp[i][0] 表示第 i 天持有股票最多现金    dp[i][1] 表示第 i 天不持有股票最多现金
	std::vector<std::vector<int>> dp(prices.size(), std::vector<int>(2));
	// 2、确定递推公式
	// dp[i][0]  第 i - 1 天不持有股票 - prices[i]     dp[i][1]  第 i - 1 天持有 + prices[i]
	/*dp[i][0] = fmax(dp[i - 1][0], dp[i - 1][1] - prices[i]);
	dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i]);*/
	// 3、初始化dp                           
	dp[0][0] = -prices[0];
	dp[0][1] = 0;
	// 4、确定遍历顺序   顺序遍历
	for (int i = 1; i < prices.size(); i++)
	{
		dp[i][0] = fmax(dp[i - 1][0], dp[i - 1][1] - prices[i]);
		dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i]);
	}

	// 5、举例确定返回值

	return dp[prices.size() - 1][1];
}


/*
	动态规划题23：买卖股票的最佳时机含冷冻期
*/

class Solution116
{
public:
	Solution116()
	{
	}

	~Solution116()
	{
	}

	int maxProfit(std::vector<int>& prices);
private:

};

// 利用可变参数，实现求最大值
template<typename T>
T maxele(T a)
{
	return a;
}

template<typename T, typename... Args>
T maxele(T a, Args... arg)
{
	return std::max(a, maxele(arg...));
}


int Solution116::maxProfit(std::vector<int>& prices) {

	int n = prices.size();
	if (n == 0) return 0;
	std::vector<std::vector<int>> dp(n, std::vector<int>(4, 0));
	dp[0][0] -= prices[0]; // 持股票
	for (int i = 1; i < n; i++) {
		dp[i][0] = maxele(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);
		dp[i][1] = maxele(dp[i - 1][1], dp[i - 1][3]);
		dp[i][2] = dp[i - 1][0] + prices[i];
		dp[i][3] = dp[i - 1][2];
	}
	return maxele(dp[n - 1][3], dp[n - 1][1], dp[n - 1][2]);
}

/*
	动态规划题24：买卖股票的最佳时机含手续费
*/
class Solution117
{
public:
	Solution117()
	{
	}

	~Solution117()
	{
	}

	int maxProfit(std::vector<int>& prices, int fee);
private:

};
//本题和动态规划：买卖股票的最佳时机2的区别就是这里需要多一个减去手续费的操作。
int Solution117::maxProfit(std::vector<int>& prices, int fee) {
	// 1、确定dp及其下标含义
	// dp[i][0] 表示第 i 天持有股票最多现金    dp[i][1] 表示第 i 天不持有股票最多现金
	std::vector<std::vector<int>> dp(prices.size(), std::vector<int>(2));
	// 2、确定递推公式
	// dp[i][0]  第 i - 1 天不持有股票 - prices[i]     dp[i][1]  第 i - 1 天持有 + prices[i]
	/*dp[i][0] = fmax(dp[i - 1][0], dp[i - 1][1] - prices[i]);
	dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i]);*/
	// 3、初始化dp                           
	dp[0][0] = -prices[0];
	dp[0][1] = 0;
	// 4、确定遍历顺序   顺序遍历
	for (int i = 1; i < prices.size(); i++)
	{
		dp[i][0] = fmax(dp[i - 1][0], dp[i - 1][1] - prices[i]);
		dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
	}
	// 5、举例确定返回值
	return dp[prices.size() - 1][1];
}

/*
	动态规划题25：最长递增子序列  （最长不连续递增序列）
*/
class Solution118
{
public:
	Solution118()
	{
	}

	~Solution118()
	{
	}

	int lengthOfLIS(std::vector<int>& nums);
private:

};

int Solution118::lengthOfLIS(std::vector<int>& nums) {
	std::vector<int> dp(nums.size(), 1);
	int result = 0;

	for (int i = 1; i < nums.size(); i++)
	{
		for (int j = 0; j < i; j++) {
			if (nums[i] > nums[j])
			{
				dp[i] = std::max(dp[i], dp[j] + 1);
			}
		}
		if (result < dp[i])
		{
			result = dp[i];
		}
	}
	return result;
}

/*
	动态规划题26：最长递增子序列  （最长连续递增序列）
*/
class Solution119
{
public:
	Solution119()
	{
	}

	~Solution119()
	{
	}

	int findLengthOfLCIS(std::vector<int>& nums);
private:

};
// 与上一题不同的是，该题是最长“连续”递增子序列
int Solution119::findLengthOfLCIS(std::vector<int>& nums) {
	if (nums.size() == 1) return 1;
	std::vector<int> dp(nums.size(), 1);
	int result = 0;

	for (int i = 1; i < nums.size(); i++)
	{
		for (int j = 0; j < i; j++) {
			if ((nums[i] > nums[j]) && (j + 1 == i))
			{
				dp[i] = std::max(dp[i], dp[j] + 1);
			}

		}
		if (result < dp[i])
		{
			result = dp[i];
		}
	}
	return result;
}

/*
	动态规划题27：最长重复子数组
*/
class Solution120
{
public:
	Solution120()
	{
	}

	~Solution120()
	{
	}

	int findLength(std::vector<int>& nums1, std::vector<int>& nums2);

private:

};
// 注意：这里的最长重复子数组，必须是连续的情况
int Solution120::findLength(std::vector<int>& nums1, std::vector<int>& nums2) {

	std::vector<std::vector<int>> dp(nums1.size() + 1, std::vector<int>(nums2.size() + 1, 0));
	int result = 0;

	for (int i = 1; i <= nums1.size(); i++)
	{
		for (int j = 1; j <= nums2.size(); j++) {
			if (nums1[i - 1] == nums2[j - 1])
			{
				dp[i][j] = dp[i - 1][j - 1] + 1;
			}
			if (result < dp[i][j])
			{
				result = dp[i][j];
			}
		}
	}
	return result;
}

/*
	动态规划题28：最长公共子序列
*/
class Solution121
{
public:
	Solution121()
	{
	}

	~Solution121()
	{
	}

	int longestCommonSubsequence(std::string text1, std::string text2);
private:

};
// 注意：这里的最长公共子序列，可以不连续的情况，这和上题的区别就在这里
int Solution121::longestCommonSubsequence(std::string text1, std::string text2) {
	std::vector<std::vector<int>> dp(text1.size() + 1, std::vector<int>(text2.size() + 1, 0));

	int result = 0;
	for (int i = 1; i <= text1.size(); i++)
	{
		for (int j = 1; j <= text2.size(); j++) {
			// 分为两种情况：当前元素相等，当前元素不等
			// 当前元素相等时：dp[i][j] = dp[i - 1][j - 1] + 1    当前元素不等时，dp[i][j] = dp[i - 1][j - 1]
			if (text1[i - 1] == text2[j - 1])
			{
				dp[i][j] = dp[i - 1][j - 1] + 1;
			}
			else {
				dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
			}
			if (result < dp[i][j])
			{
				result = dp[i][j];
			}
		}
	}
	return result;
}

/*
	动态规划题29：不相交的线
*/
class Solution122
{
public:
	Solution122()
	{
	}

	~Solution122()
	{
	}

	int maxUncrossedLines(std::vector<int>& nums1, std::vector<int>& nums2);
private:

};

int Solution122::maxUncrossedLines(std::vector<int>& nums1, std::vector<int>& nums2) {
	std::vector<std::vector<int>> dp(nums1.size() + 1, std::vector<int>(nums2.size() + 1, 0));

	int result = 0;
	for (int i = 1; i <= nums1.size(); i++)
	{
		for (int j = 1; j <= nums2.size(); j++) {
			// 分为两种情况：当前元素相等，当前元素不等
			// 当前元素相等时：dp[i][j] = dp[i - 1][j - 1] + 1    当前元素不等时，dp[i][j] = dp[i - 1][j - 1]
			if (nums1[i - 1] == nums2[j - 1])
			{
				dp[i][j] = dp[i - 1][j - 1] + 1;
			}
			else {
				dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
			}
			if (result < dp[i][j])
			{
				result = dp[i][j];
			}
		}
	}
	return result;
}

/*
	动态规划题30：最大子数组和
*/
class Solution123
{
public:
	Solution123()
	{
	}

	~Solution123()
	{
	}

	int maxSubArray(std::vector<int>& nums);
private:

};
// 注意：连续子数组  可以使用贪心  也可以使用动归
int Solution123::maxSubArray(std::vector<int>& nums) {
	if (nums.size() == 0)
	{
		return 0;
	}
	std::vector<int> dp(nums.size());
	dp[0] = nums[0];
	int result = nums[0];
	for (int i = 1; i < nums.size(); i++)
	{
		dp[i] = std::max(dp[i - 1] + nums[i], nums[i]);
		if (result < dp[i])
		{
			result = dp[i];
		}
	}
	return result;
}

/*
	动态规划题31：判断子序列
*/
class Solution124
{
public:
	Solution124()
	{
	}

	~Solution124()
	{
	}

	bool isSubsequence(std::string s, std::string t);
private:

};

bool Solution124::isSubsequence(std::string s, std::string t) {
	std::vector<std::vector<int>> dp(s.size() + 1, std::vector<int>(t.size() + 1, 0));

	int result = 0;
	for (int i = 1; i <= s.size(); i++)
	{
		for (int j = 1; j <= t.size(); j++) {
			// 分为两种情况：当前元素相等，当前元素不等
			// 当前元素相等时：dp[i][j] = dp[i - 1][j - 1] + 1    当前元素不等时，dp[i][j] = dp[i - 1][j - 1]
			if (s[i - 1] == t[j - 1])
			{
				dp[i][j] = dp[i - 1][j - 1] + 1;
			}
			else {
				dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
			}
			if (result < dp[i][j])
			{
				result = dp[i][j];
			}
		}
	}
	return result == s.size()?true:false;
}
/*
	动态规划题32：回文子串
*/

class Solution125
{
public:
	Solution125()
	{
	}

	~Solution125()
	{
	}

	int countSubstrings(std::string s);
private:

};

// 注意：具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
int Solution125::countSubstrings(std::string s) {
	std::vector<std::vector<bool>> dp(s.size(), std::vector<bool>(s.size(), false));
	int result = 0;
	for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序
		for (int j = i; j < s.size(); j++) {
			if (s[i] == s[j]) {
				if (j - i <= 1) { // 情况一 和 情况二
					result++;
					dp[i][j] = true;
				}
				else if (dp[i + 1][j - 1]) { // 情况三
					result++;
					dp[i][j] = true;
				}
			}
		}
	}
	return result;
}

/*
	动态规划题33：最长回文子序列
*/
class Solution126
{
public:
	Solution126()
	{
	}

	~Solution126()
	{
	}

	int longestPalindromeSubseq(std::string s);
private:

};

// 注意：回文子串是要连续的，回文子序列可不是连续的！
int Solution126::longestPalindromeSubseq(std::string s) {
	std::vector<std::vector<int>> dp(s.size(), std::vector<int>(s.size(), 0));
	for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
	for (int i = s.size() - 1; i >= 0; i--) {
		for (int j = i + 1; j < s.size(); j++) {
			if (s[i] == s[j]) {
				dp[i][j] = dp[i + 1][j - 1] + 2;
			}
			else {
				dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);
			}
		}
	}
	return dp[0][s.size() - 1];
}
//int main()
//{	
//	Solution126 s126;
//	std::string s = "bbbab";
//	int res = s126.longestPalindromeSubseq(s);
//	std::cout << res << std::endl;

	/*Solution125 s125;
	std::string s = "abc";
	int res = s125.countSubstrings(s);
	std::cout << res << std::endl;*/

	/*Solution124 s124;
	std::string s = "abc";
	std::string t = "ahbgdc";
	bool res = s124.isSubsequence(s, t);
	std::cout << res << std::endl;*/

	/*Solution123 s123;
	std::vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
	int res = s123.maxSubArray(nums);
	std::cout << res << std::endl;*/

	/*Solution122 s122;
	std::vector<int> nums1 = {2, 5, 1, 2, 5};
	std::vector<int> nums2 = {10, 5, 2, 1, 5, 2};
	int res = s122.maxUncrossedLines(nums1, nums2);
	std::cout << res << std::endl;*/

	/*Solution121 s121;
	std::string text1 = "abcde";
	std::string text2 = "ace";
	int res = s121.longestCommonSubsequence(text1, text2);
	std::cout << res << std::endl;*/


	/*Solution120 s120;
	std::vector<int> nums = {1, 2, 3, 2, 1};
	std::vector<int> nums2 = {3, 2, 1, 4, 7};
	int res = s120.findLength(nums, nums2);
	std::cout << res << std::endl;*/


	//Solution119 s119;
	////std::vector<int> nums = {1, 3, 5, 4, 7};
	//std::vector<int> nums = {2, 2, 2, 2, 2};
	//int res = s119.findLengthOfLCIS(nums);
	//std::cout << res << std::endl;

	/*Solution118 s118;
	std::vector<int> nums = {10,9,2,5,3,7,101,18};
	int res = s118.lengthOfLIS(nums);
	std::cout << res << std::endl;*/

	/*Solution117 s117;
	std::vector<int> prices = {1, 3, 2, 8, 4, 9};
	int fee = 2;
	int res = s117.maxProfit(prices, fee);
	std::cout << res << std::endl;*/

	//Solution116 s116;
	//std::vector<int> prices{ 1, 2, 3, 0, 2};
	////std::vector<int> prices{1};
	//int res = s116.maxProfit(prices);
	//std::cout << res << std::endl;


	/*Solution115 s115;
	std::vector<int> prices{ 7, 1, 5, 3, 1, 4};
	int res = s115.maxProfit(prices);
	std::cout << res << std::endl;*/


	/*Solution114 s114;
	std::vector<int> prices = {7, 1, 5, 3, 6, 4};
	int res = s114.maxProfit(prices);
	std::cout << res << std::endl;*/

	/*Solution113 s113;
	TreeNode* root = new TreeNode(3);
	root->left = new TreeNode(2);
	root->left->right = new TreeNode(3);
	root->right = new TreeNode(3);
	root->right->right = new TreeNode(1);
	int res = s113.rob(root);
	std::cout << res << std::endl;*/


	/*Solution112 s112;
	std::vector<int> nums = {1, 2, 3, 1};
	int res = s112.rob(nums);
	std::cout << res << std::endl;*/

	/*Solution111 s111;
	std::vector<int> nums = {1, 2, 3, 1};
	int res = s111.rob(nums);
	std::cout << res << std::endl;*/

	/*Solution110 s110;
	std::string s = "leetcode";
	std::vector<std::string> wordDict;
	wordDict.push_back("leet");
	wordDict.push_back("code");
	bool res = s110.wordBreak(s, wordDict);
	std::cout << res << std::endl;*/


	/*Solution109 s109;
	int res = s109.numSquares(12);
	std::cout << res << std::endl;*/

	/*Solution108 s108;

	std::vector<int> des = {1, 2, 5};
	int amount = 11;

	int res = s108.coinChange(des, amount);

	std::cout << res << std::endl;*/

	/*Solution107 s107;

	int res = s107.climbStairs(2);

	std::cout << res << std::endl;*/

	/*Solution106 s106;

	std::vector<int> des = {1, 2, 3};

	int target = 4;

	int res= s106.combinationSum4(des, target);
	std::cout << res << std::endl;*/

	/*Solution105 s105;
	
	std::vector<int> des = {1, 2, 5};
	int target = 5;
	int res = s105.change(target, des);
	std::cout << res << std::endl;*/

	/*Solution104 s104;
	std::vector<std::string> des = { "10", "0001", "111001", "1", "0" };
	int res = s104.findMaxForm(des, 5, 3);
	std::cout << res << std::endl;*/

	/*Solution103 s103;

	std::vector<int> nums = {1, 1, 1, 1, 1};
	int target = 3;*/
	/*int res = s103.findTargetSumWays(nums, target);

	std::cout << "-----------------------" << std::endl;
	std::cout << res << std::endl;*/

	/*int res2 = s103.findTargetSumWays2(nums, target);
	std::cout << res2 << std::endl;*/

	/*Solution99 s99;
	int res = s99.numTrees(3);
	std::cout << res << std::endl;*/

	/*Solution100 s100;
	std::vector<int> p{1, 3, 4};
	std::vector<int> v{15, 20, 30};
	int res = s100.getMaxValue(p, v, 4);*/
	//std::cout << res << std::endl;

	/*Solution101 s101;
	std::vector<int> nums = {1, 2, 3, 5};
	bool res = s101.canPartition(nums);
	std::cout << res << std::endl;*/

	//Solution102 s102;
	////std::vector<int> stones = { 2, 7, 4, 1, 8, 1 };
	//std::vector<int> stones = { 31, 26, 33, 21, 40 };
	//int res = s102.lastStoneWeightII(stones);
	//std::cout << res << std::endl;
//}


/*
	单调栈题1：每日温度
*/
class Solution127
{
public:
	Solution127()
	{
	}

	~Solution127()
	{
	}

	std::vector<int> dailyTemperatures(std::vector<int>& temperatures);
private:

};
#include<stack>
std::vector<int> Solution127::dailyTemperatures(std::vector<int>& temperatures) {
	std::stack<int> st;   // 保存下标，而非元素，有助于记录距离
	std::vector<int> result(temperatures.size(), 0);

	st.push(0); // 初始化  下标0

	for (int i = 1; i < temperatures.size(); i++)
	{
		if (temperatures[i] <= temperatures[st.top()]) {
			st.push(i);
		}
		else
		{
			while (!st.empty() && temperatures[i] > temperatures[st.top()])
			{
				result[st.top()] = i - st.top();
				st.pop();
			}
			st.push(i);
		}
	}
	return result;
}


/*
	剑指offer 1：用两个栈实现队列
*/
class Solution128
{
public:
	std::stack<int> numStack1;
	std::stack<int> numStack2;

	Solution128()
	{
	}

	~Solution128()
	{
	}
	// 压栈    不用考虑栈满的情况
	void appendTail(int value);
	// 出栈  考虑栈空的情况
	int deleteHead();

	// 打印队列元素
	void printQueue();
private:

};

void Solution128::printQueue() {
	std::stack<int> temp(numStack1);

	while (!temp.empty())
	{
		std::cout << temp.top() << " ";
		temp.pop();
	}
	std::cout << "---------------" << std::endl;
}

void Solution128::appendTail(int value) {
	this->numStack1.push(value);
}

int Solution128::deleteHead() {

	if (!numStack1.empty())
	{
		while (!numStack1.empty()) {
			int value = numStack1.top();
			numStack2.push(value);
			numStack1.pop();
		}
	}
	else
	{
		return -1;
	}

	int result = numStack2.top();
	numStack2.pop();

	while (!numStack2.empty())
	{
		int value = numStack2.top();
		numStack1.push(value);
		numStack2.pop();
	}

	return result;
}


/*
	剑指offer 2：包含min函数的栈
*/
class Solution129
{
public:
	Solution129()
	{
		minStack.push(INT_MAX);
	}

	~Solution129()
	{
	}

	void push(int x);

	void pop();

	int top();

	int min();

private:
	std::stack<int> myStack;
	std::stack<int> minStack;
};

// 保存每一次压栈操作的最小值
void Solution129::push(int x) {
	myStack.push(x);

	if (x > minStack.top())
	{
		minStack.push(minStack.top());
	}
	else
	{
		minStack.push(x);
	}
	
}

void Solution129::pop() {
	if(!myStack.empty())
	{	
		int vDelete = myStack.top();
		myStack.pop();
		minStack.pop();
	}

}

int Solution129::top() {
	return myStack.top();
}
int Solution129::min() {
	if (!minStack.empty())
	{
		return minStack.top();
	}
}

/*
	剑指offer 3：从尾到头打印链表
*/
struct ListNode {
	int val;
	ListNode* next;
	ListNode(int x) : val(x), next(NULL) {}
};
class Solution130
{
public:
	Solution130()
	{
	}

	~Solution130()
	{
	}

	std::vector<int> reversePrint(ListNode* head);
	std::vector<int> reversePrint2(ListNode* head);
	void backtracking(ListNode* head, std::vector<int>& res);
private:

};

void Solution130::backtracking(ListNode* head, std::vector<int>& res) {
	if (head->next == NULL)
	{	
		res.push_back(head->val);
		return;
	}
	
	if (head->next)
	{
		backtracking(head->next, res);
		res.push_back(head->val);
	}

}

std::vector<int> Solution130::reversePrint(ListNode* head) {
	std::vector<int>res;
	if (head == NULL)
	{
		return res;
	}
	backtracking(head, res);

	return res;
}
//#include<algorithm>
std::vector<int> Solution130::reversePrint2(ListNode* head) {
	std::vector<int>res;
	if (head == NULL)
	{
		return res;
	}

	while (head->next)
	{
		res.push_back(head->val);
		head = head->next;
	}
	res.push_back(head->val);

	
	std::reverse(res.begin(), res.end());
	return res;

}

/*
	剑指offer 4：反转链表
*/
class Solution131
{
public:
	Solution131()
	{
	}

	~Solution131()
	{
	}
	ListNode* reverseList(ListNode* head);
private:

};


ListNode* Solution131::reverseList(ListNode* head) {
	if (head == NULL)
	{
		return NULL;
	}
	// 双指针法
	ListNode* cur = head;
	ListNode* prev = NULL;

	while (cur)
	{
		ListNode* temp = cur->next;
		cur->next = prev;
		prev = cur;
		cur = temp;
	}

	return prev;
}

/*
	剑指offer 5：复杂链表的复制
*/
class Node {
public:
	int val;
	Node* next;
	Node* random;

	Node(int _val) {
		val = _val;
		next = NULL;
		random = NULL;
	}
};
#include<unordered_map>
class Solution132
{
public:
	std::unordered_map<Node*, Node*> cachedNode;
	Solution132()
	{
	}

	~Solution132()
	{
	}
	Node* copyRandomList(Node* head);
private:

};
//回溯 + 哈希表           其实回溯就能保证节点的random指针合理创建
Node* Solution132::copyRandomList(Node* head) {
	if (head == nullptr) {
		return nullptr;
	}
	if (!cachedNode.count(head)) {  // 判断该节点是否已创建   未创建则进入域
		Node* headNew = new Node(head->val);
		cachedNode[head] = headNew;
		headNew->next = copyRandomList(head->next);
		headNew->random = copyRandomList(head->random);
	}
	return cachedNode[head];
}
/*
	剑指offer 6：替换空格
*/
class Solution133
{
public:
	Solution133()
	{
	}

	~Solution133()
	{
	}
	std::string replaceSpace(std::string s);
private:

};

std::string Solution133::replaceSpace(std::string s) {
	// 1、先根据空格个数扩展原数组大小
	int count = 0;
	for (int i = 0; i < s.size(); i++)
	{
		if (isspace(s[i])) {
			count++;
		}
	}
	int oldSize = s.size();
	int newSize = s.size() + 2*count;
	s.resize(newSize);
	// 2、从后往前遍历字符串（优点不被覆盖），替换空格
	for (int i = newSize - 1, j = oldSize - 1; j >= 0; i--, j--)
	{
		if (isspace(s[j]))
		{
			s[i] = '0';
			s[i - 1] = '2';
			s[i - 2] = '%';
			i -= 2;
		}
		else
		{
			s[i] = s[j];
		}
		
	}
	return s;
}

/*
	剑指offer 7：左旋转字符串
*/
class Solution134
{
public:
	Solution134()
	{
	}

	~Solution134()
	{
	}
	std::string reverseLeftWords(std::string s, int n);
private:

};
//输入: s = "abcdefg", k = 2
//输出 : "cdefgab"
std::string Solution134::reverseLeftWords(std::string s, int n) {
	if (n > s.size())
	{
		return s;
	}
	s.resize(s.size() + n);
	for (int i = n; i > 0; i--)
	{
		s[s.size() - i] = s[n - i];
	}
	std::string res = "";
	res = s.substr(n, s.size());
	return res;
}
/*
	剑指offer 8：数组中重复的数字
*/
class Solution135
{
public:
	Solution135()
	{
	}

	~Solution135()
	{
	}
	int findRepeatNumber(std::vector<int>& nums);
private:

};
// 使用set容器，装载元素后实时检查元素个数是否改变，若改变则返回该元素
int Solution135::findRepeatNumber(std::vector<int>& nums) {

	std::unordered_set<int> res;

	for (int i = 0; i < nums.size(); i++)
	{	
		int ordSize = res.size();
		res.insert(nums[i]);
		if (res.size() == ordSize)
		{
			return nums[i];
		}
	}
	return -1;
}

/*
	剑指offer 9：在排序数组中查找数字1
*/
class Solution136
{
public:
	Solution136()
	{
	}

	~Solution136()
	{
	}

	int search(std::vector<int>& nums, int target);
private:

};

int Solution136::search(std::vector<int>& nums, int target) {
	int res = 0;
	for (int i = 0; i < nums.size(); i++)
	{
		if (nums[i] == target) {
			res++;
		}
		else if (nums[i] > target)
		{
			break;
		}
	}

	return res;
}

/*
	剑指offer 10：0～n-1中缺失的数字
*/
class Solution137
{
public:
	Solution137()
	{
	}

	~Solution137()
	{
	}
	int missingNumber(std::vector<int>& nums);
private:

};
// 通过前后元素差值找到不在集合中的元素
int Solution137::missingNumber(std::vector<int>& nums) {
	
	int n = nums.size();  // 0 ~ n

	//处理 0 ~ n - 1 元素
	for (int i = 0; i < n; i++)
	{
		if (i != nums[i]) {
			return i;
		}
	}
	// 处理最后一个元素 n
	if (nums[nums.size() - 1] != nums.size())
	{
		return nums.size();
	}
	return -1;
}

/*
	剑指offer 11：二维数组中的查找
*/
class Solution138
{
public:
	Solution138()
	{
	}

	~Solution138()
	{
	}
	bool findNumberIn2DArray(std::vector<std::vector<int>>& matrix, int target);

	void binarySearch(std::vector<int>& des, int target, int left, int right, bool& res);
private:

};
#include<algorithm>
//二分查找  每一行
void Solution138::binarySearch(std::vector<int>& des, int target, int left, int right, bool & res) {
	int mid = (left + right) / 2;
	
	if (mid < des.size())
	{
		if (des[mid] == target)
		{
			res = true;
		}
	}
	
	if (left <= right && mid < des.size())
	{
		if (des[mid] > target)
		{
			binarySearch(des, target, left, mid - 1, res);
		}
		else
		{
			binarySearch(des, target, mid + 1, right, res);
		}
	}
	
}
bool Solution138::findNumberIn2DArray(std::vector<std::vector<int>>& matrix, int target) {
	if (matrix.size() == 0)
	{
		return false;
	}
	bool res = false;
	for (auto x : matrix) {
		binarySearch(x, target, 0, x.size(), res);
		if (res)
		{
			return true;
		}
	}

	return false;
}

//[
//	[1, 4, 7, 11, 15],
//	[2, 5, 8, 12, 19],
//	[3, 6, 9, 16, 22],
//	[10, 13, 14, 17, 24],
//	[18, 21, 23, 26, 30]
//]
//target = 5    return true
//target = 10    return false

/*
	剑指offer 12：旋转数组的最小数字
*/
class Solution139
{
public:
	Solution139()
	{
	}

	~Solution139()
	{
	}

	int minArray(std::vector<int>& numbers);
private:

};
// 找到旋转边界点即可
int Solution139::minArray(std::vector<int>& numbers) {
	if (numbers.size() == 1)
	{
		return numbers[0];
	}
	
	for (int i = 1; i < numbers.size(); i++)
	{
		if (numbers[i] < numbers[i - 1])
		{
			return numbers[i];
		}
	}
	return numbers[0];
}

/*
	剑指offer 13：第一个只出现一次的字符
*/
class Solution140
{
public:
	Solution140()
	{
	}

	~Solution140()
	{
	}
	char firstUniqChar(std::string s);
private:

};

// 可以使用map 时间复杂度  n
char Solution140::firstUniqChar(std::string s) {
	std::unordered_map<char, int> res;

	for (int i = 0; i < s.size(); i++)
	{
		res[s[i]] ++;
	}

	std::vector<char> res2;

	for (auto pair: res)
	{	
		if (pair.second == 1)
		{
			res2.push_back(pair.first);
		}
	}

	for (int i = 0; i < s.size(); i++)
	{
		if (find(res2.begin(), res2.end(), s[i]) != res2.end()) {
			return s[i];
		}
	}

	return ' ';
}

/*
	剑指offer 14：从上到下打印二叉树
*/
class Solution141
{
public:
	Solution141()
	{
	}

	~Solution141()
	{
	}

	std::vector<int> levelOrder(TreeNode* root);
private:

};
#include<queue>
// 也就是层序遍历二叉树   回溯
std::vector<int> Solution141::levelOrder(TreeNode* root) {
	std::vector<int> res;
	if (root == NULL) return res;
	std::queue<TreeNode*> q;
	q.push(root);
	while (!q.empty()) {
		int size = q.size();
		for (int i = 0; i < size; i++) {
			TreeNode* node = q.front();
			res.push_back(node->val);
			q.pop();
			if (node->left) q.push(node->left);
			if (node->right) q.push(node->right);
		}
	}
	return res;

}

/*
	剑指offer 15：从上到下打印二叉树2
*/
class Solution142
{
public:
	Solution142()
	{
	}

	~Solution142()
	{
	}
	std::vector<std::vector<int>> levelOrder(TreeNode* root);
private:

};

std::vector<std::vector<int>> Solution142::levelOrder(TreeNode* root) {
	std::vector < std::vector<int>> res;
	if (root == NULL)
	{
		return res;
	}

	std::queue<TreeNode*> q;
	q.push(root);

	while (!q.empty())
	{
		int size = q.size();
		std::vector<int> temp;
		for (int i = 0; i < size; i++)
		{
			TreeNode* node = q.front();
			temp.push_back(node->val);
			q.pop();
			if (node->left)
			{
				q.push(node->left);
			}
			if (node->right)
			{
				q.push(node->right);
			}
		}
		res.push_back(temp);
	}
	return res;
}

/*
	剑指offer 16：从上到下打印二叉树3
*/
class Solution143
{
public:
	Solution143()
	{
	}

	~Solution143()
	{
	}
	std::vector<std::vector<int>> levelOrder(TreeNode* root);
private:

};
// 第一层按照从左到右打印，第二层按照从右到左打印，第三层按照从左到右打印。。。以此类推
std::vector<std::vector<int>> Solution143::levelOrder(TreeNode* root) {
	std::vector<std::vector<int>> res;
	if (root == NULL)
	{
		return res;
	}

	std::queue<TreeNode*> q;
	q.push(root);
	bool flag = true;
	while (!q.empty())
	{
		int size = q.size();
		std::vector<int> temp;

		if (flag)
		{
			for (int i = 0; i < size; i++)
			{
				TreeNode* node = q.front();
				temp.push_back(node->val);
				q.pop();

				if (node->left)
				{
					q.push(node->left);
				}
				if (node->right)
				{
					q.push(node->right);
				}
			}
			res.push_back(temp);
			flag = false;
		}
		else
		{
			for (int i = 0; i < size; i++)
			{
				TreeNode* node = q.front();
				temp.push_back(node->val);
				q.pop();

				if (node->left)
				{
					q.push(node->left);
				}
				if (node->right)
				{
					q.push(node->right);
				}
			}
			std::reverse(temp.begin(), temp.end());
			res.push_back(temp);
			flag = true;
		}
	}
	return res;
}

/*
	剑指offer 17：树的子结构     这个是错误解法
*/
class Solution144
{
public:
	Solution144()
	{
	}

	~Solution144()
	{
	}
	bool isSubStructure(TreeNode* A, TreeNode* B);
	void backTracking(TreeNode* root, std::vector<int>& res); // 前序
	void backTracking2(TreeNode* root, std::vector<int>& res); // 中序

	void getNext(int* next, std::vector<int>& s);
	int strStr(std::vector<int>& haystack, std::vector<int>& needle);
private:

};

void Solution144::backTracking(TreeNode* root, std::vector<int>& res) {

	if (root == NULL)
	{
		return;
	}

	res.push_back(root->val);

	if (root->left)
	{
		backTracking(root->left, res);
	}
	if (root->right)
	{
		backTracking(root->right, res);
	}

}
void Solution144::backTracking2(TreeNode* root, std::vector<int>& res) {

	if (root == NULL)
	{
		return;
	}

	if (root->left)
	{
		backTracking2(root->left, res);
	}
	res.push_back(root->val);
	if (root->right)
	{
		backTracking2(root->right, res);
	}
}

// KMP 算法对 重要的一步 求next数组，即部分匹配表
void Solution144::getNext(int* next, std::vector<int>& s) {

	int j = 0;
	next[0] = 0;
	for (int i = 1; i < s.size(); i++) {
		while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
			j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
		}
		if (s[i] == s[j]) {
			j++;
		}
		next[i] = j;
	}

};
int Solution144::strStr(std::vector<int> &haystack, std::vector<int> &needle) {
	if (needle.size() == 0) {
		return 0;
	}
	int size = needle.size();
	int* next = new int[size];
	getNext(next, needle);
	int j = 0;
	for (int i = 0; i < haystack.size(); i++) {
		while (j > 0 && haystack[i] != needle[j]) {
			j = next[j - 1];
		}
		if (haystack[i] == needle[j]) {
			j++;
		}
		if (j == needle.size()) {
			return (i - needle.size() + 1);
		}
	}
	return -1;
}


// 先序 + 中序    后序 + 中序  都可以唯一确定一棵子树
// 可以根据两个树的先序 + 后序是否包含关系确定是否父子树关系
bool Solution144::isSubStructure(TreeNode* A, TreeNode* B) {

	if (A == NULL || B == NULL)
	{
		return false;
	}

	std::vector<int> preSearchA;
	std::vector<int> postSearchA;
	std::vector<int> preSearchB;
	std::vector<int> postSearchB;

	backTracking(A, preSearchA);
	backTracking2(A, postSearchA);

	backTracking(B, preSearchB);
	backTracking2(B, postSearchB);

	for (int i = 0; i < preSearchA.size(); i++)
	{
		std::cout << preSearchA[i] << " ";
	}
	std::cout << std::endl;

	for (int i = 0; i < postSearchA.size(); i++)
	{
		std::cout << postSearchA[i] << " ";
	}
	std::cout << std::endl;
	std::cout << "-------------------" << std::endl;

	for (int i = 0; i < preSearchB.size(); i++)
	{
		std::cout << preSearchB[i] << " ";
	}
	std::cout << std::endl;

	for (int i = 0; i < postSearchB.size(); i++)
	{
		std::cout << postSearchB[i] << " ";
	}
	std::cout << std::endl;


	// 判断子数组   KMP 算法匹配
	if (strStr(preSearchA, preSearchB) != -1 && strStr(postSearchA, postSearchB) != -1) {
		return true;
	}

	return false;
}

/*
	剑指offer 18：二叉树的镜像
*/
class Solution145
{
public:
	Solution145()
	{
	}

	~Solution145()
	{
	}
	TreeNode* mirrorTree(TreeNode* root);
private:

};

// 层序遍历的应用
TreeNode* Solution145::mirrorTree(TreeNode* root) {

	std::queue<TreeNode*> q;
	q.push(root);
	while (!q.empty()) {
		TreeNode* t = q.front();
		q.pop();
		if (t) {
			q.push(t->left);
			q.push(t->right);
			TreeNode* tmp = t->left;
			t->left = t->right;
			t->right = tmp;
		}
	}
	return root;
}

/*
	剑指offer 19：对称的二叉树   未解决
*/
class Solution146
{
public:
	Solution146()
	{
	}

	~Solution146()
	{
	}
	bool isSymmetric(TreeNode* root);
	bool isSymmetric2(TreeNode* root);
	bool check(TreeNode* p, TreeNode* q);
	TreeNode* mirrorTree(TreeNode* root);
	std::vector<int> search2(TreeNode* root);
private:

};
TreeNode* Solution146::mirrorTree(TreeNode* root) {

	std::queue<TreeNode*> q;
	q.push(root);
	while (!q.empty()) {
		TreeNode* t = q.front();
		q.pop();
		if (t) {
			q.push(t->left);
			q.push(t->right);
			TreeNode* tmp = t->left;
			t->left = t->right;
			t->right = tmp;
		}
	}
	return root;
}

std::vector<int> Solution146::search2(TreeNode* root) {

	std::vector<int> res;
	if (root == nullptr) return res;

	// 使用队列实现
	std::queue<TreeNode*> q;
	q.push(root);

	while (!q.empty())
	{

		int size = q.size();
		
		for (int i = 0; i < size; i++)
		{
			TreeNode* node = q.front();
			res.push_back(node->val);
			q.pop();
			if (node->left) q.push(node->left);
			if (node->right) q.push(node->right);
		}
	}

	return res;
}

bool Solution146::isSymmetric(TreeNode* root) {
	TreeNode* mirrorNode = mirrorTree(root);

	std::vector<int> res1 = search2(root);
	std::vector<int> res2 = search2(mirrorNode);

	if (res1.size() != res2.size())
	{
		return false;
	}

	for (int i = 0; i < res1.size(); i++)
	{
		if (res1[i] != res2[i])
		{
			return false;
		}
	}

	return true;
}

bool Solution146::check(TreeNode* p, TreeNode* q) {
	if (!p && !q) return true; // 两个都为空 返回true
	if (!p || !q) return false; // 其中一个不为空返回false
	return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
}

bool Solution146::isSymmetric2(TreeNode* root) {
	return check(root, root);
}

int main() {

	Solution146 s146;
	TreeNode* root = new TreeNode(1);
	root->left = new TreeNode(4);
	root->right = new TreeNode(4);
	root->left->left = new TreeNode(3);
	root->left->right = new TreeNode(4);
	root->right->left = new TreeNode(4);
	root->right->right = new TreeNode(3);


	bool res = s146.isSymmetric2(root);
	std::cout << res << std::endl;

	/*Solution145 s145;
	TreeNode* root = new TreeNode(4);
	root->left = new TreeNode(2);
	root->right = new TreeNode(7);
	root->left->left = new TreeNode(1);
	root->left->right = new TreeNode(3);
	root->right->left = new TreeNode(6);
	root->right->right = new TreeNode(9);


	TreeNode* res = s145.mirrorTree(root);*/


	/*Solution144 s144;
	TreeNode* A = new TreeNode(3);
	A->left = new TreeNode(4);
	A->right = new TreeNode(5);

	A->left->left = new TreeNode(1);
	A->left->right= new TreeNode(2);

	TreeNode* B = new TreeNode(4);
	B->left = new TreeNode(1);

	bool res = s144.isSubStructure(A, B);
	std::cout << res << std::endl;*/


	/*Solution143 s143;
	TreeNode* root = new TreeNode(3);
	root->left = new TreeNode(9);
	root->right = new TreeNode(20);
	root->right->left = new TreeNode(15);
	root->right->right = new TreeNode(7);

	std::vector<std::vector<int>> res = s143.levelOrder(root);

	for (auto y : res)
	{
		for (auto x : y)
		{
			std::cout << x << " ";
		}
		std::cout << std::endl;
	}*/


	/*Solution142 s142;
	TreeNode* root = new TreeNode(3);
	root->left = new TreeNode(9);
	root->right = new TreeNode(20);
	root->right->left = new TreeNode(15);
	root->right->right = new TreeNode(7);

	std::vector<std::vector<int>> res = s142.levelOrder(root);

	for (auto y : res)
	{	
		for (auto x : y)
		{
			std::cout << x << " ";
		}
		std::cout << std::endl;
	}*/
	

	/*Solution141 s141;
	TreeNode* root = new TreeNode(3);
	root->left = new TreeNode(9);
	root->right = new TreeNode(20);
	root->right->left = new TreeNode(15);
	root->right->right = new TreeNode(7);

	std::vector<int> res = s141.levelOrder(root);

	for (auto y : res)
	{
		std::cout << y << " ";
	}
	std::cout << std::endl;*/
	

	/*Solution140 s140;
	std::string s = "dlaeetcoe";
	char res = s140.firstUniqChar(s);
	std::cout << res << std::endl;*/


	/*Solution139 s139;
	std::vector<int> nums = {3, 4, 5, 1, 2};
	int res = s139.minArray(nums);
	std::cout << res << std::endl;*/


	/*Solution138 s138;
	std::vector<std::vector<int>> nums = { {1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, 
		{18, 21, 23, 26, 30} };
	int target = 1000;
	bool res = s138.findNumberIn2DArray(nums, target);
	std::cout << res << std::endl;*/


	/*Solution137 s137;
	std::vector<int> nums = {0, 1, 2, 3, 4, 5};
	int res = s137.missingNumber(nums);
	std::cout << res << std::endl;*/
	    

	/*Solution136 s136;
	std::vector<int> nums = {5, 7, 7, 8, 8, 10};
	int target = 8;
	int res = s136.search(nums, target);
	std::cout << res << std::endl;*/


	/*Solution133 s133;
	std::string s = "We are happy.";
	std::string res = s133.replaceSpace(s);

	std::cout << res << std::endl;*/


	//Solution134 s134;
	////std::string s = "abcdefg";
	//std::string s = "lrloseumgh";
	//std::string res = s134.reverseLeftWords(s, 6);
	//std::cout << res << std::endl;


	/*Solution135 s135;
	std::vector<int> des = {1, 2, 3, 4, 5, 2, 4, 5};
	int res = s135.findRepeatNumber(des);
	std::cout << res << std::endl;*/


	/*Solution127 s127;
	std::vector<int> des = { 73,74,75,71,69,72,76,73 };
	std::vector<int> res = s127.dailyTemperatures(des);
	for (auto i = res.begin(); i != res.end(); i++)
	{
		std::cout << *i << " ";
	}*/



	/*Solution128 s128;
	
	s128.appendTail(1);
	s128.appendTail(2);
	s128.appendTail(3);
	s128.appendTail(4);
	s128.appendTail(5);
	s128.appendTail(6);

	s128.printQueue();

	int res = s128.deleteHead();

	std::cout << res << std::endl;
	s128.printQueue();*/



	/*Solution129 s129;

	s129.push(5);

	int res1 = s129.min();
	std::cout << res1 << std::endl;
	s129.push(-2);
	s129.push(0);
	s129.push(-3);
	int res2 = s129.min();
	std::cout << res2 << std::endl;
	s129.pop();
	int res3 = s129.top();
	std::cout << res3 << std::endl;

	int res4 = s129.min();
	std::cout << res4 << std::endl;*/



	/*Solution130 s130;
	ListNode* root = new ListNode(1);
	root->next = new ListNode(3);
	root->next->next = new ListNode(2);
	std::vector<int> res = s130.reversePrint2(root);
	for (int i = 0; i < res.size(); i++)
	{
		std::cout << res[i] << " ";
	}*/



	/*Solution131 s131;
	ListNode* root = new ListNode(1);
	root->next = new ListNode(2);
	root->next->next = new ListNode(3);
	root->next->next->next = new ListNode(4);
	root->next->next->next->next = new ListNode(5);
	root->next->next->next->next->next = NULL;

	ListNode* res = s131.reverseList(root);

	while (res->next)
	{
		std::cout << res->val << " ";
		res = res->next;
	}
	std::cout << res->val << std::endl;*/



	//Solution132 s132;

	////输入：head = [[7, null], [13, 0], [11, 4], [10, 2], [1, 0]]
	////输出： [[7, null], [13, 0], [11, 4], [10, 2], [1, 0]]
	//Node* root = new Node(7);
	//root->random = NULL;

	//root->next = new Node(13);
	//root->next->random = root;

	//root->next->next = new Node(11);
	//


	//root->next->next->next = new Node(10);
	//root->next->next->next->random = root->next->next;

	//root->next->next->next->next = new Node(1);
	//root->next->nex t->next->next->random = root;

	//root->next->next->random = root->next->next->next->next;




	//Node* res = s132.copyRandomList(root);
	//while (res->next)
	//{	
	//	std::cout << res->val << " ";
	//	res = res->next;
	//}
	//std::cout << res->val << std::endl;

	
	return 0;
}

// ======== End 代码随想录 c++ ========

/////////////////////////////////////////////////////////////////////////////

// ======== Start 剑指offer1 java ========
import java.util.*;
import java.math.BigInteger;
public class offer {

    /**
     * 剑指offer 20：斐波那契数列
     * 动态规划解法
     * @param n
     * @return
     */
    public int fib(int n) {
        if (n == 0){
            return 0;
        }

        if (n == 1){
            return 1;
        }

        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }

        return dp[n];
    }


    /**
     * 剑指offer 21：青蛙跳台阶问题
     * 动态规划解法
     * @param n
     * @return
     */
    public int numWays(int n) {
        if (n == 0){
            return 1;
        }

        if (n == 1){
            return 1;
        }

        int[] dp = new int[n + 1];
        // 初始化
        dp[1] = 1;  // 第一个台阶只有一种跳法
        dp[2] = 2; // 第二个台阶存在两种跳法

        for (int i = 3; i <=n ; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007; // 解释：该台阶的跳法就是前两个台阶跳法之和
        }

        return dp[n];
    }

    /**
     * 剑指offer 22：股票的最大利润
     * 动态规划解法
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        // 1、确定dp及其下标含义
        // dp[i][0] 表示第 i 天持有股票所得最多现金     dp[i][1] 表示第 i 不持有股票所得最多现金
        int[][] dp = new int[prices.length + 1][2];
        // 2、确定递推公式    dp[i][0] 分为第 i 天之前就买入 还是当天买入    dp[i][1]  分为第 i 天之前就卖出 还是当天卖出
        // dp[i][0] = fmax(dp[i - 1][0], -prices[i])     dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i])
        // 3、初始化dp    根据递推公式初始化 dp[0][0]   dp[0][1]
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        // 4、确定遍历顺序   i 状态依赖于 i - 1  ， 从前往后遍历
        for (int i = 1; i < prices.length; i++)
        {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        // 5、举例推导出返回值
        return dp[prices.length - 1][1];
    }

    /**
     * 剑指offer 23：连续子数组的最大和
     * 动态规划解法
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        int pre = 0, // 初始化前一个元素
        maxAns = nums[0]; // 将第一个元素初始化为 最大值
        for (int x : nums) {
            pre = Math.max(pre + x, x); // 跟新前一个元素
            maxAns = Math.max(maxAns, pre); // 跟新最大值
        }
        return maxAns;
    }

    /**
     * 剑指offer 24：礼物的最大价值
     * 动态规划解法
     * @param grid
     * @return
     */
    public int maxValue(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(i == 0 && j == 0) continue; // 第一个元素跳过
                if(i == 0) grid[i][j] += grid[i][j - 1] ; // 第一行元素
                else if(j == 0) grid[i][j] += grid[i - 1][j]; // 第一列元素
                else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);
            }
        }
        return grid[m - 1][n - 1];  // 右下角元素为最大元素
    }

    /**
     * 剑指offer 25：把数字翻译成字符串
     * 动态规划解法
     * 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。
     * 一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
     * @param num
     * @return
     */
    public int translateNum(int num) {
        String src = String.valueOf(num);  // 转化为字符串
        int p = 0, q = 0, r = 1;
        for (int i = 0; i < src.length(); ++i) { // 遍历字符串
            p = q;
            q = r;
            r = 0;
            r += q;
            if (i == 0) {
                continue;
            }
            String pre = src.substring(i - 1, i + 1);
            if (pre.compareTo("25") <= 0 && pre.compareTo("10") >= 0) {
                r += p;
            }
        }
        return r;

    }

    /**
     * 剑指offer 26：最长不含重复字符的子字符串
     * 动态规划解法
     * @param s
     * @return
     */
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();
        int res = 0;
        int tmp = 0;
        for(int j = 0; j < s.length(); j++) {
            int i = j - 1;
            while(i >= 0 && s.charAt(i) != s.charAt(j)) i--; // 线性查找 i   不重复字符
            tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        }
        return res;

    }
    public static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }
    /**
     * 剑指offer 27：删除链表的节点
     * 双指针法
     * @param head
     * @param val
     * @return
     */
    public ListNode deleteNode(ListNode head, int val) {

        if (head == null) return head;
        if (head.val == val) return head.next;

        ListNode pre = null;
        ListNode cur = head;

        while (cur != null){

            if (cur.val == val){
                pre.next = cur.next;
                break;
            }
            pre = cur;
            cur = cur.next;
        }

        return head;
    }

    /**
     * 剑指offer 28：链表中倒数第 k 个节点
     * 双指针法
     * @param head
     * @param k
     * @return
     */
    public ListNode getKthFromEnd(ListNode head, int k) {

        // 思路：快慢指针
        ListNode pre = head;
        ListNode cur = head;

        for (int i = 0; i < k; i++) {
            if (cur != null){
                cur = cur.next;
            }
        }

        while (cur != null){
            pre = pre.next;
            cur = cur.next;
        }
        return pre;
    }

    /**
     * 剑指offer 33：翻转单词顺序
     * 双指针法
     * @param s
     * @return
     */
    public String reverseWords(String s) {
        s = s.trim(); // 删除首尾空格
        int j = s.length() - 1; // 两个指针都指向最后一个元素
        int i = s.length() - 1;
        StringBuilder res = new StringBuilder();

        while (i >= 0){
            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格   从后向前查找单词
            res.append(s.substring(i + 1, j + 1) + " "); // 添加单词
            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格
            j = i; // j 指向下个单词的尾字符
        }


        return res.toString().trim(); // 转化为字符串并返回

    }

    public void backTracking(TreeNode root, int target, int sum, List<List<Integer>> res, List<Integer> temp){
        if (root == null) return;

        temp.add(root.val);
        sum += root.val;
        if (sum == target && root.left == null && root.right == null){
            res.add(new ArrayList<>(temp));
        }

        if (root.left != null) backTracking(root.left, target, sum, res, temp);
        if (root.right != null) backTracking(root.right, target, sum, res, temp);

        sum -= root.val;
        temp.remove(temp.size() - 1);
    }

    /**
     * 剑指offer 34：回溯搜索
     * @param root
     * @param target
     * @return
     */
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> temp = new ArrayList<>();
        backTracking(root, target, 0, res, temp);

        return res;
    }

    public void backTracking2(Node node, List<Node> res){
        if (node == null) return;
        if (node.left != null) backTracking2(node.left, res);
        res.add(node);
        if (node.right != null) backTracking2(node.right, res);
    }

    /**
     * 剑指offer 35：回溯搜索
     * @param root
     * @return
     */
    public Node treeToDoublyList(Node root){
        if (root == null) return root;

        List<Node> res = new ArrayList<>();
        backTracking2(root, res);


        Node doublyListHead = new Node();
        doublyListHead = res.get(0);
        res.get(0).left = res.get(res.size() - 1);
        for (int i = 0; i < res.size() - 1; i++) {
            res.get(i).right = res.get(i + 1);
            res.get(i + 1).left = res.get(i);
        }
        res.get(res.size() - 1).right = res.get(0);

        return doublyListHead;
    }

    public void backTracking3(TreeNode node, List<TreeNode> res){
        if (node == null) return;
        if (node.left != null) backTracking3(node.left, res);
        res.add(node);
        if (node.right != null) backTracking3(node.right, res);
    }

    /**
     * 剑指offer 36：回溯搜索
     * @param root
     * @param k
     * @return
     */
    public int kthLargest(TreeNode root, int k){

        List<TreeNode> res = new ArrayList<>();
        backTracking3(root, res);
        return res.get(res.size() - k).val;
    }



    public void backTracking4(int[] nums, StringBuilder s, int count, StringBuilder minValue, int index){

        if (count == nums.length){

            // 比较字符串大小   （1）int转char，将数字加一个‘0’，并强制类型转换为char。
            //（2）char转int，将字符减一个‘0’即可。
            StringBuilder ss = new StringBuilder(s);
            for (int i = 0; i < ss.length(); i++) {
                if (((ss.charAt(i) - '0') < (minValue.charAt(i) - '0'))){
                    minValue = ss;
                    System.out.println(minValue);
                    break;
                }
            }
//            return;
        }

        for (int i = index; i < nums.length; i++) {
            int len = (nums[i] + "").length();
            s.append(nums[i]);
            count ++;
            backTracking4(nums, s, count, minValue, i + 1);
            s.delete(s.length() - len, s.length());
            count --;
        }

    }

    public void backTracking4(List<StringBuilder> res, StringBuilder temp, boolean[] used, int count, int[] nums){

        if (count == nums.length){
            res.add(new StringBuilder(temp));
            return;
        }

        for (int i = 0; i < nums.length; i++) {

            if (used[i]){
                continue;
            }

            temp.append(nums[i]);
            int len = (nums[i] + "").length();
            used[i] = true;
            count ++;
            backTracking4(res, temp, used, count, nums);
            temp.delete(temp.length() - len, temp.length());
            used[i] = false;
            count --;

        }


    }
    /**
     * 剑指offer 37：排序
     * 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
     * 这道题思路是一道排列问题，使用回溯算法解决                 回溯解法超时了！！！！！
     * @param nums
     * @return
     */
    public String minNumber(int[] nums) {

        List<StringBuilder> res = new ArrayList<>();
        boolean[] used = new boolean[nums.length];

        backTracking4(res, new StringBuilder(), used, 0, nums);

        String minValue = String.valueOf(res.get(0));

        for (int i = 1; i < res.size(); i++) {
            for (int j = 0; j < res.get(0).length(); j++) {
                if ((minValue.charAt(j) - '0') < (res.get(i).charAt(j) - '0')){
                    break;
                }else if ((minValue.charAt(j) - '0') > (res.get(i).charAt(j) - '0')){
                    minValue = String.valueOf(res.get(i));
                    break;
                }
            }
        }

        return minValue;
    }



    /**
     * 剑指offer 38：排序
     * @param nums
     * @return
     */
    public boolean isStraight(int[] nums) {



        return false;
    }

    /**
     * 剑指offer 39：排序
     * @param arr
     * @param k
     * @return
     */
    public int[] getLeastNumbers(int[] arr, int k) {
        Arrays.sort(arr);
        int[] res = new int[k];
        System.arraycopy(arr, 0, res, 0, k);
        return res;
    }

    /**
     * 剑指offer 40：二叉树的深度
     * @param root
     * @return
     */
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return (Math.max(left, right)) + 1;
    }

    public int getDeep(TreeNode root){

        if (root == null) return 0;

        int left = getDeep(root.left);
        int right = getDeep(root.right);

        return (Math.max(left, right)) + 1;

    }
    /**
     * 剑指offer 41：平衡二叉树
     * @param root
     * @return
     */
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;

        if (Math.abs(getDeep(root.left) - getDeep(root.right)) <= 1){
            return isBalanced(root.left) && isBalanced(root.right);
        }else {
            return false;
        }
    }

    /**
     * 剑指offer 42：求 1+2+。。。+n
     * @param n
     * @return
     */
    public int sumNums(int n) {
        boolean flag = n > 0 && (n += sumNums(n - 1)) > 0;
        return n;
    }

    /**
     * 剑指offer 43：二叉搜索树的最近公共祖先
     * @param root
     * @param p
     * @param q
     * @return
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val > root.val && q.val > root.val){
            return lowestCommonAncestor(root.right, p, q);
        }else if (p.val < root.val && q.val < root.val){
            return lowestCommonAncestor(root.left, p, q);
        }else {
            return root;
        }
    }


    /**
     * 剑指offer 44：二叉树的最近公共祖先
     * @param root
     * @param p
     * @param q
     * @return
     */
    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q ){
            return root;
        }

        TreeNode left = lowestCommonAncestor2(root.left, p, q);
        TreeNode right = lowestCommonAncestor2(root.right, p, q);

        if (left == null && right == null) {
            return null;
        }
        if (left == null){
            return right;
        }
        if (right == null){
            return left;
        }
        return root;
    }


    /**
     * 剑指offer 45：重建二叉树  根据前序和中序遍历重建二叉树，这道题其实就是回溯思想  也具备分治思想
     * 首次开整分治算法
     * @param preorder
     * @param inorder
     * @return
     */
    public TreeNode buildTree(int[] preorder, int[] inorder) {

        // 这里已经使用 java 实现 -> 需要写切片和找索引函数，这里使用 c++ 实现（迭代器比较方便）

        return null;
    }

    public double myPow1(double x, int n) {
        double res = 1;
        while (n > 0){
            res *= x;
            n --;
        }
        return res;

//        if (n <= 0) {
//            return 1;
//        }
//
//        return x * myPow(x, --n);
    }

    public double myPow2(double x, int n) {
        double res = 1;
        while (n < 0){
            res *= 1 / x;
            n ++;
        }
        return res;

//        if (n >= 0) {
//            return 1;
//        }
//
//        return 1 / x * myPow(x, ++n);

    }
    /**
     * 剑指offer 46：数值的整数次方       可以是正整数，也可以是负整数           超时！！！！！
     * 首次开整分治算法
     * @param x
     * @param n
     * @return
     */
    public double myPow(double x, int n) {
        if ((int)x == 1){
            return x;
        }
        if (n > 0) {
            return myPow1(x, n);
        }

        if (n < 0) {
            return myPow2(x, n);
        }

        return 1;
    }

    /**
     * 剑指offer 47：剪绳子2
     * 动态规划
     * @param n
     * @return
     */

    public int cuttingRope(int n) {

        // 因为 题目 n >= 2 所以不考虑，但在动规数组中需要作为初始化
//        if (n == 0 || n == 1){
//            return 0
//        }

        BigInteger dp[] = new BigInteger[n + 1];
        Arrays.fill(dp, BigInteger.valueOf(1));
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = dp[i].max(BigInteger.valueOf(j * (i - j))).max(dp[i - j].multiply(BigInteger.valueOf(j)));
            }
        }
        return  dp[n].mod(BigInteger.valueOf(1000000007)).intValue();
    }


}


class Node {
    int val;
    Node left;
    Node right;
    Node() {}
    Node(int val) { this.val = val; }
    Node(int val, Node left, Node right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

Skip to content
Search or jump to…
Pull requests
Issues
Codespaces
Marketplace
Explore
 
@qwert233xu 
qwert233xu
/
leetcodeJava1
Public
Cannot fork because you own this repository and are not a member of any organizations.
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
Settings
leetcodeJava1/src/com/wenqu/leetcode/offerTest.java /
@qwert233xu
qwert233xu Add files via upload
Latest commit 190933b 2 weeks ago
 History
 1 contributor
243 lines (191 sloc)  5.63 KB

import org.junit.jupiter.api.Test;
import java.util.List;
class offerTest {

    @Test
    void fib() {
        offer offer = new offer();
        int n = 45;
        int res = offer.fib(n);
        System.out.println(res);  // 预期：134903163
    }

    @Test
    void numWays() {
        offer offer = new offer();
        int n = 100;

        int res = offer.numWays(n);
        System.out.println(res);

    }

    @Test
    void maxProfit() {
        offer offer = new offer();
//        int[] prices = new int[]{7, 1, 5, 3, 6, 4};
        int[] prices = new int[]{0, 2};

        int res = offer.maxProfit(prices);
        System.out.println(res);

    }

    @Test
    void maxSubArray() {
        offer offer = new offer();
        int[] nums = new int[]{-2,1,-3,4,-1,2,1,-5,4};
        int res = offer.maxSubArray(nums);
        System.out.println(res);
    }

    @Test
    void maxValue() {

        offer offer = new offer();
        int[][] grid = new int[][]{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
        int res = offer.maxValue(grid);
        System.out.println(res);
    }

    @Test
    void translateNum() {

        offer offer = new offer();
        int num = 12258;
        int res = offer.translateNum(num);  // 5
        System.out.println(res);
    }

    @Test
    void lengthOfLongestSubstring() {

        offer offer = new offer();
        String s = "abcabcbb";
        int res = offer.lengthOfLongestSubstring(s);
        System.out.println(res);

    }

    @Test
    void deleteNode() {
        offer offer = new offer();
        offer.ListNode root = new offer.ListNode(-3);
        root.next = new offer.ListNode(5);
        root.next.next = new offer.ListNode(-99);
        int val = -3;
        offer.ListNode res = offer.deleteNode(root, val);

        while (res != null){
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    void getKthFromEnd() {
        offer offer = new offer();
        offer.ListNode root = new offer.ListNode(1);
        root.next = new offer.ListNode(2);
        root.next.next = new offer.ListNode(3);
        root.next.next.next = new offer.ListNode(4);
        root.next.next.next.next = new offer.ListNode(5);
        int k = 2;
        offer.ListNode res = offer.getKthFromEnd(root, k);

        while (res != null){
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    void reverseWords() {

        offer offer = new offer();
        String des = "   the sky is blue   ";
        String res = offer.reverseWords(des);
        System.out.println(res);
    }

    @Test
    public void testPathSum() {
//        输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
//        输出：[[5,4,11,2],[5,8,4,5]]
//        tree -> doublelist -> sort
//        no.k
        offer app = new offer();
        TreeNode root = new TreeNode(5);
        root.left = new TreeNode(4);
        root.right = new TreeNode(8);
        root.right.left = new TreeNode(13);
        root.right.right = new TreeNode(4);
        root.right.right.left = new TreeNode(5);
        root.right.right.right = new TreeNode(1);
        root.left.left = new TreeNode(11);
        root.left.left.left = new TreeNode(7);
        root.left.left.right = new TreeNode(2);

        int target = 26;
        List<List<Integer>> res = app.pathSum(root, target);

        System.out.println(res);

    }

    @Test
    public void testTreeToDoublyList() {
        offer app = new offer();
        Node root = new Node(4);
        root.left = new Node(2);
        root.left.left = new Node(1);
        root.left.right = new Node(3);
        root.right = new Node(5);
        Node res = app.treeToDoublyList(root);


    }
    @Test
    public void testKthLargest() {
        offer app = new offer();
        TreeNode root = new TreeNode(5);
        root.left = new TreeNode(3);
        root.right = new TreeNode(6);
        root.left.left = new TreeNode(2);
        root.left.right = new TreeNode(4);
        root.left.left.left = new TreeNode(1);
        int k = 3;
        int res = app.kthLargest(root, k);
        System.out.println(res); //4
    }

    @Test
    void minNumber() {

        offer offer = new offer();
        int[] des = new int[]{1, 2, 3, 5, 6, 7, 8, 9, 0};
        String res = offer.minNumber(des);
        System.out.println(res);

    }


    @Test
    void isStraight() {

    }

    @Test
    void getLeastNumbers() {

    }

    @Test
    void maxDepth() {

    }

    @Test
    void isBalanced() {

    }

    @Test
    void sumNums() {

    }

    @Test
    void lowestCommonAncestor() {

    }

    @Test
    void lowestCommonAncestor2() {

    }

    @Test
    void buildTree() {

        offer offer = new offer();
        int[] preorder = new int[]{};
        int[] inorder = new int[]{};
        TreeNode res = offer.buildTree(preorder, inorder);
        System.out.println(res.val);
    }

    @Test
    void myPow() {

        offer offer = new offer();
//        double x = 2.00000;
//        double x = 2.10000;
//        double x = 2.00000;
//        double x = 1.00000;
        double x = 2;
//        int n = 10;
//        int n = 3;
//        int n = -2;
//        int n = 2147483647;
        int n = -1;
        double res = offer.myPow(x, n);
        System.out.println(res);
    }

    @Test
    void cuttingRope() {
        offer offer = new offer();

        int res = offer.cuttingRope(10);
        System.out.println(res);
    }
}

// ======== End 剑指offer1 java ========

///////////////////////////////////////////////////////////

// ======== Start 牛客网Top101 java ========

Skip to content
Search or jump to…
Pull requests
Issues
Codespaces
Marketplace
Explore
 
@qwert233xu 
qwert233xu
/
leetcodeJava1
Public
Cannot fork because you own this repository and are not a member of any organizations.
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
Settings
leetcodeJava1/src/com/wenqu/leetcode/App.java /
@qwert233xu
qwert233xu Update App.java
Latest commit c6ec73c 2 weeks ago
 History
 1 contributor
3578 lines (3144 sloc)  108 KB

package com.xu;

import java.util.*;

/**
 * 牛客网  Top101
 *
 */
public class App 
{

    public static void main(String[] args )
    {
        System.out.println( "Hello World!" );
    }

    /** 单链表
     * 1.反转链表 递归实现
     * @param root
     * @return
     */
    public ListNode ReverseList(ListNode root) {
        //终止条件
        if (root == null || root.next == null)
            return root;
        //保存当前节点的下一个结点
        ListNode next = root.next;
        //从当前节点的下一个结点开始递归调用
        ListNode reverse = ReverseList(next);
        //reverse是反转之后的链表，因为函数reverseList
        // 表示的是对链表的反转，所以反转完之后next肯定
        // 是链表reverse的尾结点，然后我们再把当前节点
        //head挂到next节点的后面就完成了链表的反转。
        next.next = root;
        //这里head相当于变成了尾结点，尾结点都是为空的，
        //否则会构成环
        root.next = null;
        return reverse;
    }
    /**
     * 1.反转链表 栈实现
     * @param root
     * @return
     */
    public ListNode ReverseList2(ListNode root) {
        if (root == null || root.next == null) return root;

        Stack<ListNode> stack = new Stack<>();

        while (root.next != null){
            stack.push(root);
            root = root.next;
        }

        ListNode temp = root;
        while (!stack.isEmpty()){
            temp.next = stack.peek();
            stack.pop();
            temp.next.next = null;
            temp = temp.next;
        }
        return root;
    }

    /**
     * 1.反转链表 双链表实现
     * @param root
     * @return
     */
    public ListNode ReverseList3(ListNode root) {
        if (root == null || root.next == null) return root;

        ListNode newHead = null;
        while (root!= null){
            ListNode temp = root.next;
            root.next = newHead;
            newHead = root;
            root = temp;
        }
        return newHead;
    }

    /**
     * 2.链表内指定区间内反转    局部反转 + 切断
     * @param head
     * @param m
     * @param n
     * @return
     */
    public ListNode reverseBetween (ListNode head, int m, int n) {
        // write code here
        ListNode virtualHead = new ListNode(-1);
        virtualHead.next = head;

        ListNode pre = virtualHead;

        for (int i = 0; i < m - 1; i++) {
            pre = pre.next;
        }
        ListNode left = pre.next;

        ListNode right = pre;
        for (int i = 0; i < n - m + 1; i++) {
            right = right.next;
        }
        ListNode cur = right.next;

        //4.切断链接
        pre.next=null;
        right.next=null;

        // 局部遍历
        reverseList(left);

        pre.next = right;
        left.next = cur;

        return virtualHead.next;
    }
    public void reverseList(ListNode head){
        ListNode pre = null;
        ListNode cur = head;

        while (cur != null){
            ListNode cur_next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = cur_next;
        }
    }

    /**
     * 2.链表内指定区间内反转   一次遍历优化
     * @param head
     * @param m
     * @param n
     * @return
     */
    public ListNode reverseBetween2 (ListNode head, int m, int n) {
        // write code here
        ListNode virtualHead = new ListNode(-1);
        virtualHead.next = head;

        ListNode pre = virtualHead;

        for (int i = 0; i < m - 1; i++) {
            pre = pre.next;
        }
        
        ListNode cur = pre.next;
        ListNode Cur_next = null;
        for (int i = 0; i < n - m; i++) {
            Cur_next = cur.next;
            cur.next = Cur_next.next;
            Cur_next .next = pre.next;
            pre.next = Cur_next ;
        }
        return virtualHead.next;
    }

    /**
     * 3.链表中的节点每 k 个一组翻转  递归实现
     * @param head
     * @param k
     * @return
     */
    public ListNode reverseKGroup (ListNode head, int k) {
        //找到每次翻转的尾部
        ListNode tail = head;
        //遍历k次到尾部
        for(int i = 0; i < k; i++){
            //如果不足k到了链表尾，直接返回，不翻转
            if(tail == null)
                return head;
            tail = tail.next;
        }
        //翻转时需要的前序和当前节点
        ListNode pre = null;
        ListNode cur = head;
        //在到达当前段尾节点前
        while(cur != tail){
            //翻转
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        //当前尾指向下一段要翻转的链表
        head.next = reverseKGroup(tail, k);
        return pre;
    }

    /**
     * 4.合并两个排序的链表
     * @param list1
     * @param list2
     * @return
     */
    public ListNode Merge(ListNode list1,ListNode list2) {
        // list1 list2为空的情况
        if(list1 == null || list2 == null){
            return list1 != null ? list1 : list2;
        }
        // 两个链表元素依次对比
        if(list1.val <= list2.val){
            // 递归计算 list1.next, list2
            list1.next = Merge(list1.next, list2);
            return list1;
        }else{
            // 递归计算 list1, list2.next
            list2.next = Merge(list1, list2.next);
            return list2;
        }
    }

    /**
     * 5.合并k个排序的链表    归并排序
     * @param lists
     * @return
     */
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        return divide(lists, 0, lists.size() - 1);
    }

    // 合并两个链表
    // 依次顺序比较两个链表的节点值
    public ListNode Merge2(ListNode list1, ListNode list2){
        if (list1 == null){
            return list2;
        }
        if (list2 == null){
            return list1;
        }

        ListNode head = new ListNode(0);
        ListNode cur = head;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1;
                list1 = list1.next;
                cur = cur.next;
            } else {
                cur.next = list2;
                list2 = list2.next;
                cur = cur.next;
            }
        }

        if (list1 != null){
            cur.next = list1;
        }
        if (list2 != null){
            cur.next = list2;
        }

        return head.next;

    }

    // 划分区间
    // 递归调用处理每个分治后的小区间
    // 采用二分法处理每个小区间
    public ListNode divide(ArrayList<ListNode> lists, int left, int right){

        if (left > right){
            return null;
        }
        if (left == right){
            return lists.get(left);
        }

        int mid = (left + right) / 2;
        return Merge2(divide(lists, left, mid), divide(lists, mid + 1, right));
    }

    /**
     * 6.判断链表中是否有环   时间复杂度 O（n）
     * @param head
     * @return
     */
    public boolean hasCycle(ListNode head) {
        // 使用快慢指针 一个走两步，一个走一步，当重合时必定有环
        if (head == null || head.next == null){
            return false;
        }

        ListNode virHead = new ListNode(-1);
        virHead.next = head;

        ListNode slow = virHead;
        ListNode swift = virHead;

        while (swift.next != null && swift.next.next != null){
            slow = slow.next;
            swift = swift.next.next;
            if (slow == swift){
                return true;
            }
        }

        return false;
    }

    /**
     * 7.链表中环的入口节点   时间复杂度 O（n）
     * @param pHead
     * @return
     */
    public ListNode EntryNodeOfLoop(ListNode pHead) {

        if (pHead == null){
            return null;
        }

        ListNode virHead = new ListNode(-1);
        virHead.next = pHead;

        ListNode slow = virHead;
        ListNode swift = virHead;

        while (swift != null && swift.next!= null){
            slow = slow.next;
            swift = swift.next.next;
            if (slow == swift){
                break;
            }
        }
        // 当条件不满足时，一定存在环
        if (swift == null || swift.next == null){
            return null;
        }

        swift = virHead;
        while (swift != slow){
            swift = swift.next;
            slow = slow.next;
        }
        return swift;
    }

    /**
     * 8.链表中倒数最后 k 个节点   时间复杂度 O（n）
     * @param pHead
     * @param k
     * @return
     */
    public ListNode FindKthToTail (ListNode pHead, int k) {
        // write code here
        if (pHead == null) {
            return null;
        }

        ListNode temp = pHead;
        int count = 0;
        while (temp != null){
            count ++;
            temp = temp.next;
        }

        if (k  > count){
            return null;
        }

        ListNode cur = pHead;
        for (int i = 0; i < count - k; i++) {
            cur = cur.next;
        }
        return cur;
    }

    /**
     * 9.删除链表中倒数第 k 个节点   时间复杂度 O（n）
     * @param head
     * @param n
     * @return
     */
    public ListNode removeNthFromEnd (ListNode head, int n) {
        // write code here
        if (head == null) {
            return null;
        }

        ListNode temp = head;
        int count = 0;
        while (temp != null){
            count ++;
            temp = temp.next;
        }

        if (n  > count){
            return null;
        }else if (n == count){
            return head.next;
        }

        ListNode cur = head;
        ListNode virHead = new ListNode(-1);
        virHead.next = head;
        ListNode pre = virHead;
        for (int i = 0; i < count - n; i++) {
            pre = pre.next;
            cur = cur.next;
        }

        pre.next = cur.next;
        return head;
    }

    /**
     * 10.两个链表的第一个公共节点   时间复杂度 O（n）
     * @param pHead1
     * @param pHead2
     * @return
     */
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {

        ListNode temp = pHead1;
        ListNode temp2 = pHead2;

        int count1 = 0;
        int count2 = 0;
        while (temp != null){
            count1 ++;
            temp = temp.next;
        }

        while (temp2 != null){
            count2 ++;
            temp2 = temp2.next;
        }

        int index = Math.abs(count1 - count2);

        temp = pHead1;
        temp2 = pHead2;

        if (count1 > count2){
            for (int i = 0; i < index; i++) {
                temp = temp.next;
            }
        }else if (count1 < count2){
            for (int i = 0; i < index; i++) {
                temp2 = temp2.next;
            }
        }

        while (temp != null){

            if (temp == temp2){
                break;
            }
            temp = temp.next;
            temp2 = temp2.next;
        }

        return temp;
    }

    /**
     * 11.链表相加（二）   时间复杂度 O（n） 空间复杂度 O（n）
     * @param head1 ListNode类
     * @param head2 ListNode类
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        if (head1 == null){
            return head2;
        }
        if (head2 == null){
            return head1;
        }
        // 使用栈
        Stack<ListNode> listNodeStack = new Stack<>();
        Stack<ListNode> listNodeStack2 = new Stack<>();

        ListNode temp = head1;
        ListNode temp2 = head2;

        while (temp != null){
            listNodeStack.push(temp);
            temp = temp.next;
        }

        while (temp2 != null){
            listNodeStack2.push(temp2);
            temp2 = temp2.next;
        }

        int count = Math.min(listNodeStack.size(), listNodeStack2.size());
        ListNode virHead = new ListNode(-1);
        ListNode te = virHead;
        int JinWei = 0;
        for (int i = 0; i < count; i++) {
            int addValue = listNodeStack.peek().val + listNodeStack2.peek().val;
            addValue += JinWei;
            listNodeStack.pop();
            listNodeStack2.pop();
            if (addValue >= 10){
                JinWei = 1;
                addValue %= 10;
            }else {
                JinWei = 0;
            }
            te.next = new ListNode(addValue);
            te = te.next;
        }
        if (listNodeStack.isEmpty()){
            while (!listNodeStack2.isEmpty()){
                int value = listNodeStack2.peek().val;
                value += JinWei;
                listNodeStack2.pop();
                if (value >= 10){
                    JinWei = 1;
                    value %= 10;
                }else {
                    JinWei = 0;
                }
                te.next = new ListNode(value);
                te = te.next;
            }
        }else if (listNodeStack2.isEmpty()){
            while (!listNodeStack.isEmpty()){
                int value = listNodeStack.peek().val;
                value += JinWei;
                listNodeStack.pop();
                if (value >= 10){
                    JinWei = 1;
                    value %= 10;
                }else {
                    JinWei = 0;
                }
                te.next = new ListNode(value);
                te = te.next;
            }
        }

        if (JinWei == 1){
            te.next = new ListNode(1);
        }


//        return virHead.next;
        return reverseListNode(virHead.next);
    }

    // 反转链表
    public ListNode reverseListNode(ListNode head){

        ListNode pre = null;
        ListNode cur = head;

        while (cur != null){
            ListNode curNext = cur.next;
            cur.next = pre;
            pre = cur;
            cur = curNext;
        }
        return pre;
    }

    /**
     * 12. 单链表的排序    时间复杂度 O(nlogn)
     * @param head 头节点
     * @return ListNode类
     */
    public ListNode sortInList (ListNode head) {
        // write code here
        ListNode temp = head;
        int count = 0;
        while (temp != null){
            temp = temp.next;
            count ++;
        }
        int[] ints = new int[count];

        temp = head;
        for (int i = 0; i < count; i++) {
            ints[i] = temp.val;
            temp = temp.next;
        }

        Arrays.sort(ints);

        ListNode virHead = new ListNode(-1);
        ListNode te = virHead;
        for (int i = 0; i < count; i++) {
            te.next = new ListNode(ints[i]);
            te = te.next;
        }

        return virHead.next;
    }


    /**
     * 13. 判断一个链表是否为回文结构
     * 方法一：将链表节点的值加入list
     * 方法二：使用快慢指针
     * @param head ListNode类 the head
     * @return bool布尔型
     */
    public boolean isPail (ListNode head) {
        if (head == null || head.next == null){
            return true;
        }

        // write code here
        // 快慢指针
        ListNode fast = head;
        ListNode slow = head;


        ListNode temp = head;
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            temp = temp.next;
        }
        // fast 不为空，说明链表节点个数为奇数个
        if (fast != null){
            slow = slow.next;
        }

        // 反转前半部分链表
        slow = reverse13(slow);
        fast = head;

        while (slow != null){
            if (slow.val != fast.val){
                return false;
            }
            slow = slow.next;
            fast = fast.next;
        }
        return true;
    }

    public ListNode reverse13(ListNode head){

        ListNode pre = null;
        ListNode cur = head;

        while (cur != null){
            ListNode cur_next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = cur_next;
        }
        return pre;
    }

    /**
     * 14. 链表的奇偶重排
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 奇偶指针
     * @param head ListNode类
     * @return ListNode类
     */
    public ListNode oddEvenList (ListNode head) {
        // write code here
        if (head == null || head.next == null || head.next.next == null){
            return head;
        }
        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = even;
        while (even != null && even.next != null){
            odd.next = even.next;
            even.next = odd.next.next;
            odd = odd.next;
            even = even.next;
        }
        odd.next = evenHead;

        return head;
    }
    /**
     * 15. 删除有序链表中重复的元素1
     * @param head ListNode类
     * @return ListNode类
     */
    public ListNode deleteDuplicates (ListNode head) {
        // write code here
        if (head == null || head.next == null){
            return head;
        }
        ListNode virHead = new ListNode(-200);
        virHead.next = head;

        ListNode pre = virHead;
        ListNode cur = head;
        boolean flag = false;
        while (cur != null){  // 其实时间复杂度还为 O（n）
            while (pre.val == cur.val){
                if (cur.next != null){
                    cur = cur.next;
                }else {
                    flag = true;
                    pre.next = null;
                    break;
                }
            }
            if (flag){
                break;
            }
            pre.next = cur;
            pre = cur;
            cur = cur.next;
        }

        return head;
    }

    /**
     * 16. 删除有序链表中重复的元素2
     * 要求：空间复杂度 O(n), 时间复杂度：O(n)
     * 进阶：空间复杂度 O(1), 时间复杂度：O(n)
     * @param head ListNode类
     * @return ListNode类
     */
    public ListNode deleteDuplicates2 (ListNode head) {
        ListNode newhead = new ListNode(0);//设置一个初始链表
        newhead.next = head;//将head链表添加到newhead中
        ListNode pre = newhead;
        ListNode cur = head;
        int count = 0;//设置重复次数
        while(cur != null && cur.next != null){//判断条件
            if(cur.val == cur.next.val){//如果按照顺序，值相等
                cur.next = cur.next.next;//删除该元素
                count++;//将count次数加一再次进行判断
            }
            else{
                if(count > 0){
                    pre.next = cur.next;//将该元素值全部删除
                    count = 0;
                }
                else
                    pre = cur;
                cur = cur.next;//递归条件
            }
        }
        if(count > 0)//存在比如{1，2，2}，因为删除，所以上述循环条件不进行判断，在此额外进行判断
            pre.next = cur.next;
        return newhead.next;
    }

    /** 排序
     * 1. 二分查找
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 递归和迭代法
     * @param nums int整型一维数组
     * @param target int整型
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        if (nums.length == 0) return -1;

        int left = 0;
        int right = nums.length;

        while (left <= right){
            int mid = (left + right) / 2;
            if (nums[mid] > target){
                right = mid - 1;
            }else if (nums[mid] < target){
                left = mid + 1;
            }else {
                return mid;
            }
        }

        return -1;
    }

    /**
     * 2.寻找峰值
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 暴力遍历 时间复杂度为 O（n）  ->  O(logN)
     * @param nums int整型一维数组
     * @return int整型
     */
    public int findPeakElement (int[] nums) {
        // write code here
        int left = 0;
        int right = nums.length - 1;

        while (left < right){
            int mid = (left + right) / 2;
            if (nums[mid] > nums[mid + 1]){
                right = mid;
            }else {
                left = mid + 1;
            }
        }
        return right;
    }

    static final int kmod = 1000000007;
    int count = 0;
    /**
     * 3.数组中的逆序对
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 时间复杂度：O（nlogn）  空间复杂度：O（n）
     *
     *
     * @param array int整型一维数组
     * @return int整型
     */
    public int InversePairs(int [] array) {
        int[] temp = new int[array.length];
        merge_rec(array, 0, array.length - 1, temp);
        return count;
    }

    // 递归过程
    public void merge_rec(int[] array, int left, int right, int[] temp){
        if (left == right){
            return;
        }
        int mid = (left + right) / 2;
        merge_rec(array, left, mid, temp);
        merge_rec(array, mid + 1, right, temp);
        merge(array, left, mid, right, temp);
    }

    // 合并过程
    public void merge(int[] array, int left, int mid, int right, int[] temp){

        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right){
            if (array[i] < array[j]){
                temp[k++] = array[i++];
            }else {
                temp[k++] = array[j++];
//                count += 1;
                count += (mid - i + 1);
                count %= kmod;
            }
        }

        while (i <= mid){
            temp[k++] = array[i++];
        }

        while (j<=right){
            temp[k++] = array[j++];
        }

        for (int k2 = 0, t = left; t <= right; k2++, t++) {
            array[t] = temp[k2];
        }
    }

    /**
     * 利用优先队列排序的demo
     * @param arr
     * @return
     */
    public int[] PriorityQueueSort(int[] arr){

        PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);  // 从小到大
            }
        });

        for (int i = 0; i < arr.length; i++) {
            queue.add(arr[i]);
        }
        int[] newarr = new int[arr.length];

        for (int i = 0; i < arr.length; i++) {
            newarr[i] = queue.poll();
        }
        return newarr;
    }

    /**
     * 4.比较版本号
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 空间复杂度： O（1）  时间复杂度： O（n）
     * 比较版本号
     * @param version1 string字符串
     * @param version2 string字符串
     * @return int整型
     */
    public int compare (String version1, String version2) {
        int n1 = version1.length();
        int n2 = version2.length();
        int i = 0, j = 0;
        //直到某个字符串结束
        while(i < n1 || j < n2){
            long num1 = 0;
            //从下一个点前截取数字
            while(i < n1 && version1.charAt(i) != '.'){
                num1 = num1 * 10 + (version1.charAt(i) - '0');
                i++;
            }
            //跳过点
            i++;
            long num2 = 0;
            //从下一个点前截取数字
            while(j < n2 && version2.charAt(j) != '.'){
                num2 = num2 * 10 + (version2.charAt(j) - '0');
                j++;
            }
            //跳过点
            j++;
            //比较数字大小
            if(num1 > num2)
                return 1;
            if(num1 < num2)
                return -1;
        }
        //版本号相同
        return 0;
    }

    /** 二叉树
     * 1.二叉树的前序遍历、中序遍历、后序遍历
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @return int整型一维数组
     */
//    public int[] preorderTraversal (TreeNode root) {
//        // write code here
//    }
      /*
        std::vector<int> preorderTraversal(TreeNode* root){
            std::vector<int> res;
            dfs(root, res);
            return res;
        }
        void dfs(TreeNode *root, std::vector<int>& res){
            if(root == NULL){
                return;
            }
            res.push_back(root->val);
            dfs(root->left, res);
            dfs(root->right, res);
        }
      */


    /**
     * 2.二叉树的层序遍历
     * @param root TreeNode类
     * @return int整型ArrayList<ArrayList<>>
     */
    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        // write code here
        if (root == null) return new ArrayList<>();

        LinkedList<TreeNode> q = new LinkedList<>();
        q.addLast(root);
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();

        while (!q.isEmpty()){
            ArrayList<Integer> temp = new ArrayList<>();
            int len = q.size();
            for (int i = 0; i < len; i++) {
                TreeNode t = q.getFirst();
                temp.add(t.val);
                q.removeFirst();
                if (t.left != null) q.addLast(t.left);
                if (t.right!= null) q.addLast(t.right);
            }
            res.add(temp);
        }
        return res;
    }

    /**
     * 3.按Z字形顺序打印二叉树
     * @param pRoot TreeNode类
     * @return int整型ArrayList<ArrayList<>>
     */
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if (pRoot == null) return new ArrayList<>();

        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        LinkedList<TreeNode> q = new LinkedList<>();
        q.addLast(pRoot);

        int level = 0;
        while (!q.isEmpty()){
            ArrayList<Integer> temp = new ArrayList<>();
            int len = q.size();
            for (int i = 0; i < len; i++) {
                TreeNode t = q.getFirst();
                if (level % 2 == 0){
                    temp.add(t.val);
                }else {
                    temp.add(0, t.val);
                }
                q.removeFirst();
                if (t.left != null) q.addLast(t.left);
                if (t.right!= null) q.addLast(t.right);
            }
            level ++;
            res.add(temp);
        }
        return res;
    }

    /**
     * 4.二叉树的最大深度
     * 空间复杂度： O（1）  时间复杂度： O（n）
     * 可以使用递归方法求解，也可以通过层序遍历求解
     * 本题使用递归求解
     * @param root TreeNode类
     * @return int整型
     */
    public int maxDepth (TreeNode root) {
        // write code here
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }


    /**
     * 5.二叉树中和为某一值的路径1
     * 空间复杂度： O（n）  时间复杂度： O（n）
     * 进阶：空间复杂度： O（树的高度）  时间复杂度： O（n）
     * 实质为二叉树的前序遍历
     * @param root TreeNode类
     * @param sum int整型
     * @return bool布尔型
     */
    public boolean hasPathSum (TreeNode root, int sum) {
        // write code here
        if (root == null){
            return false;
        }
        return hasPathSum_dfs(root, sum);
    }

    public boolean hasPathSum_dfs(TreeNode root, int sum){
        if (root == null){ // 不是叶子节点的情况，也没找到路径
            return false;
        }

        sum -= root.val;

        if (root.left == null && root.right == null && sum == 0){ // 叶子节点且已找到路径
            return true;
        }

        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum); // 是否可以剪枝？
    }

    /**
     * 6.二叉搜索树与双向链表
     * 方法一：使用中间数组  空间复杂度：O（n）  时间复杂度：O（n）
     * 方法二：原树上进行   空间复杂度： O（1）  时间复杂度： O（n）
     * 二叉搜索树的中序遍历即升序
     * @param pRootOfTree TreeNode类
     * @return bool布尔型
     */
    public TreeNode Convert(TreeNode pRootOfTree) {
        if (pRootOfTree == null) return null;
        TreeNode headList = pRootOfTree;
        while (headList.left != null){
            headList = headList.left;
        }
        Convert_dfs(pRootOfTree);
        return headList;
    }

    TreeNode preNode = null;
    public void Convert_dfs(TreeNode pRootOfTree){
        if (pRootOfTree == null){
            return;
        }
        Convert_dfs(pRootOfTree.left);

        pRootOfTree.left = preNode;

        if (preNode != null){
            preNode.right = pRootOfTree; // 存在重复指向，但是没有影响，并且必要
        }
        preNode = pRootOfTree;
        Convert_dfs(pRootOfTree.right);
    }

    /**
     * 7.对称的二叉树
     * 空间复杂度： O（n）  时间复杂度： O（n）
     * 方法一：递归  后序遍历
     * 方法二：迭代
     * @param pRoot TreeNode类
     * @return bool布尔型
     */
    boolean isSymmetrical(TreeNode pRoot) {
        return isSymmetrical_dfs(pRoot, pRoot);
    }

    public boolean isSymmetrical_dfs(TreeNode pRoot1, TreeNode pRoot2){
        if (pRoot1 == null && pRoot2 == null){
            return true;
        }

        if (pRoot1 == null || pRoot2 == null || pRoot1.val != pRoot2.val){
            return false;
        }

        return isSymmetrical_dfs(pRoot1.left, pRoot2.right) && isSymmetrical_dfs(pRoot1.right, pRoot2.left);
    }


    /**
     * 8.合并二叉树
     * 空间复杂度 o（1）  时间复杂度 O（n）
     * @param t1 TreeNode类
     * @param t2 TreeNode类
     * @return TreeNode类
     */
    public TreeNode mergeTrees (TreeNode t1, TreeNode t2) {
        // write code here
        if (t1 == null){
            return t2;
        }

        if (t2 == null){
            return t1;
        }

        TreeNode head = new TreeNode(t1.val + t2.val);
        head.left = mergeTrees(t1.left, t2.left);
        head.right = mergeTrees(t1.right, t2.right);
        System.out.println(head.val);
        return head; // 因为其他根节点没有接受，所以覆盖返回最开始的那一个
    }


    /**
     * 9.二叉树的镜像
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 空间复杂度： O（n）  时间复杂度： O（n）
     * 进阶：空间复杂度： O（1）  时间复杂度： O（n）
     *
     * @param pRoot TreeNode类
     * @return TreeNode类
     */
    public TreeNode Mirror (TreeNode pRoot) {
        // write code here
        if (pRoot == null){
            return null;
        }

        TreeNode temp = pRoot.left;
        pRoot.left = pRoot.right;
        pRoot.right = temp;

        pRoot.left = Mirror(pRoot.left);
        pRoot.right = Mirror(pRoot.right);

        return pRoot;
    }

    TreeNode preNode2 = null;
    /**
     * 10.判断是不是二叉搜索树
     * 这道题和 6.二叉树转双向链表是一样的思路
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param root TreeNode类
     * @return bool布尔型
     */
    public boolean isValidBST (TreeNode root) {
        // write code here
        return isValidBST_dfs(root);
    }

    public boolean isValidBST_dfs(TreeNode root){
        if (root == null){
            return true;
        }

        boolean l = isValidBST_dfs(root.left);

//        root.left = preNode2;
        if (preNode2!=null){
//            preNode2.right = root;
            if (preNode2.val > root.val){
                return false;
            }
        }
        preNode2 = root;

        boolean r = isValidBST_dfs(root.right);

        return l&&r;
    }

    /**
     * 11.判断是不是完全二叉树
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 根据完全二叉树的定义，采用层序遍历，当出现null时，发现null后还有节点则不是完全二叉树，反之则是
     *
     * @param root TreeNode类
     * @return bool布尔型
     */
    public boolean isCompleteTree (TreeNode root) {
        // write code here
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        boolean flag = false;
        while (!q.isEmpty()){
            TreeNode temp = q.poll();

            if (temp == null){
                flag = true;
            }else {
                if (flag){
                    return false;
                }
                q.offer(temp.left);
                q.offer(temp.right);
            }
        }
        return true;
    }


    boolean isBalanced = true;
    /**
     * 12.判断是不是平衡二叉树
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 空间复杂度 o（1）  时间复杂度 O（n）
     * 后序遍历，自底向上
     * @param root TreeNode类
     * @return bool布尔型
     */
    public boolean IsBalanced_Solution(TreeNode root) {
        IsBalanced_Solution_dfs(root);
        return isBalanced;
    }

    public int IsBalanced_Solution_dfs(TreeNode root){
        if (root == null){
            return 0;
        }

        int l = IsBalanced_Solution_dfs(root.left);

        int r = IsBalanced_Solution_dfs(root.right);

        if (Math.abs(l - r) > 1){
            isBalanced = false;
        }

        return 1 + Math.max(l, r);
    }

    /**
     * 13.二叉树的最近公共祖先
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *  方法一：搜索路径比较 ：通过比较两个目标节点的路径，比较路径数组最后一个相等的元素便是最近公共祖先
     *  方法二：二叉树递归
     *
     * @param root TreeNode类
     * @param p int整型
     * @param q int整型
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int p, int q) {
        // write code here
        // 递归实现
        lowestCommonAncestor_dfs(root, p, q);
        return target;
    }
    int target = 0;
//    boolean flag = true;
    // 前序遍历
    public void lowestCommonAncestor_dfs(TreeNode root, int p, int q){
        if (root == null){
            return;
        }

        if (root.val > p && root.val > q){
            lowestCommonAncestor(root.left, p, q);
        } else if (root.val < p && root.val < q){
            lowestCommonAncestor(root.right, p, q);
        } else {
//            if (flag){
                target = root.val;
//                flag = false;
//            }
        }
    }

    /**
     * 14.在二叉树中找到两个节点的最近公共祖先
     * 方法一：路径法 BFS（层序遍历找到节点）
     * 方法二：递归法
     *
     * @param root TreeNode类
     * @param o1 int整型
     * @param o2 int整型
     * @return int整型
     */
    public int lowestCommonAncestor2 (TreeNode root, int o1, int o2) {
        // write code here
        // 1.路径法
        return -1;
    }

    public int lowestCommonAncestor3 (TreeNode root, int o1, int o2) {
        // write code here
        // 2.递归法
        return lowestCommonAncestor3_dfs(root, o1, o2).val;
    }

    public TreeNode lowestCommonAncestor3_dfs(TreeNode root, int o1, int o2){

        if (root == null || root.val == o1 | root.val == o2){
            return root;
        }

        TreeNode left = lowestCommonAncestor3_dfs(root.left, o1, o2);
        TreeNode right = lowestCommonAncestor3_dfs(root.right, o1, o2);

        if (left == null){
            return right;
        }

        if (right == null){
            return left;
        }

        return root;
    }

    int INF = 0x3f3f3f3f;
    TreeNode emptyNode = new TreeNode(INF);
    /**
     * 15.序列化二叉树
     * 序列化可以按照前序、中序、后序
     * 使用层序序列化和反序列化
     * */
    String Serialize(TreeNode root) {
        if (root == null) return "";

        StringBuilder res = new StringBuilder();
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);


        while (!q.isEmpty()) {
            // 每次从队列中取出元素进行「拼接」，包括「正常节点」和「叶子节点对应的首位空节点」
            TreeNode poll = q.poll();
            res.append(poll.val + "_");
            // 如果取出的节点不为「占位节点」，则继续往下拓展，同时防止「占位节点」不继续往下拓展
            if (!poll.equals(emptyNode)) {
                q.offer(poll.left != null ? poll.left : emptyNode);
                q.offer(poll.right != null ? poll.right : emptyNode);
            }
        }
        return res.toString();
    }

    TreeNode Deserialize(String str) {
        if (str.equals("")) return null;

        // 根据分隔符进行分割
        String[] ss = str.split("_");
        int n = ss.length;
        // 怎么序列化就怎么反序列化
        // 使用队列进行层序遍历，起始先将 root 构建出来，并放入队列
        TreeNode root = new TreeNode(Integer.parseInt(ss[0]));
        Deque<TreeNode> d = new ArrayDeque<>();
        d.addLast(root);
        for (int i = 1; i < n - 1; i += 2) {
            TreeNode poll = d.pollFirst();
            // 每次从中取出左右节点对应 val
            int a = Integer.parseInt(ss[i]), b = Integer.parseInt(ss[i + 1]);
            // 如果左节点对应的值不是 INF，则构建「真实节点」
            if (a != INF) {
                poll.left = new TreeNode(a);
                d.addLast(poll.left);
            }
            // 如果右节点对应的值不是 INF，则构建「真实节点」
            if (b != INF) {
                poll.right = new TreeNode(b);
                d.addLast(poll.right);
            }
        }
        return root;
    }

    /**
     * 16.输出二叉树的右视图
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 求二叉树的右视图
     * 思路：先按照前序和中序遍历恢复二叉树，再按照层序遍历判断当某节点右边没有其余节点是则该节点为右边界节点
     * @return int整型一维数组
     */
    public int[] solve (int[] xianxu, int[] zhongxu) {
        // 重建二叉树
        TreeNode rebuildTree = rebuildTree(xianxu, zhongxu);
        // 层序遍历找到右边界节点
        ArrayList<ArrayList<Integer>> arrayLists = solve_levelOrder(rebuildTree);

        int[] res = new int[arrayLists.size()];
        for (int i = 0; i < arrayLists.size(); i++) {
            res[i] = arrayLists.get(i).get(arrayLists.get(i).size() - 1);
        }

        return res;
    }

    // 寻找索引
    public int findIndex(int[] arr, int target){
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target){
                return i;
            }
        }
        return -1;
    }

    // 切片
    public int[] slice(int[] arr, int start, int end){
        int[] res = new int[end - start];
        System.arraycopy(arr, start, res, 0, res.length);
        return res;
    }

    // 恢复二叉树
    public TreeNode rebuildTree(int[] pre, int[] in){
        if (pre.length == 0){
            return null;
        }

        TreeNode root = new TreeNode(pre[0]);
        int indexOfRootOnIn = findIndex(in, pre[0]);
        root.left = rebuildTree(slice(pre, 1, indexOfRootOnIn + 1), slice(in, 0, indexOfRootOnIn));
        root.right = rebuildTree(slice(pre, indexOfRootOnIn + 1, pre.length), slice(in, indexOfRootOnIn + 1, in.length));
        return root;
    }

    // 层序遍历二叉树
    public ArrayList<ArrayList<Integer>> solve_levelOrder (TreeNode root) {
        // write code here
        if (root == null) return new ArrayList<>();

        LinkedList<TreeNode> q = new LinkedList<>();
        q.addLast(root);
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();

        while (!q.isEmpty()){
            ArrayList<Integer> temp = new ArrayList<>();
            int len = q.size();
            for (int i = 0; i < len; i++) {
                TreeNode t = q.getFirst();
                temp.add(t.val);
                q.removeFirst();
                if (t.left != null) q.addLast(t.left);
                if (t.right!= null) q.addLast(t.right);
            }
            res.add(temp);
        }
        return res;
    }

    static class MyStackMin{
        Stack<Map<Integer, Integer>> stack;

        public MyStackMin() {
            this.stack = new Stack<>();
        }

        /** 堆/栈/队列
         * 1.包含 min 函数的栈
         *  一个正常栈 和 一个最小值栈   时间复杂度为 O（1） 空间复杂度为 O（n）
         *  原栈上操作（加入元组的概念）  时间复杂度为 O（1） 空间复杂度为 O（1）    x , min
         */
        public void push(int node) {
            if (stack.isEmpty()){
                HashMap<Integer, Integer> map = new HashMap<>();
                map.put(node, node);
                stack.push(map);
                return;
            }
            int peakElementMin = 0;
            for (Map.Entry<Integer, Integer> entry : stack.peek().entrySet()) {
                peakElementMin = entry.getValue();
                break;
            }

            if (node > peakElementMin){
                HashMap<Integer, Integer> map = new HashMap<>();
                map.put(node, peakElementMin);
                stack.push(map);
            }else {
                HashMap<Integer, Integer> map = new HashMap<>();
                map.put(node, node);
                stack.push(map);
            }

        }

        public void pop() {
            if (!stack.isEmpty()){
                stack.pop();
            }
        }

        public int top() {
            if (!stack.isEmpty()){
                for (Map.Entry<Integer, Integer> entry : stack.peek().entrySet()) {
                    return entry.getKey();
                }
            }
            return -20000;
        }

        public int min() {
            if (!stack.isEmpty()){
                for (Map.Entry<Integer, Integer> entry : stack.peek().entrySet()) {
                    return entry.getValue();
                }
            }
            return -20000;
        }
    }

    Stack<Character> stack_isValid;
    /**
     * 2.有效括号序列
     * 时间复杂度 O（n）  空间复杂度 O（n）
     *
     * @param s string字符串
     * @return bool布尔型
     */
    public boolean isValid (String s) {
        // write code here
        stack_isValid = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{'){
                stack_isValid.push(c);
            }else if (c == ')'){
                if (!stack_isValid.isEmpty()){
                    Character peek = stack_isValid.peek();
                    if (peek != '('){
                        return false;
                    }
                    stack_isValid.pop();
                }else {
                    return false;
                }

            }else if (c == ']'){
                if (!stack_isValid.isEmpty()){
                    Character peek = stack_isValid.peek();
                    if (peek != '['){
                        return false;
                    }
                    stack_isValid.pop();
                }else {
                    return false;
                }

            }else if (c == '}'){
                if (!stack_isValid.isEmpty()){
                    Character peek = stack_isValid.peek();
                    if (peek != '{'){
                        return false;
                    }
                    stack_isValid.pop();
                }else {
                    return false;
                }
            }
        }

        return stack_isValid.isEmpty();
    }

    /**
     * 3.滑动窗口的最大值
     * 时间复杂度 O（n）  空间复杂度 O（n）
     *
     * 考虑最大值队列
     * @param num int数组
     * @param size int
     * @return ArrayList<Integer>
     */
    public ArrayList<Integer> maxInWindows(int [] num, int size) {
        if (num.length == 0 || size > num.length || size == 0){
            return new ArrayList<>();
        }

        ArrayList<Integer> ret = new ArrayList<>();
        LinkedList<Integer> dq = new LinkedList<>();

        for (int i = 0; i < num.length; ++i) {
            while (!dq.isEmpty() && num[dq.getLast()] < num[i]) {
                dq.removeLast();
            }
            dq.addLast(i);
            // 判断队列的头部的下标是否过期
            if (dq.getFirst() + size <= i) {
                dq.removeFirst();
            }
            // 判断是否形成了窗口
            if (i + 1 >= size) {
                ret.add(num[dq.getFirst()]);
            }
        }
        return ret;
    }

    /**
     * 4.最小的k个数
     * 空间复杂度 O（n）  时间复杂度 O（nlogk）
     * 使用快排解决，空间复杂度为 O（1），平均时间复杂度为 O（n）
     *
     * @param input int数组
     * @param k int
     * @return ArrayList<Integer>
     */
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> ret = new ArrayList<>();
        if (k==0 || k > input.length) return ret;
        int l = 0, r = input.length;
        while (l < r) {
            int p = GetLeastNumbers_Solution_quickSort(input, l, r);
            if (p+1 == k) {
                ArrayList<Integer> integers = new ArrayList<>();
                for (int i = 0; i < k; i++) {
                    integers.add(input[i]);
                }
                return integers;
            }
            if (p+1 < k) {
                l = p + 1;
            }
            else {
                r = p;
            }

        }
        return ret;
    }

    public int GetLeastNumbers_Solution_quickSort(int[] input, int l, int r){

        int pivot = input[r-1]; // 最后一个值作为分割点
        int i = l;
        for (int j=l; j<r-1; ++j) {
            if (input[j] < pivot) {
                int temp = input[j];
                input[j] = input[i];
                input[i] = temp;
                i++;
            }
        }
        int temp = input[i];
        input[i] = input[r-1];
        input[r-1] = temp;
        return i;
    }

    /**
     * 5.寻找第k大的元素
     * 空间复杂度 O（1）  时间复杂度 O（nlogn）
     * 使用优先队列
     *
     * @param a int数组
     * @param n int
     * @param K int
     * @return int
     */
    public int findKth(int[] a, int n, int K) {
        // write code here
        if (n == 0 || K > n) return -1;
        PriorityQueue<Integer> q = new PriorityQueue<>();
        for (int i = 0; i < K; i++) {
            q.add(a[i]);
        }

        for (int i = K; i < n; i++) {
            if (q.peek() < a[i]){
                q.poll();
                q.add(a[i]);
            }

        }

        return q.peek();
    }

    //小顶堆，元素数值都比大顶堆大
    private PriorityQueue<Integer> max = new PriorityQueue<>();
    //大顶堆，元素数值较小
    private PriorityQueue<Integer> min = new PriorityQueue<>((o1, o2)->o2.compareTo(o1));
    //维护两个堆，取两个堆顶部即与中位数相关
    /**
     * 6.数据流中的中位数
     * 空间复杂度 O（n）  时间复杂度 O（nlogn）
     *
     *
     * @param num int数组
     */
    public void Insert(Integer num) {
        //先加入较小部分
        min.offer(num);
        //将较小部分的最大值取出，送入到较大部分
        max.offer(min.poll());
        //平衡两个堆的数量
        if(min.size() < max.size())
            min.offer(max.poll());
    }

    public Double GetMedian() {
        //奇数个
        if(min.size() > max.size())
            return (double)min.peek();
        else
            //偶数个
            return (double)(min.peek() + max.peek()) / 2;
    }


    // 使用 map 维护一个运算符优先级（其中加减法优先级相同，乘法有着更高的优先级）
    Map<Character, Integer> map = new HashMap<Character, Integer>(){{
        put('-', 1);
        put('+', 1);
        put('*', 2);
    }};
    /**
     * 7.表达式求值
     *
     * 空间复杂度 O（n）时间复杂度 O（n）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 返回表达式的值
     * @param s string字符串 待计算的表达式
     * @return int整型
     */
    public int solve(String s) {
        // 将所有的空格去掉
        s = s.replaceAll(" ", "");

        char[] cs = s.toCharArray();
        int n = s.length();

        // 存放所有的数字
        Deque<Integer> nums = new ArrayDeque<>();
        // 为了防止第一个数为负数，先往 nums 加个 0
        nums.addLast(0);
        // 存放所有「非数字以外」的操作
        Deque<Character> ops = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            char c = cs[i];
            if (c == '(') {
                ops.addLast(c);
            } else if (c == ')') {
                // 计算到最近一个左括号为止
                while (!ops.isEmpty()) {
                    if (ops.peekLast() != '(') {
                        calc(nums, ops);
                    } else {
                        ops.pollLast();
                        break;
                    }
                }
            } else {
                if (isNumber(c)) {
                    int u = 0;
                    int j = i;
                    // 将从 i 位置开始后面的连续数字整体取出，加入 nums
                    while (j < n && isNumber(cs[j])) u = u * 10 + (cs[j++] - '0');
                    nums.addLast(u);
                    i = j - 1;
                } else {
                    if (i > 0 && (cs[i - 1] == '(' || cs[i - 1] == '+' || cs[i - 1] == '-')) {
                        nums.addLast(0);
                    }
                    // 有一个新操作要入栈时，先把栈内可以算的都算了
                    // 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算
                    while (!ops.isEmpty() && ops.peekLast() != '(') {
                        char prev = ops.peekLast();
                        if (map.get(prev) >= map.get(c)) {
                            calc(nums, ops);
                        } else {
                            break;
                        }
                    }
                    ops.addLast(c);
                }
            }
        }
        // 将剩余的计算完
        while (!ops.isEmpty() && ops.peekLast() != '(') calc(nums, ops);
        return nums.peekLast();
    }
    // 计算逻辑：从 nums 中取出两个操作数，从 ops 中取出运算符，然后根据运算符进行计算即可
    void calc(Deque<Integer> nums, Deque<Character> ops) {
        if (nums.isEmpty() || nums.size() < 2) return;
        if (ops.isEmpty()) return;
        int b = nums.pollLast(), a = nums.pollLast();
        char op = ops.pollLast();
        int ans = 0;
        if (op == '+') ans = a + b;
        else if (op == '-') ans = a - b;
        else if (op == '*') ans = a * b;
        nums.addLast(ans);
    }
    boolean isNumber(char c) {
        return Character.isDigit(c);
    }


    /** 哈希
     * 1.两数之和
     *
     * 空间复杂度 O（n）   时间复杂度 O（nlogn）   使用 hash 时间复杂度为 O（n）  哈希表查找的时间复杂度为 O（1）
     * @param numbers int整型一维数组
     * @param target int整型
     * @return int整型一维数组
     */
    public int[] twoSum (int[] numbers, int target) {
        // write code here
        HashMap<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < numbers.length; i++) {
            if (map.containsKey(target - numbers[i])){
                return new int[]{map.get(target - numbers[i]) + 1, i+1};
            }else {
                map.put(numbers[i], i);
            }
        }

        throw new IllegalArgumentException("No solution");
    }

    /**
     * 2.数组中出现次数超过一半的数字
     *
     * 空间复杂度为 O（1） 时间复杂度为 O（n）
     * @param array
     * @return
     */
    public int MoreThanHalfNum_Solution(int [] array) {
        if (array.length == 1) return array[0];
        int targetLen = array.length / 2;

        HashMap<Integer, Integer> map = new HashMap<>();

        for (int j : array) {
            if (map.containsKey(j)) {
                int newValue = map.get(j) + 1;
                map.put(j, newValue);
                if (newValue > targetLen) {
                    return j;
                }
            } else {
                map.put(j, 1);
            }
        }

        return -1;
    }


    /**
     * 3.数组中只出现一次的两个数字
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 空间复杂度为 O（1） 时间复杂度为 O（n）
     * @param array int整型一维数组
     * @return int整型一维数组
     */
    public int[] FindNumsAppearOnce (int[] array) {
        // write code here

        HashMap<Integer, Integer> map = new HashMap<>();

        for (int i : array) {
            if (map.containsKey(i)) {
                int newValue = map.get(i) + 1;
                map.put(i, newValue);
            } else {
                map.put(i, 1);
            }
        }

        int[] res = new int[2];
        int c = 0;
        for (Map.Entry<Integer, Integer> integerIntegerEntry : map.entrySet()) {
            if (integerIntegerEntry.getValue() == 1){
                res[c++] = integerIntegerEntry.getKey();
            };
        }

        return res;
    }

    /**
     * 4.缺失的第一个正整数
     *
     * 空间复杂度为 O（1） 时间复杂度为 O（n）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param nums int整型一维数组
     * @return int整型
     */
    public int minNumberDisappeared (int[] nums) {
        // write code here
        int n = nums.length;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, 1);
        }
        int c = 1;
        while (map.containsKey(c)){
            c++;
        }

        return c;
    }

    /**
     * 5.三数之和
     *
     * 空间复杂度为 O（n2） 时间复杂度为 O（n2）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 方法一：双指针
     * 方法二：回溯
     * @param num int整型一维数组
     * @return ArrayList<ArrayList<Integer>>
     */
    public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
        if (num.length < 3) return new ArrayList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();

        Arrays.sort(num);
        for (int i = 0; i < num.length; i++) {
            if(i>0 && num[i]==num[i-1])continue;
            int j = i+1;
            int k = num.length - 1;
            while (j < k){
                if (num[i] + num[j] + num[k] > 0){
                    k --;
                }else if (num[i] + num[j] + num[k] < 0){
                    j ++;
                }else {
                    ArrayList<Integer> temp = new ArrayList<>();
                    temp.add(num[i]);
                    temp.add(num[j]);
                    temp.add(num[k]);
                    res.add(temp);
                    while (num[j] == num[j+1] && j+1 < k){
                        j++;
                    }
                    while (num[k-1] == num[k] && k-1>j){
                        k--;
                    }
                    j++;
                    k--;
                }
            }

        }

        return res;
    }

    /** 递归/回溯
     * 1.没有重复项数组的全排列
     *
     * 空间复杂度为 O（n！） 时间复杂度为 O（n！）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param num int整型一维数组
     * @return ArrayList<ArrayList<Integer>>
     */
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
        if (num.length == 0) return new ArrayList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        ArrayList<Integer> temp = new ArrayList<>();

        boolean[] used = new boolean[num.length];
        permute_dfs(res, temp, num);

        return res;
    }

    public void permute_dfs(ArrayList<ArrayList<Integer>> res, ArrayList<Integer> temp,int[] num){
        if (temp.size() == num.length){
            res.add(new ArrayList<>(temp));
            return;
        }

        for (int j : num) {
            if (temp.contains(j)) continue;
            temp.add(j);
            permute_dfs(res, temp, num);
            temp.remove(temp.size() - 1);
        }
    }


    /**
     * 2.有重复项数字的全排列
     *
     * 空间复杂度为 O（n！） 时间复杂度为 O（n！）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param num int整型一维数组
     * @return ArrayList<ArrayList<Integer>>
     */
    public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
        if (num.length == 0) return new ArrayList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        ArrayList<Integer> temp = new ArrayList<>();
        Arrays.sort(num);

        boolean[] used = new boolean[num.length];
        permuteUnique_dfs(res, temp, num, used);

        return res;


    }

    public void permuteUnique_dfs(ArrayList<ArrayList<Integer>> res, ArrayList<Integer> temp,int[] num, boolean[] used) {
        if (temp.size() == num.length){
            res.add(new ArrayList<>(temp));
            return;
        }

        for (int j = 0; j < num.length; j++) {
            if (used[j]) continue;
            if (j > 0 && num[j] == num[j-1] && !used[j-1]){
                continue;
            }

            temp.add(num[j]);
            used[j] = true;
            permuteUnique_dfs(res, temp, num, used);
            temp.remove(temp.size() - 1);
            used[j] = false;
        }
    }

    /**
     * 3.判断岛屿数量
     *
     * dfs 和 bfs解法
     * 1代表陆地，0代表海洋，考虑相邻上下左右
     * @param grid char字符型二维数组
     * @return int整型
     */
    public int solve (char[][] grid) {
        // write code here
        // dfs
        if (grid.length == 0) return 0;

        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1'){
                    count++;
                    solve_dfs(grid, i, j);
                }
            }
        }
        return count;
    }
    public void solve_dfs(char[][] grid, int i, int j){

        grid[i][j] = '0'; // 当前置为 0

        if (i - 1 >= 0 && grid[i - 1][j] == '1'){
            solve_dfs(grid, i - 1, j);
        }
        if (i + 1 < grid.length && grid[i + 1][j] == '1'){
            solve_dfs(grid, i + 1, j);
        }
        if (j - 1 >= 0 && grid[i][j - 1] == '1'){
            solve_dfs(grid, i, j - 1);
        }
        if (j + 1 < grid[0].length && grid[i][j + 1] == '1'){
            solve_dfs(grid, i, j + 1);
        }

    }

    public int solve2 (char[][] grid) {
        // write code here
        // bfs
        if (grid.length == 0) return 0;
        int count = 0;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {

                Queue<Integer> queue1 = new ArrayDeque<>(); // 队列存放二维坐标  i
                Queue<Integer> queue2 = new ArrayDeque<>(); // 队列存放二维坐标  j

                if (grid[i][j] == '1') {
                    queue1.add(i);
                    queue2.add(j);

                    while (!queue1.isEmpty() && !queue2.isEmpty()){

                        int x = queue1.poll();
                        int y = queue2.poll();

                        grid[x][y] = '0';

                        if (x - 1 >= 0 && grid[x - 1][y] == '1'){
                            queue1.add(x - 1);
                            queue2.add(y);
                            grid[x - 1][y] = '0';
                        }
                        if (x + 1 < grid.length && grid[x + 1][y] == '1'){
                            queue1.add(x + 1);
                            queue2.add(y);
                            grid[x + 1][y] = '0';
                        }
                        if (y - 1 >= 0 && grid[x][y - 1] == '1'){
                            queue1.add(x);
                            queue2.add(y - 1);
                            grid[x][y - 1] = '0';
                        }
                        if (y + 1 < grid[0].length && grid[x][y + 1] == '1'){
                            queue1.add(x);
                            queue2.add(y + 1);
                            grid[x][y + 1] = '0';
                        }
                    }
                    count ++;
                    }
                }
            }
        return count;
    }

    /**
     * 4.字符串的排列
     *
     * 空间复杂度为 O（n！）
     * 时间复杂度为 O（n！）
     * @param str
     * @return ArrayList<String> 数组
     */
    public ArrayList<String> Permutation(String str) {
        if (str.length() == 0) return new ArrayList<>();
        ArrayList<String> res = new ArrayList<>();

        boolean[] used = new boolean[str.length()];
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        Permutation_backtrack(chars, res, new StringBuilder(), used);

        return res;
    }


    public void Permutation_backtrack(char[] str, ArrayList<String> res, StringBuilder temp, boolean[] used){
        if (temp.length() == str.length){
            res.add(temp.toString());
            return;
        }

        for (int i = 0; i < str.length; i++) {
            if (used[i]){
                continue;
            }

            if(i > 0 && str[i - 1] == str[i] && !used[i - 1]) // 剪枝很重要，不然会超时
                //当前的元素str[i]与同一层的前一个元素str[i-1]相同且str[i-1]已经用过了
                continue;

            temp.append(str[i]);
            used[i] = true;
            Permutation_backtrack(str, res, temp, used);
            temp.deleteCharAt(temp.length() - 1);
            used[i] = false;
        }
    }

    Set<Integer> column = new HashSet<Integer>(); //标记列不可用
    Set<Integer> posSlant = new HashSet<Integer>();//标记正斜线不可用
    Set<Integer> conSlant = new HashSet<Integer>();//标记反斜线不可用
    int result = 0;
    /**
     * 5.n皇后问题
     * 空间复杂度 O（1）
     * 时间复杂度 O（n！）
     * @param n int整型 the n
     * @return int整型
     */
    public int Nqueen (int n) {
        // write code here
        compute(0, n); // 0 代表皇后计数， n代表皇后总数
        return result;
    }
    private void compute(int i, int n){
        if(i == n){ // 皇后计数满足皇后总数，则存在一种排列方案
            result++;
            return;
        }
        for(int j = 0; j < n; j++){
            if(column.contains(j) || posSlant.contains(i - j) || conSlant.contains(i + j)){
                continue;
            }
            column.add(j);//列号j
            posSlant.add(i - j);//行号i - 列号j 正斜线
            conSlant.add(i + j);//行号i + 列号j 反斜线
            compute(i + 1, n); //计算下一行
            column.remove(j); //完成上一步递归计算后，清除
            posSlant.remove(i - j);
            conSlant.remove(i + j);
        }
    }

    /**
     * 6.括号生成
     * 空间复杂度 O（n）
     * 时间复杂度 O（2^n）
     *
     * @param n int整型
     * @return string字符串ArrayList
     */
    public ArrayList<String> generateParenthesis (int n) {
        // write code here
        if (n == 0) return new ArrayList<>();

        ArrayList<String> res = new ArrayList<>();

        generateParenthesis_backTrack(res, new StringBuilder(), 0, 0, n);

        return res;
    }

    public void generateParenthesis_backTrack(ArrayList<String> res, StringBuilder temp, int leftCount, int rightCount, int n){
        if (leftCount == n && rightCount == n){
            res.add(temp.toString());
            return;
        }

        if (leftCount < n){
            temp.append("(");
            generateParenthesis_backTrack(res, temp, leftCount + 1, rightCount, n);
            temp.deleteCharAt(temp.length() - 1);
        }
        if (rightCount < leftCount && rightCount < n){
            temp.append(")");
            generateParenthesis_backTrack(res, temp, leftCount, rightCount + 1, n);
            temp.deleteCharAt(temp.length() - 1);
        }
    }

    /**
     * 7.矩阵最长递增路径
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 递增路径的最大长度
     * @param matrix int整型二维数组 描述矩阵的每个数
     * @return int整型
     */
    //记录四个方向
    private int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 分别对应 上下
    private int n, m;
    //深度优先搜索，返回最大单元格数
    public int dfs(int[][] matrix, int[][] dp, int i, int j) {
        if(dp[i][j] != 0)
            return dp[i][j];
        dp[i][j]++;
        for (int k = 0; k < 4; k++) {
            int nexti = i + dirs[k][0];
            int nextj = j + dirs[k][1];
            //判断条件
            if(nexti >= 0 && nexti < n && nextj >= 0 && nextj < m && matrix[nexti][nextj] > matrix[i][j]) // 没有越界，并且递增
                dp[i][j] = Math.max(dp[i][j], dfs(matrix, dp, nexti, nextj) + 1);
        }
        return dp[i][j];
    }
    public int solve (int[][] matrix) {
        //矩阵不为空
        if (matrix.length == 0 || matrix[0].length == 0)
            return 0;
        int res = 0;
        n = matrix.length;
        m = matrix[0].length;
        //i，j处的单元格拥有的最长递增路径
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                //更新最大值
                res = Math.max(res, dfs(matrix, dp, i, j));
        return res;
    }


    /** 动态规划
     * 1.跳台阶
     *
     * 时间复杂度 O（n）  空间复杂度 O（1）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param target 整数
     * @return int
     */
    public int jumpFloor(int target) {
        int[] dp = new int[target + 1];

        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= target; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }

        return dp[target];
    }

    /**
     * 2.最小花费爬楼梯
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param cost int整型一维数组
     * @return int整型
     */
    public int minCostClimbingStairs (int[] cost) {
        // write code here
        int[] dp = new int[cost.length + 1];

        for (int i = 2; i <= cost.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); // dp[2] 是 索引下标为 0 和 1花费的最小值
        }

        return dp[cost.length];
    }


    String res = "";
    /**
     * 3.最长公共子序列2
     *
     * 时间复杂度 O(n^2) 空间复杂度 O(n^2)
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        // write code here
        if (s1.length() == 0 || s2.length() == 0) return "-1";

        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        int[][] record = new int[s1.length() + 1][s2.length() + 1]; // 1表示左上方、2表示左方、3表示上方

        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    record[i][j] = 1; // 记录左上方
                }else {
                    if (dp[i - 1][j] > dp[i][j - 1]){
                        dp[i][j] = dp[i - 1][j];
                        record[i][j] = 3;
                    }else {
                        dp[i][j] = dp[i][j - 1];
                        record[i][j] = 2;
                    }
                }
            }
        }

        // 根据 record 拼接 字符串
        ans(s1.length(), s2.length(), record, s1, s2);

        if(!res.isEmpty()){
            return res;
        }else {
            return "-1";
        }
    }

    public void ans(int i, int j, int[][] record, String s1, String s2){
        if (i == 0 || j == 0){
            return;
        }

        if (record[i][j] == 1){
            ans(i - 1, j - 1, record, s1, s2);
            res += s1.charAt(i - 1);

        }else {
            if (record[i][j] == 2){
                ans(i, j - 1, record, s1, s2);
            }else {
                ans(i - 1, j, record, s1, s2);

            }
        }
    }


    /**
     * 4.最长公共子串
     *
     * 时间复杂度 O(n^2) 空间复杂度 O(n^2)
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public String LCS2 (String str1, String str2) {
        // write code here
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];
        int maxLen = 0;
        int maxLastIndex = 0;

        for (int i = 0; i < str1.length(); i++) {
            for (int j = 0; j < str2.length(); j++) {
                if (str1.charAt(i) == str2.charAt(j)){
                    dp[i + 1][j + 1] = dp[i][j] + 1;

                    if (dp[i + 1][j + 1] > maxLen) {
                        maxLen = dp[i + 1][j+1];
                        maxLastIndex = i;
                    }
//                    maxLen = Math.max(dp[i + 1][j + 1], maxLen);
//                    maxLastIndex = i;
                }else {
                    dp[i + 1][j + 1] = 0;  // 注意这里和最长公共子序列的区别
                }
            }
        }

        return str1.substring(maxLastIndex - maxLen + 1, maxLastIndex + 1);
    }

    /**
     * 5.不同路径的数目1
     *
     * 时间复杂度 O（mn）  空间复杂度 O（mn）
     * 进阶 空间复杂度 O（1）  时间复杂度 O（min（m,n））
     * @param m int整型
     * @param n int整型
     * @return int整型
     */
    public int uniquePaths (int m, int n) {
        // write code here
        if (m == 1 || n == 1) return 1;

        int[][] dp = new int[m + 1][n + 1];

        //第一行初始化，只有一条路径
        for(int i=0;i<n;i++){
            dp[0][i] = 1;
        }
        //第一列初始化，只有一条路径
        for(int i=0;i<m;i++){
            dp[i][0] =1;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }

    int res2 = 0; // 使用回溯 会超时
    public int uniquePaths2 (int m, int n) {
        // write code here
        uniquePaths2_dfs(m, n, 0 , 0);
        return res2;
    }

    public void uniquePaths2_dfs(int m, int n, int i, int j){
        if (i < 0 || i >= m || j < 0 || j >= n){
            return;
        }
        if ((i == m - 1) && (j == n - 1)){
            res2 += 1;
        }

        uniquePaths2_dfs(m, n, i, j+1);
        uniquePaths2_dfs(m, n, i + 1, j);

    }


    /**
     * 6.矩阵的最小路径和
     * @param matrix int整型二维数组 the matrix
     * @return int整型
     */
    public int minPathSum (int[][] matrix) {
        // write code here
        int[][] dp = new int[matrix.length][matrix[0].length];

        dp[0][0] = matrix[0][0];

        for (int i = 1; i < matrix.length; i++) {
            dp[i][0] = dp[i - 1][0] + matrix[i][0];
        }

        for (int i = 1; i < matrix[0].length; i++) {
            dp[0][i] = dp[0][i - 1] + matrix[0][i];
        }

        for (int i = 1; i < matrix.length; i++) {
            for (int j = 1; j < matrix[0].length; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j];
            }
        }

        return dp[matrix.length - 1][matrix[0].length - 1];
    }


    /**
     * 7.把数字翻译成字符串
     * 解码
     *
     * 时间复杂度 O（n）  空间复杂度 O（n）
     * 'a' -> 1,  'b' -> 2,  'z' -> 26
     * @param nums string字符串 数字串
     * @return int整型
     */
    public int solve2 (String nums) {
        // write code here
        if (nums.equals("0")) return 0;
        if (nums.equals("10") || nums.equals("20")) return 1;
        if (nums.length() == 1) return 1;


        // 当0的前面不是 1或者2时无法译码
        for (int i = 1; i < nums.length(); i++) {
            if (nums.charAt(i) == '0'){
                if (nums.charAt(i - 1) != '1' && nums.charAt(i - 1) != '2'){
                    return 0;
                }
            }
        }

        int[] dp = new int[nums.length() + 1];

        dp[0] = 1;

        if (((nums.charAt(0) - '0') * 10 + (nums.charAt(1) - '0') >= 11 && (nums.charAt(0) - '0') * 10 + (nums.charAt(1) - '0') <= 19)
                || ((nums.charAt(0) - '0') * 10 + (nums.charAt(1) - '0') >= 21 && (nums.charAt(0) - '0') * 10 + (nums.charAt(1) - '0') <= 26)) {
            // 存在两中译码方案
            dp[1] = 2;
        }else {
            dp[1] = 1;
        }

        for (int i = 2; i < nums.length(); i++) {
            if (((nums.charAt(i-1) - '0') * 10 + (nums.charAt(i) - '0') >= 11 && (nums.charAt(i-1) - '0') * 10 + (nums.charAt(i) - '0') <= 19)
            || ((nums.charAt(i-1) - '0') * 10 + (nums.charAt(i) - '0') >= 21 && (nums.charAt(i-1) - '0') * 10 + (nums.charAt(i) - '0') <= 26)){
                // 存在两中译码方案
                dp[i] = dp[i - 1] + dp[i - 2];
            }else {
                // 只有一种译码方案
                dp[i] = dp[i - 1];
            }
        }

        return dp[nums.length() - 1];
    }

    /**
     * 8.兑换零钱1
     *
     * 最少货币数
     *
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] arr, int aim) {
        // write code here
        if (aim < 1) return 0;
        int[] dp = new int[aim + 1];  //dp[i] 表示要凑出 i 元钱需要的最小货币数

        Arrays.fill(dp, aim + 1); // 填充为最大货币数
        dp[0] = 0;

        for (int i = 1; i <= aim; i++) { // 遍历容量
            for (int k : arr) { // 遍历货币
                if (k <= i) {
                    dp[i] = Math.min(dp[i], dp[i - k] + 1);
                }
            }
        }
        return dp[aim] > aim?-1:dp[aim];
    }

    /**
     * 9.最长上升子序列1
     *
     * 时间复杂度 O（n^2）  空间复杂度 O（n）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 给定数组的最长严格上升子序列的长度。
     * @param arr int整型一维数组 给定的数组
     * @return int整型
     */
    public int LIS (int[] arr) {
        // write code here
        int n=arr.length;
        //特殊请款判断
        if(n==0) return 0;
        //dp[i]表示以下标i结尾的最长上升子序列长度
        int[] dp=new int[n];
        //初始化为1
        Arrays.fill(dp, 1);
        int res = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(arr[i]>arr[j]){
                    //只要前面某个数小于当前数，则要么长度在之前基础上加1，要么保持不变，取较大者
                    dp[i]=Math.max(dp[i],dp[j]+1); // 以 i 索引结尾的最长上升子序列的最大值
                }
            }
            res = Math.max(dp[i], res); // 更新最大值
        }
        //返回所有可能中的最大值
        return res;
    }

    /**
     * 10.连续子数组的最大值
     *
     * 时间复杂度 O（n）  空间复杂度 O（n）
     * 进阶：时间复杂度 O（n）  空间复杂度 O（1）
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 给定数组的最长严格上升子序列的长度。
     * @param array int整型一维数组 给定的数组
     * @return int整型
     */
    public int FindGreatestSumOfSubArray(int[] array) {
        if (array.length == 1) return array[0];

        int[] dp = new int[array.length]; // dp 代表以 i 结尾子串和的最大值
        dp[0] = array[0];
        int res = 0;

        for (int i = 1; i < array.length; i++) {
            dp[i] = Math.max(array[i], dp[i - 1] + array[i]);
            res = Math.max(res, dp[i]); // 因为并不是最后一个为最大值
        }

        return dp[array.length - 1];
    }

    // 进阶
    public int FindGreatestSumOfSubArray2(int[] array) {
        int sum = 0;
        int max = array[0];
        for (int j : array) {
            // 优化动态规划，确定sum的最大值
            sum = Math.max(sum + j, j);
            // 每次比较，保存出现的最大值
            max = Math.max(max, sum);
        }
        return max;
    }


    /**
     * 11.最长回文字串
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param A string字符串
     * @return int整型
     */
    public int getLongestPalindrome (String A) {
        // write code here
        if (A.length() == 0) return 0;

        boolean[][] dp = new boolean[A.length()][A.length()]; // dp 表示 前一个索引 到 后一个索引是否构成回文串
        int res = 0;

        for (int c = 0; c <= A.length(); c++) {  // 遍历字串长度 c 为字串长度
            for (int left = 0; left + c < A.length(); left++) { // left 左边界
                int right = left + c; // right 右边界
                if (A.charAt(left) == A.charAt(right)){
                    if (c <= 1){
                        dp[left][right] = true;
                    }else {
                        dp[left][right] = dp[left + 1][right - 1];
                    }

                    if (dp[left][right]){
                        res = c + 1;
                    }

                }
            }
        }
        return res;
    }

    /**
     * 12.数字字符串转换成 IP 地址
     *
     * 回溯 + 剪枝
     * 空间复杂度 O（n！）  时间复杂度 O（n！）
     * @param s string字符串
     * @return string字符串ArrayList
     */
    //记录分段IP数字字符串
    private String nums = "";
    //step表示第几个数字，index表示字符串下标
    public void dfs(String s, ArrayList<String> res, int step, int index){
        //当前分割出的字符串
        String cur = "";
        //分割出了四个数字
        if(step == 4){
            //下标必须走到末尾
            if(index != s.length())
                return;
            res.add(nums);
        }else{
            //最长遍历3位
            for(int i = index; i < index + 3 && i < s.length(); i++){
                cur += s.charAt(i);
                //转数字比较
                int num = Integer.parseInt(cur);
                String temp = nums;
                //不能超过255且不能有前导0
                if(num <= 255 && (cur.length() == 1 || cur.charAt(0) != '0')){
                    //添加点
                    if(step - 3 != 0) // 最后一个不能加 .
                        nums += cur + ".";
                    else
                        nums += cur;
                    //递归查找下一个数字
                    dfs(s, res, step + 1, i + 1);
                    //回溯
                    nums = temp;
                }
            }
        }
    }
    public ArrayList<String> restoreIpAddresses(String s) {
        ArrayList<String> res = new ArrayList<String>();
        dfs(s, res, 0, 0);
        return res;
    }


    /**
     * 13. 打家劫舍1
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param nums int整型一维数组
     * @return int整型
     */
    public int rob (int[] nums) {
        // write code here
        // dp[i]表示长度为i的数组，最多能偷取多少钱
        int[] dp = new int[nums.length + 1];
        //长度为1只能偷第一家
        dp[1] = nums[0];
        for(int i = 2; i <= nums.length; i++)
            //对于每家可以选择偷或者不偷
            dp[i] = Math.max(dp[i - 1], nums[i - 1] + dp[i - 2]); // 注意这里 nums[i - 1] 因为 i - 1 就是当前家
        return dp[nums.length];
    }

    /**
     * 14. 打家劫舍2
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param nums int整型一维数组
     * @return int整型
     */
    public int rob2 (int[] nums) {
        // write code here
        int[] dp = new int[nums.length + 1];
        dp[1] = nums[0];
        // 最后一家不偷
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        int res = dp[nums.length];
        Arrays.fill(dp, 0);
        // 第一家不偷
        dp[1] = 0;
        for (int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }

        return Math.max(res, dp[nums.length]);
    }


    /**
     * 15. 买卖股票的最好时机1
     *
     * @param prices int整型一维数组
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        if (prices.length < 2) return 0;

        int[][] dp = new int[prices.length][2]; // dp[i][0]表示第i天不持股，dp[i][1]表示第i天持股
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);

        }

        return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
    }

    /**
     * 16. 买卖股票的最好时机2
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算最大收益
     * @param prices int整型一维数组 股票每一天的价格
     * @return int整型
     */
    public int maxProfit2 (int[] prices) {
        // write code here
        if (prices.length < 2) return 0;

        int[][] dp = new int[prices.length][2]; // dp[i][0]表示第i天不持股，dp[i][1]表示第i天持股
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] -prices[i]);

        }

        return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
    }

    /**
     * 17. 买卖股票的最好时机3
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 两次交易所能获得的最大收益
     * @param prices int整型一维数组 股票每一天的价格
     * @return int整型
     */
    public int maxProfit3 (int[] prices) {
        // write code here
        int[][] dp = new int[prices.length][5];
        // dp[i][0] 表示第i天为止还没购买股票
        // dp[i][1] 表示第i天为止购买一次股票，还没卖出的情况
        // dp[i][2] 表示第i天为止购买一个股票且卖出一次股票的情况
        // dp[i][3] 表示第i天为止购买两次股票且卖出一次股票的情况
        // dp[i][4] 表示第i天为止购买两次股票且卖出两次股票的情况
        Arrays.fill(dp[0], -10000);

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
            dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
            dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3]);
            dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4]);
        }

        return Math.max(dp[prices.length - 1][2], Math.max(0, dp[prices.length - 1][4]));
    }

    /**
     * 18. 编辑距离1
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 对字符串的三种操作
     * 插入、删除、修改
     *
     * @param str1 string字符串
     * @param str2 string字符串
     * @return int整型
     */
    public int editDistance (String str1, String str2) {
        // write code here
        int[][] dp = new int[str1.length() + 1][str2.length() + 1]; // dp 表示第 第一个字符串首部到 第 i 位的字串 修改到 第二个字符串首部到 第 j 位的字符需要修改的距离

        // 初始化边界
        for (int i = 1; i <= str1.length(); i++) {
            dp[i][0] = dp[i - 1][0] + 1;
        }
        for (int i = 1; i <= str2.length(); i++) {
            dp[0][i] = dp[0][i - 1] + 1;
        }

        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1];
                }else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }

        return dp[str1.length()][str2.length()];
    }


    /** 字符串
     * 1. 字符串变形
     *
     * 时间复杂度 O（n）  空间复杂度 O（n）
     *
     * @param s string字符串
     * @param n int整型
     * @return string字符串
     */
    public String trans(String s, int n) {
        // write code here
        if (s.length() == 0 || n == 0) return "";
        char[] chars = s.toCharArray();

        for (int i = 0; i < n; i++) {
            if (chars[i] == ' '){
                continue;
            }
            if (chars[i] >= 'a' && chars[i] <= 'z'){
                String temp = chars[i] + "";
                chars[i] = temp.toUpperCase().charAt(0);
            }else {
                String temp = chars[i] + "";
                chars[i] = temp.toLowerCase().charAt(0);
            }
        }

        System.out.println(chars);

        StringBuilder res1 = new StringBuilder();

        String t = "";
        for (char c:chars){
            if (c == ' '){
                res1.append(t);
                res1.append(' ');
                t = "";
            }else {
                t+=c;
            }
        }
        res1.append(t);
        System.out.println(res1);

        StringBuilder r = new StringBuilder();
        String[] s1 = res1.toString().split(" ");

        if (s1.length == 0) return s;

        for (int i = s1.length - 1; i >=0 ; i--) {
            r.append(s1[i]);
            r.append(" ");
        }
        r.delete(r.length()-1, r.length());

        System.out.println(r);

        if (res1.length() > r.length()){
            r.insert(0, res1.substring(r.length(), res1.length()));
        }

        return r.toString();
    }

    /**
     * 2.最长公共前缀
     *
     * 时间复杂度 O（n*len）  空间复杂度 O（1）
     * @param strs string字符串一维数组
     * @return string字符串
     */
    public String longestCommonPrefix (String[] strs) {
        // write code here
        if (strs.length == 0) return "";
        if (strs.length == 1) return strs[0];
        int minLenIndex = 0;
        for (int i = 1; i < strs.length; i++) {
            if (strs[i].length() < strs[i-1].length()){
                minLenIndex = i;
            }
        }

        String minStr = strs[minLenIndex];

        int count = 0;
        int cc = minStr.length();
        for (int i = 0; i < cc; i++) {
            for (String str : strs) {
                if (str.startsWith(minStr)) {
                    count++;
                } else {
                    break;
                }
                if (count == strs.length) {
                    return minStr;
                }
            }
            minStr = minStr.substring(0, minStr.length() - 1);
            count = 0;
        }

        return minStr;
    }

    /**
     * 3.验证 IP地址
     *
     * 时间复杂度 O（n）  空间复杂度 O（n）
     * 验证IP地址
     * @param IP string字符串 一个IP地址字符串
     * @return string字符串
     */
    public String solve3(String IP) {
        if(isIPv4(IP))
            return "IPv4";
        else if(isIPv6(IP))
            return "IPv6";
        return "Neither";
    }
    boolean isIPv4 (String IP) {
        if(IP.indexOf('.') == -1){
            return false;
        }
        String[] s = IP.split("\\.");
        //IPv4必定为4组
        if(s.length != 4)
            return false;
        for(int i = 0; i < s.length; i++){
            //不可缺省，有一个分割为零，说明两个点相连
            if(s[i].length() == 0)
                return false;
            //比较数字位数及不为零时不能有前缀零
            if(s[i].length() < 0 || s[i].length() > 3 || (s[i].charAt(0)=='0' && s[i].length() != 1))
                return false;
            int num = 0;
            //遍历每个分割字符串，必须为数字
            for(int j = 0; j < s[i].length(); j++){
                char c = s[i].charAt(j);
                if (c < '0' || c > '9')
                    return false;
                //转化为数字比较，0-255之间
                num = num * 10 + (int)(c - '0');
                if(num < 0 || num > 255)
                    return false;
            }
        }
        return true;
    }
    boolean isIPv6 (String IP) {
        if (IP.indexOf(':') == -1) {
            return false;
        }
        String[] s = IP.split(":",-1);
        //IPv6必定为8组
        if(s.length != 8){
            return false;
        }
        for(int i = 0; i < s.length; i++){
            //每个分割不能缺省，不能超过4位
            if(s[i].length() == 0 || s[i].length() > 4){
                return false;
            }
            for(int j = 0; j < s[i].length(); j++){
                //不能出现a-fA-F以外的大小写字符
                char c = s[i].charAt(j);
                boolean expr = (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') ;
                if(!expr){
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 4.大数加法
     *
     * 时间复杂度 O（n）   使用栈
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param s string字符串 表示第一个整数
     * @param t string字符串 表示第二个整数
     * @return string字符串
     */
    public String solve (String s, String t) {
        // write code here
        Stack<Integer> stack = new Stack<>();
        StringBuilder stringBuilder = new StringBuilder();
        int i = s.length() - 1, j = t.length() - 1, carry = 0;
        while (i >= 0 || j >= 0 || carry != 0) {
            carry += i >= 0 ? s.charAt(i--) - '0' : 0;
            carry += j >= 0 ? t.charAt(j--) - '0' : 0;
            stack.push(carry % 10); // 非进位
            carry = carry / 10;  // 进位
        }
        while (!stack.isEmpty())
            stringBuilder.append(stack.pop());
        return stringBuilder.toString();
    }

    /** 双指针
     * 1.合并两个有序数组
     *
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param A int数组
     * @param m int
     * @param B int数组
     * @param n int
     * @return void
     */
    public void merge(int A[], int m, int B[], int n) {
        int i = m - 1;
        int j = n - 1;
        int p = m + n - 1;


        while (i >= 0 && j >= 0){
            A[p--] = A[i] >= B[j]? A[i--]:B[j--];
        }

        while (j >= 0){
            A[p--] = B[j--];
        }
    }

    /**
     * 2.判断是否为回文字符串
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here

        int i = 0;
        int j = str.length() - 1;

        while (i < j){
            if (str.charAt(i) != str.charAt(j)){
                return false;
            }
            i++;
            j--;

        }
        return true;
    }

    /**
     * 3.合并区间
     *
     *
     * 时间复杂度：O（nlogn）  空间复杂度：O（n）
     * 进阶：时间复杂度 O（val）   空间复杂度 O（val）   val为区间里的值
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param intervals ArrayList数组
     * @return ArrayList数组
     */
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        if (intervals.size() == 0) return new ArrayList<>();

        // List排序
//        intervals.sort(new Comparator<Interval>() {
//            @Override
//            public int compare(Interval o1, Interval o2) {
//                if (o1.start != o2.start)
//                    return o1.start - o2.start;
//                else
//                    return o1.end - o2.end;
//            }
//        });

        // Array排序
        Interval[] intervals2 = intervals.toArray(new Interval[0]);
        Arrays.sort(intervals2, new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                if (o1.start != o2.start)
                    return o1.start - o2.start;
                else
                    return o1.end - o2.end;
            }
        });
//        注意：需要按照上面分开写，合起来写排不了序
//        Arrays.sort(intervals.toArray(new Interval[0]), new Comparator<Interval>() {
//            @Override
//            public int compare(Interval o1, Interval o2) {
//                if (o1.start != o2.start)
//                    return o1.start - o2.start;
//                else
//                    return o1.end - o2.end;
//            }
//        });
//
//        for (Interval interval : intervals) {
//            System.out.println(interval.start + "   " + interval.end);
//        }

        ArrayList<Interval> res = new ArrayList<>();
        res.add(intervals2[0]);

        for (int i = 1; i < intervals2.length; i++) {
            if (intervals2[i].start <= res.get(res.size() - 1).end){ // 有重合
                int newEnd = Math.max(intervals2[i].end, res.get(res.size() - 1).end);
                System.out.println(newEnd);
                int newStart = res.get(res.size() - 1).start;
                System.out.println(newStart);
                res.remove(res.size() - 1);
                res.add(new Interval(newStart, newEnd));
            }else {
                res.add(intervals2[i]);
            }
        }

        return res;
    }

    /**
     *
     * 4.最长无重复子数组
     *
     * 要求：连续 且 不重复
     *
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxLength (int[] arr) {
        // write code here
        // 哈希方法

        if (arr.length == 0) return 0;
        if (arr.length == 1) return 1;


        int res = 0;

        for (int i = 0; i < arr.length; i++) {
            HashSet<Integer> hashSet = new HashSet<>();
            hashSet.add(arr[i]);

            for (int j = i + 1; j < arr.length; j++) {
                int oldSize = hashSet.size();
                hashSet.add(arr[j]);
                int newSize = hashSet.size();
                if (oldSize == newSize){
                    res = Math.max(hashSet.size(), res);
                    break;
                }else {
                    res = Math.max(res, hashSet.size());
                }
            }
        }

        return res;
    }

    /**
     * 5.盛水最多的容器
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     *
     * @param height int整型一维数组
     * @return int整型
     */
    public int maxArea (int[] height) {
        // write code here
        if (height.length < 2){
            return 0;
        }

        int i = 0;
        int j = height.length - 1;
        int res = 0;
        while (i < j){
            int temp = Math.min(height[i], height[j]) * (j - i);
            res = Math.max(res, temp);
            if (height[i] < height[j]){
                i ++;
            }else if (height[i] > height[j]){
                j --;
            }else {
                i ++;
                j --;
            }
        }

        return res;
    }

    /**
     * 6.接雨水问题
     *
     * 时间复杂度：O（n）
     * max water
     * @param arr int整型一维数组 the array
     * @return long长整型
     */
    public long maxWater (int[] arr) {
        // write code here
        //排除空数组
        if(arr.length == 0)
            return 0;

        long res = 0;
        //左右双指针
        int left = 0;
        int right = arr.length - 1;

        //中间区域的边界高度
        int maxL = 0;
        int maxR = 0;

        //直到左右指针相遇
        while(left < right){
            //每次维护往中间的最大边界
            maxL = Math.max(maxL, arr[left]);
            maxR = Math.max(maxR, arr[right]);
            //较短的边界确定该格子的水量
            if(maxR > maxL)
                res += maxL - arr[left++];
            else
                res += maxR - arr[right--];
        }
        return res;
    }

    /**
     *
     * 7.最小覆盖子串
     *
     * 时间复杂度为 O（n）
     *
     * @return string字符串
     */
    //检查是否有小于0的
    boolean check(int[] hash) {
        for (int i = 0; i < hash.length; i++) {
            if (hash[i] < 0)
                return false;
        }
        return true;
    };

    public String minWindow (String S, String T) {
        int cnt = S.length() + 1;
        //记录目标字符串T的字符个数
        int[] hash = new int[128];
        for(int i = 0; i < T.length(); i++)
            //初始化哈希表都为负数，找的时候再加为正
            hash[T.charAt(i)] -= 1;
        int slow = 0, fast = 0;
        //记录左右区间
        int left = -1, right = -1;
        for(; fast < S.length(); fast++){
            char c = S.charAt(fast);
            //目标字符匹配+1
            hash[c]++;
            //没有小于0的说明都覆盖了，缩小窗口
            while(check(hash)){
                //取最优解
                if(cnt > fast - slow + 1){
                    cnt = fast - slow + 1;
                    left = slow;
                    right = fast;
                }
                c = S.charAt(slow);
                //缩小窗口的时候减1
                hash[c]--;
                //窗口缩小
                slow++;
            }
        }
        //找不到的情况
        if(left == -1)
            return "";
        return S.substring(left, right + 1);
    }

    /** 贪心
     * 1.主持人调度
     *
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算成功举办活动需要多少名主持人
     * @param n int整型 有n个活动
     * @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间
     * @return int整型
     */
    public int minmumNumberOfHost (int n, int[][] startEnd) {
        // write code here
        int[] start = new int[n];
        int[] end = new int[n];
        //分别得到活动起始时间
        for(int i = 0; i < n; i++){
            start[i] = startEnd[i][0];
            end[i] = startEnd[i][1];
        }
        //单独排序
        Arrays.sort(start, 0, start.length);
        Arrays.sort(end, 0, end.length);
        int res = 0;
        int j = 0;
        for(int i = 0; i < n; i++){
            //新开始的节目大于上一轮结束的时间，主持人不变
            if(start[i] >= end[j])
                j++;
            else
                //主持人增加
                res++;
        }
        return res;
    }

    /** 模拟
     *
     * 1.旋转数组
     *
     * 时间复杂度：O（n）  空间复杂度：O（1）
     * @param n int整型 数组长度
     * @param m int整型 右移距离
     * @param a int整型一维数组 给定数组
     * @return int整型一维数组
     */
    public int[] solve (int n, int m, int[] a) {
        //取余，因为每次长度为n的旋转数组相当于没有变化
        m = m % n;
        //第一次逆转全部数组元素
        reverse(a, 0, n - 1);
        //第二次只逆转开头m个
        reverse(a, 0, m - 1);
        //第三次只逆转结尾m个
        reverse(a, m, n - 1);
        return a;
    }
    //反转函数
    public void reverse(int[] nums, int start, int end){
        while(start < end){
            swap(nums, start++, end--);
        }
    }
    //交换函数
    public void swap(int[] nums, int a, int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    /** 模拟
     *
     * 2.螺旋矩阵
     *
     * 时间复杂度：O（nm）  空间复杂度：O（nm）
     * @param matrix int[][]整型二维数组
     * @return ArrayList<Integer>
     */
    public ArrayList<Integer> spiralOrder(int[][] matrix) {
        ArrayList<Integer> res = new ArrayList<>();
        if(matrix.length == 0)
            return res;

        // 定义四个指针，并且充当边界限制的作用
        int top = 0, bottom = matrix.length-1;
        int left = 0, right = matrix[0].length-1;

        while( top < (matrix.length+1)/2 && left < (matrix[0].length+1)/2 ){
            //上面  左到右
            for(int i = left; i <= right; i++){
                res.add(matrix[top][i]);
            }

            //右边 上到下
            for(int i = top+1; i <= bottom; i++){
                res.add(matrix[i][right]);
            }

            //下面  右到左
            for(int i = right-1; top!=bottom && i>=left; i--){ // top !=bottom 避免只有一行的情况
                res.add(matrix[bottom][i]);
            }

            //左边 下到上
            for(int i = bottom-1; left!=right && i>=top+1; i--){ // left!=right 避免只有一列的情况
                res.add(matrix[i][left]);
            }
            // 遍历完一圈之后，所有往里面靠
            ++top;
            --bottom;
            ++left;
            --right;
        }
        return res;

    }

}

// 定义一个区间
class Interval{
     int start;
     int end;
     Interval() { start = 0; end = 0; }
     Interval(int s, int e) { start = s; end = e; }


}



// 二叉树节点
class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}

// 单链表节点
class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}

Skip to content
Search or jump to…
Pull requests
Issues
Codespaces
Marketplace
Explore
 
@qwert233xu 
qwert233xu
/
leetcodeJava1
Public
Cannot fork because you own this repository and are not a member of any organizations.
Code
Issues
Pull requests
Actions
Projects
Wiki
Security
Insights
Settings
leetcodeJava1/src/com/wenqu/leetcode/AppTest.java /
@qwert233xu
qwert233xu Add files via upload
Latest commit 190933b 2 weeks ago
 History
 1 contributor
848 lines (714 sloc)  24.1 KB

package com.xu;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * Unit test for simple App.
 */
public class AppTest {
    /**
     * Rigorous Test :-)
     */
    @Test
    public void shouldAnswerWithTrue() {
        assertTrue(true);
    }

    @Test
    public void testReverseList() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        root.next.next = new ListNode(3);
        ListNode temp = app.ReverseList3(root);
        while (temp != null) {
            System.out.println(temp.val);
            temp = temp.next;
        }
    }

    @Test
    public void testReverseBetween() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        root.next.next = new ListNode(3);
        root.next.next.next = new ListNode(4);
        root.next.next.next.next = new ListNode(5);
        int m = 2;
        int n = 4;
        ListNode temp = app.reverseBetween2(root, m, n);
        while (temp != null) {
            System.out.println(temp.val);
            temp = temp.next;
        }
    }

    @Test
    public void testReverseKGroup() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        root.next.next = new ListNode(3);
        root.next.next.next = new ListNode(4);
//        root.next.next.next.next = new ListNode(5);
        ListNode res = app.reverseKGroup(root, 2);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testMerge() {
        App app = new App();
        ListNode list1 = new ListNode(1);
        list1.next = new ListNode(3);
        list1.next.next = new ListNode(5);
        ListNode list2 = new ListNode(2);
        list2.next = new ListNode(4);
        list2.next.next = new ListNode(6);
        ListNode res = app.Merge(list1, list2);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testDivide() {
        App app = new App();
        ArrayList<ListNode> res = new ArrayList<>();
        res.add(new ListNode(1));
        res.add(new ListNode(2));
        res.add(new ListNode(1));
        res.add(new ListNode(4));
        res.add(new ListNode(5));
        res.add(new ListNode(6));
        ListNode result = app.mergeKLists(res);
        while (result != null) {
            System.out.println(result.val);
            result = result.next;
        }
    }

    @Test
    public void testHasCycle() {
        App app = new App();
        ListNode root = new ListNode(3);
        root.next = new ListNode(2);
        root.next.next = new ListNode(0);
        root.next.next.next = new ListNode(-4);
        root.next.next.next.next = root.next;
        boolean res = app.hasCycle(root);
        System.out.println(res);
    }

    @Test
    public void testEntryNodeOfLoop() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        root.next.next = new ListNode(3);
        root.next.next.next = new ListNode(4);
        root.next.next.next.next = new ListNode(5);
        root.next.next.next.next.next = root.next.next;

        ListNode res = app.EntryNodeOfLoop(root);
        System.out.println(res.val);
    }

    @Test
    public void testFindKthToTail() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        root.next.next = new ListNode(3);
        root.next.next.next = new ListNode(4);
        root.next.next.next.next = new ListNode(5);
        ListNode res = app.FindKthToTail(root, 2);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testRemoveNthFromEnd() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        ListNode res = app.removeNthFromEnd(root, 2);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testFindFirstCommonNode() {

        App app = new App();
        ListNode pHead1 = new ListNode(1);
        pHead1.next = new ListNode(2);
        pHead1.next.next = new ListNode(3);
        pHead1.next.next.next = new ListNode(6);
        pHead1.next.next.next.next = new ListNode(7);

        ListNode pHead2 = new ListNode(4);
        pHead2.next = new ListNode(5);
        pHead2.next.next = pHead1.next.next.next;
        pHead2.next.next.next = pHead1.next.next.next.next;

        ListNode res = app.FindFirstCommonNode(pHead1, pHead2);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testAddInList() {
        App app = new App();
        ListNode pHead1 = new ListNode(0);

        ListNode pHead2 = new ListNode(6);
        pHead2.next = new ListNode(3);

        ListNode res = app.addInList(pHead1, pHead2);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testSortInList() {
        App app = new App();
        ListNode head = new ListNode(1);
        head.next = new ListNode(3);
        head.next.next = new ListNode(2);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        ListNode res = app.sortInList(head);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testIsPail() {
        App app = new App();
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        head.next.next.next.next.next = new ListNode(4);
        head.next.next.next.next.next.next = new ListNode(3);
        head.next.next.next.next.next.next.next = new ListNode(2);
        head.next.next.next.next.next.next.next.next = new ListNode(1);
        head.next.next.next.next.next.next.next.next.next = new ListNode(1);
        boolean pail = app.isPail(head);
        System.out.println(pail);
    }

    @Test
    public void testOddEvenList() {
        App app = new App();
        ListNode root = new ListNode(1);
        root.next = new ListNode(2);
        root.next.next = new ListNode(3);
        root.next.next.next = new ListNode(4);
        root.next.next.next.next = new ListNode(5);
        root.next.next.next.next.next = new ListNode(6);

        ListNode res = app.oddEvenList(root);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testDeleteDuplicates() {
        App app = new App();
        ListNode head = new ListNode(1);
        head.next = new ListNode(1);
        ListNode res = app.deleteDuplicates(head);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testDeleteDuplicates2() {
        App app = new App();
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(2);
        ListNode res = app.deleteDuplicates2(head);
        while (res != null) {
            System.out.println(res.val);
            res = res.next;
        }
    }

    @Test
    public void testSearch() {
        App app = new App();
//        System.out.println(app.search(new int[]{-1, 0, 3, 4, 6, 10, 13, 14}, 13));
        System.out.println(app.search(new int[]{-1, 1}, -1));
    }

    @Test
    public void testFindPeakElement() {
        App app = new App();
        int peakElement = app.findPeakElement(new int[]{2, 4, 1, 2, 7, 8, 4});
        System.out.println(peakElement);
    }

    @Test
    public void testInversePairs() {
        App app = new App();
        System.out.println(app.InversePairs(new int[]{1, 2, 3, 4, 5, 6, 7, 0}));
    }

    @Test
    public void testPriorityQueueSort() {
        App app = new App();
        System.out.println(Arrays.toString(app.PriorityQueueSort(new int[]{3, 2, 5, 1, 7})));
    }

    @Test
    public void testCompare() {
        App app = new App();
        System.out.println(app.compare("1.1", "2.1"));
    }

    @Test
    public void testLevelOrder() {
        App app = new App();
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(9);
        root.right = new TreeNode(20);
        root.right.left = new TreeNode(15);
        root.right.right = new TreeNode(7);
        System.out.println(app.levelOrder(root));
    }

    @Test
    public void testPrint() {
        App app = new App();
        TreeNode root = new TreeNode(8);
        root.left = new TreeNode(10);
        root.right = new TreeNode(6);
        root.left.left = new TreeNode(5);
        root.left.right = new TreeNode(7);
        root.right.left = new TreeNode(9);
        root.right.right = new TreeNode(11);
        System.out.println(app.Print(root));
    }

    @Test
    public void testMaxDepth() {
        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        System.out.println(app.maxDepth(root)); // 3
    }

    @Test
    public void testHasPathSum() {

        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        System.out.println(app.hasPathSum(root, 7)); // true
    }

    @Test
    public void testConvert() {
        App app = new App();
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(6);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(8);
        root.right = new TreeNode(14);
        root.right.left = new TreeNode(12);
        root.right.right = new TreeNode(16);

        TreeNode res = app.Convert(root);
        while (res != null) {
            System.out.println(res.val);
            res = res.right;
        }
    }

    @Test
    public void testIsSymmetrical() {
        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(2);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(4);
        root.right.left = new TreeNode(4);
        root.right.right = new TreeNode(3);
        boolean symmetrical = app.isSymmetrical(root);
        System.out.println(symmetrical);
    }

    @Test
    public void testMergeTrees() {
        App app = new App();
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(3);
        root1.right = new TreeNode(2);
        root1.left.left = new TreeNode(5);

        TreeNode root2 = new TreeNode(2);
        root2.left = new TreeNode(1);
        root2.right = new TreeNode(3);
        root2.left.right = new TreeNode(4);
        root2.right.right = new TreeNode(7);
        TreeNode res = app.mergeTrees(root1, root2);
        System.out.println(app.levelOrder(res));
    }

    @Test
    public void testMirror() {
        App app = new App();
        TreeNode root = new TreeNode(8);
        root.left = new TreeNode(6);
        root.right = new TreeNode(10);
        root.left.left = new TreeNode(5);
        root.left.right = new TreeNode(7);
        root.right.left = new TreeNode(9);
        root.right.right = new TreeNode(11);
        TreeNode res = app.Mirror(root);
        System.out.println(app.levelOrder(res));
    }

    @Test
    public void testIsValidBST_dfs() {
        App app = new App();
        /*TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);*/

        TreeNode root = new TreeNode(2);
        root.left = new TreeNode(1);
        root.right = new TreeNode(3);

        System.out.println(app.isValidBST(root));
    }

    @Test
    public void testIsCompleteTree() {
        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        boolean res = app.isCompleteTree(root);
        System.out.println(res);
    }

    @Test
    public void testIsBalanced_Solution() {
        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
        System.out.println(app.IsBalanced_Solution(root));
    }

    @Test
    public void testLowestCommonAncestor() {
        App app = new App();
        TreeNode root = new TreeNode(7);
        root.left = new TreeNode(1);
        root.right = new TreeNode(12);
        root.left.left = new TreeNode(0);
        root.left.right = new TreeNode(4);
        root.right.left = new TreeNode(11);
        root.right.right = new TreeNode(14);
        root.left.right.left = new TreeNode(3);
        root.left.right.right = new TreeNode(5);
        int res = app.lowestCommonAncestor(root, 1, 12);
        System.out.println(res);
    }

    @Test
    public void testLowestCommonAncestor2() {
        App app = new App();
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(5);
        root.right = new TreeNode(1);
        root.left.left = new TreeNode(6);
        root.left.right = new TreeNode(2);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(8);
        root.left.right.left = new TreeNode(7);
        root.left.right.right = new TreeNode(4);
        System.out.println(app.lowestCommonAncestor2(root, 5, 1));
    }

    @Test
    public void testSerialize() {
        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
        System.out.println(app.Serialize(root));
    }

    @Test
    public void testDeserialize() {
        App app = new App();
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(9);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
        TreeNode res = app.Deserialize(app.Serialize(root));
        System.out.println(app.levelOrder(res));
    }

    @Test
    public void testSolve() {
        App app = new App();
        // 前序  和  中序数组
        int[] pre = new int[]{1, 2, 4, 5, 3};
        int[] in = new int[]{4, 2, 5, 1, 3};
        System.out.println(Arrays.toString(app.solve(pre, in)));
    }

    @Test
    public void testRebuildTree() {
        App app = new App();
        TreeNode res = app.rebuildTree(new int[]{1, 2, 4, 5, 3}, new int[]{4, 2, 5, 1, 3});
        ArrayList<ArrayList<Integer>> result = app.levelOrder(res);
        System.out.println(result);
    }

    @Test
    public void testMyStackMin() {
        App.MyStackMin myStackMin = new App.MyStackMin();
        myStackMin.push(-1);
        myStackMin.push(2);
        int min = myStackMin.min();
        int top = myStackMin.top();
        System.out.println(min);
        System.out.println(top);
        myStackMin.pop();
        myStackMin.push(1);
        int top2 = myStackMin.top();
        int min2 = myStackMin.min();
        System.out.println(top2);
        System.out.println(min2);
    }

    @Test
    public void testIsValid() {
        App app = new App();

        System.out.println(app.isValid("{}[]()"));
        System.out.println(app.isValid("{]()"));
        System.out.println(app.isValid("{[()]}"));

    }

    @Test
    public void testMaxInWindows() {
        App app = new App();
        System.out.println(app.maxInWindows(new int[]{2, 3, 4, 2, 6, 2, 5, 1}, 3));
    }

    @Test
    public void testGetLeastNumbers_Solution() {
        App app = new App();
        System.out.println(app.GetLeastNumbers_Solution(new int[]{4, 5, 1, 6, 2, 7, 3, 8}, 4));
    }

    @Test
    public void testFindKth() {
        App app = new App();
        System.out.println(app.findKth(new int[]{10, 10, 9, 9, 8, 7, 5, 6, 4, 3, 4, 2}, 12, 3));
    }

    @Test
    public void testTwoSum() {
        App app = new App();
        System.out.println(Arrays.toString(app.twoSum(new int[]{3, 2, 4}, 6)));
    }

    @Test
    public void testMoreThanHalfNum_Solution() {
        App app = new App();
        System.out.println(app.MoreThanHalfNum_Solution(new int[]{1, 2, 3, 2, 2, 2, 5, 4, 2}));
    }

    @Test
    public void testFindNumsAppearOnce() {
        App app = new App();
        System.out.println(Arrays.toString(app.FindNumsAppearOnce(new int[]{1, 4, 1, 6})));
    }

    @Test
    public void testMinNumberDisappeared() {
        App app = new App();
        System.out.println(app.minNumberDisappeared(new int[]{-2, 3, 4, 1, 5}));
    }

    @Test
    public void testThreeSum() {
        App app = new App();
        ArrayList<ArrayList<Integer>> arrayLists = app.threeSum(new int[]{-2, 0, 1, 1, 2});
        System.out.println(arrayLists);
    }

    @Test
    public void testPermute() {
        App app = new App();
        System.out.println(app.permute(new int[]{1, 2, 3}));
    }

    @Test
    public void testPermuteUnique() {
        App app = new App();
        System.out.println(app.permuteUnique(new int[]{1, 1, 2}));
    }

    @Test
    public void testTestSolve() {
        App app = new App();
        System.out.println(app.solve2(new char[][]{{'1', '1', '0', '0', '0'},
                {'0', '1', '0', '1', '1'},
                {'0', '0', '0', '1', '1'},
                {'0', '0', '0', '0', '0'},
                {'0', '0', '1', '1', '1'}}));
    }

    @Test
    public void testPermutation_backtrack() {
        App app = new App();
        System.out.println(app.Permutation("aab"));
    }

    @Test
    public void testNqueen() {
        App app = new App();
        System.out.println(app.Nqueen(8));
    }

    @Test
    public void testGenerateParenthesis() {
        App app = new App();
        ArrayList<String> res = app.generateParenthesis(3);
        System.out.println(res);
    }

    @Test
    public void testTestSolve1() {
        App app = new App();
        System.out.println(app.solve(new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}));
    }

    @Test
    public void testJumpFloor() {
        App app = new App();
        System.out.println(app.jumpFloor(7));
    }

    @Test
    public void testMinCostClimbingStairs() {
        App app = new App();
        System.out.println(app.minCostClimbingStairs(new int[]{1, 100, 1, 1, 1, 90, 1, 1, 80, 1}));
    }

    @Test
    public void testLCS() {
        App app = new App();
        System.out.println(app.LCS("1A2C3D4B56", "B1D23A456A"));
    }

    @Test
    public void testLCS2() {
        App app = new App();
        System.out.println(app.LCS2("1AB2345CD", "12345EF"));
    }

    @Test
    public void testUniquePaths2_dfs() {
        App app = new App();
//        System.out.println(app.uniquePaths2(2, 2));
        System.out.println(app.uniquePaths(3, 3));
    }

    @Test
    public void testMinPathSum() {
        App app = new App();
        System.out.println(app.minPathSum(new int[][]{{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0}}));
    }

    @Test
    public void testSolve2() {
        App app = new App();
        System.out.println(app.solve2("12"));
    }

    @Test
    public void testMinMoney() {
        App app = new App();
        System.out.println(app.minMoney(new int[]{5, 2, 3}, 20));
    }

    @Test
    public void testLIS() {
        App app = new App();
        System.out.println(app.LIS(new int[]{3, 5, 7, 1, 2, 4, 6, 3, 8, 9, 5, 6}));
    }

    @Test
    public void testFindGreatestSumOfSubArray() {
        App app = new App();
        System.out.println(app.FindGreatestSumOfSubArray(new int[]{1, -2, 3, 10, -4, 7, 2, -5}));
    }

    @Test
    public void testGetLongestPalindrome() {
        App app = new App();
        System.out.println(app.getLongestPalindrome("ababc"));
    }

    @Test
    public void testRestoreIpAddresses() {
        App app = new App();
        ArrayList<String> strings = app.restoreIpAddresses("25525522135");
        System.out.println(strings);
    }

    @Test
    public void testRob() {
        App app = new App();
        System.out.println(app.rob(new int[]{1, 2, 3, 4}));
    }

    @Test
    public void testRob2() {
        App app = new App();
        System.out.println(app.rob2(new int[]{1, 2, 3, 4}));
    }

    @Test
    public void testMaxProfit() {
        App app = new App();
        System.out.println(app.maxProfit(new int[]{8, 9, 2, 5, 4, 7, 1}));
    }

    @Test
    public void testMaxProfit2() {
        App app = new App();
        System.out.println(app.maxProfit2(new int[]{8, 9, 2, 5, 4, 7, 1}));
    }

    @Test
    public void testMaxProfit3() {
        App app = new App();
        System.out.println(app.maxProfit3(new int[]{8, 9, 3, 5, 1, 3}));
    }

    @Test
    public void testEditDistance() {
        App app = new App();
        System.out.println(app.editDistance("nowcoder", "new"));
    }

    @Test
    public void testTrans() {
        App app = new App();
        System.out.println(app.trans("          ", 10));
    }

    @Test
    public void testLongestCommonPrefix() {
        App app = new App();
//        System.out.println(app.longestCommonPrefix(new String[]{"abca", "abcg", "abca", "abcf", "abcc"}));
        System.out.println(app.longestCommonPrefix(new String[]{"cadrwrer", "cadrwes"}));
    }

    @Test
    public void testSolve3() {
        App app = new App();
        System.out.println(app.solve3("172.16.254.1"));
    }

    @Test
    public void testTestSolve2() {
        App app = new App();
        System.out.println(app.solve("1", "99"));
    }

    @Test
    public void testTestMerge() {
        App app = new App();
        ArrayList<Interval> root = new ArrayList<>();
        root.add(new Interval(1, 4));
        root.add(new Interval(0, 2));
        ArrayList<Interval> merge = app.merge(root);
        for (Interval interval : merge) {
            System.out.println(interval.start + "   " + interval.end);
        }
    }

    @Test
    public void testMaxLength() {
        App app = new App();
        System.out.println(app.maxLength(new int[]{2, 3, 4, 5}));
    }

    @Test
    public void testMaxArea() {
        App app = new App();
        System.out.println(app.maxArea(new int[]{1, 7, 3, 2, 4, 5, 8, 2, 7}));
    }

    @Test
    public void testMaxWater() {
        App app = new App();
        System.out.println(app.maxWater(new int[]{3, 1, 2, 5, 2, 4}));
    }

    @Test
    public void testSpiralOrder() {
        App app = new App();
//        System.out.println(app.minWindow("XDOYEZODEYXNZ", "XYZ"));
        System.out.println(app.minWindow("lhibsbrpxssyuibsdicrucaega", "ebsdslcacpib"));
    }

}

// ======== End 牛客网Top101 java ========

///////////////////////////////////////////////////////////////

// ======== Start 专题 动态规划、贪心、位运算、图 java + c# ========

package com.xu;

import org.testng.annotations.Test;

import java.util.*;

// dynamic process
public class App2 {
    public static void main(String[] args) {

    }

    // O(n)   1
    public int MaxSubArray(int[] nums) {
        if (nums.length == 1) return nums[0];

        int[] dp = new int[nums.length]; // 表示以 nums[i] 结尾 的 连续 子数组的最大和
        dp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
           dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
           res = Math.max(dp[i], res); // -3  8  -2  -3
        }
        return res;
    }

    //   2
    // [2,3,1,1,4] true   [3,2,1,0,4] false
    // [2,0]
    public boolean canJump(int[] nums) {

        int border = 0;
        int end = 0;

        for (int i = 0; i < nums.length-1; i++) {
            border = Math.max(border, nums[i] + i);
            if (i == end){
                end = border;
            }
        }
        if (end >= nums.length - 1) return true;
        return end + nums[end] >= nums.length - 1;
    }

    private int res_count = 0;

    // backTracking     over time!
    public int uniquePaths(int m, int n) {

        boolean[][] used = new boolean[m][n];
        backTracking_uniquePaths(used, 0, 0, m, n);
        return res_count;
    }

    public void backTracking_uniquePaths(boolean[][] used, int i, int j, int m, int n){
        used[i][j] = true;
        if (i == m - 1 && j == n - 1){
            res_count++;
            return;
        }
        int[][] choice = new int[][]{{0, 1}, {1, 0}};
        for (int[] ints : choice) {
            int newI = i + ints[0];
            int newJ = j + ints[1];
            if (newI < used.length && newJ < used[0].length && !used[newI][newJ]) {
                backTracking_uniquePaths(used, newI, newJ, m, n);
                used[newI][newJ] = false;
            }
        }
    }

    //  3
    // dynamic process    O(n2)
    public int uniquePaths2(int m, int n) {
        // i   j     dp[i][j] 表示从 0 0 到 i j 路径总数
        // 只有上部 和 左部 能到达  dp[i][j] = dp[i-1][j] + dp[i][j-1]
        int[][] dp = new int[m][n];
        // 处理边界  上边界 和 左边界  只有一条路径
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }


    // 4  带障碍物    障碍物 1    无障碍物 0
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0) return 0;


        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;



        int[][] dp = new int[m][n];
        // 处理边界  上边界 和 左边界  只有一条路径
        int border = 0;
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
                dp[i][0] = 1;
        }

        for (int i = 0; i < n && obstacleGrid[0][i] == 0; i++) {
            dp[0][i] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 障碍物判断
                if (obstacleGrid[i][j] != 1) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return obstacleGrid[m-1][n-1] != 1?dp[m-1][n-1]:0;

    }

    // 5、
    public int minPathSum(int[][] grid) {

        if (grid == null || grid.length == 0) return 0;

        int m = grid.length;
        int n = grid[0].length;


        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        // 处理边界  上边界 和 左边界  只有一条路径
        for (int i = 1; i < m; i++) {
            dp[i][0] = grid[i][0] + dp[i - 1][0];
        }
        for (int i = 1; i < n; i++) {
            dp[0][i] = grid[0][i] + dp[0][i - 1];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }

        return dp[m-1][n-1];

    }

    // 6、
    public int climbStairs(int n) {

        if (n == 0) return 0;
        if (n == 1) return 1;

        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }

    // 7、
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> dp = new ArrayList<>(numRows);
        ArrayList<Integer> initial = new ArrayList<>();
        initial.add(1);
        if (numRows >= 1) dp.add(0, initial);
        ArrayList<Integer> initial2 = new ArrayList<>();
        if (numRows >= 2) {
            initial2.add(1);
            initial2.add(1);
        }
        dp.add(1, initial2);

        for (int i = 2; i < numRows; ++i) {
            ArrayList<Integer> temp = new ArrayList<>();
            temp.add(0, 1);
            for (int j = 1; j <= i - 1; ++j) {
                temp.add(j, dp.get(i-1).get(j) + dp.get(i - 1).get(j - 1));
            }

            temp.add(1);
            dp.add(temp);
        }

        return dp;
    }

    // 8、
    public int maxProfit(int[] prices) {

        if (prices.length == 1) return 0;

        int[][] dp = new int[prices.length][2];  // 0 不持有  1  持有
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        }

        return Math.max(dp[prices.length - 1][0], 0);
    }

    // 9、
    public List<List<String>> partition(String s) {
        int len = s.length();
        List<List<String>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        char[] charArray = s.toCharArray();
        // 预处理
        // 状态：dp[i][j] 表示 s[i][j] 是否是回文
        boolean[][] dp = new boolean[len][len];
        // 状态转移方程：在 s[i] == s[j] 的时候，dp[i][j] 参考 dp[i + 1][j - 1]
        for (int right = 0; right < len; right++) {
            // 注意：left <= right 取等号表示 1 个字符的时候也需要判断
            for (int left = 0; left <= right; left++) {
                if (charArray[left] == charArray[right] && (right - left <= 2 || dp[left + 1][right - 1])) {
                    dp[left][right] = true;
                }
            }
        }

        Deque<String> stack = new ArrayDeque<>();
        dfs(s, 0, len, dp, stack, res);
        return res;
    }

    private void dfs(String s, int index, int len, boolean[][] dp, Deque<String> path, List<List<String>> res) {
        if (index == len) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = index; i < len; i++) {
            if (dp[index][i]) {  // index =》 left   i =》 right
                path.addLast(s.substring(index, i + 1)); // 截取字符串  （回文子串）
                System.out.println(i+1);
                dfs(s, i + 1, len, dp, path, res);  // i + 1  i 为 right （索引）  当回溯到该子串右边界时，保存满足的组合
                path.removeLast();
            }
        }
    }


    public List<List<String>> partition_test(String s) {

        List<List<String>> res = new ArrayList<>();
        ArrayList<String> temp = new ArrayList<>();

        int index = 0;
        dfs_test(s, res, temp, index);
        return res;
    }

    private void dfs_test(String s, List<List<String>> res, ArrayList<String> temp, int index) {
        if (index == s.length()) {
//        if (temp.size() == s.length()) { // 和 i = 0 搭配着使用 排列问题
            res.add(new ArrayList<>(temp));
            return;
        }

        for (int i = index; i < s.length(); i++) {   // 当 i = 0 时表示可以重复选（排列）   index 的情况表示不可重复选（组合）
            temp.add(s.substring(index, i+1));  // 分割问题
//            temp.add(String.valueOf(s.charAt(i)));
            dfs_test(s, res, temp, i+1);
            temp.remove(temp.size() - 1);
        }
    }

    // 10、
    public int maxProduct(int[] nums) {
        int n = nums.length;

        int[] maxNums = new int[n]; // 以j结尾的最大乘积子数组  正数情况
        int[] minNums = new int[n]; // 以j结尾的最小乘积子数组  负数情况

        System.arraycopy(nums, 0, maxNums, 0, n);
        System.arraycopy(nums, 0, minNums, 0, n);


        for (int i = 1; i < n; i++) {
                maxNums[i] = Math.max(maxNums[i - 1]*nums[i], Math.max(minNums[i - 1]*nums[i], nums[i]));
                minNums[i] = Math.min(minNums[i - 1]*nums[i], Math.min(maxNums[i - 1]*nums[i], nums[i]));
        }

        int max = maxNums[0];
        for (int i = 1; i < n; i++) {
            max = Math.max(max, maxNums[i]);
        }

        return max;
    }
    // 11、
    public int rob(int[] nums) {
        if(nums.length == 1) return nums[0];
        int[][] dp = new int[nums.length][2]; // 0 tou  1 butou
        dp[0][0] = nums[0];
        dp[0][1] = 0;

        for (int i = 1; i < nums.length; i++) {
            dp[i][0] = dp[i - 1][1] + nums[i];
            dp[i][1] = Math.max(dp[i - 1][0], dp[i - 1][1]); // 但是可以隔多家butou
        }

        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
    }

    // 12、 环形
    public int rob2(int[] nums) {

        if (nums.length == 1){
            return nums[0];
        }else if (nums.length == 2){
            return Math.max(nums[0], nums[1]);
        }

        return Math.max(MaxDiff(Arrays.copyOfRange(nums, 1, nums.length)), MaxDiff(Arrays.copyOfRange(nums, 0, nums.length-1)));

    }

    public int MaxDiff(int[] nums){
        if(nums.length == 1) return nums[0];
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        dp[0][1] = 0;

        for (int i = 1; i < nums.length; i++) {
            dp[i][0] = dp[i - 1][1] + nums[i];
            dp[i][1] = Math.max(dp[i - 1][0], dp[i - 1][1]);
        }

        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
    }

    // 13、
    public int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;

        int[][] dp = new int[matrix.length][matrix[0].length];
        int res = 0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == '1'){
                    if (i == 0 || j == 0){
                        dp[i][j] = 1;
                        res = Math.max(res, dp[i][j]);
                    }else {
                        dp[i][j] =Math.min(Math.min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1;
                        res = Math.max(res, dp[i][j]);
                    }
                }
            }
        }
        return res * res;
    }

    // 14、
    public List<Integer> diffWaysToCompute(String expression) {
        return diffWaysToCompute_Partition(expression);
    }


    public List<Integer> diffWaysToCompute_Partition(String s){

        ArrayList<Integer> res = new ArrayList<>();
        if (s.length() < 3){
            res.add(Integer.parseInt(s));
            return res;
        }


        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '+' || s.charAt(i) == '-' || s.charAt(i) == '*'){
                // 分治
                List<Integer> left = diffWaysToCompute_Partition(s.substring(0, i));
                List<Integer> right = diffWaysToCompute_Partition(s.substring(i+1, s.length()));

                for (Integer value : left) {
                    for (Integer integer : right) {
                        if (s.charAt(i) == '+') {
                            res.add(value + integer);
                        } else if (s.charAt(i) == '-') {
                            res.add(value - integer);
                        } else if (s.charAt(i) == '*') {
                            res.add(value * integer);
                        }
                    }
                }
            }
        }
        return res;
    }

    // 15、
    public int nthUglyNumber(int n) {
        if (n == 1) return 1;

        int[] dp = new int[n + 1];  // dp[i]  存放第几个丑数
        dp[1] = 1;

        int a2 = 1, a3 = 1, a5 = 1;
        for (int i = 2; i <= n; i++) {
            int a = dp[a2] * 2;
            int b = dp[a3] * 3;
            int c = dp[a5] * 5;

            int minValue = Math.min(Math.min(a, b), c);
            dp[i] = minValue;  // 可能有  2  和  3  共同组成的情况，所以为 if  而非 else if
            if (dp[i] == a){
                a2++;
            }
            if (dp[i] == b){
                a3++;
            }
            if (dp[i] == c){
                a5++;
            }
        }

        return dp[n];
    }

    // 16、
    public int numSquares(int n) {
        int[] dp = new int[n + 1]; // 默认初始化值都为0     索引是数，值是个数

        for (int i = 1; i <= n; i++) { // dp[1] = 1(1)   dp[2] = 2 (1 1)    dp[3] = 3 (1 1 1)  dp[8] = 2 (4 4)
            dp[i] = i; // 最坏的情况就是每次+1

            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程
            }

        }
        System.out.println(Arrays.toString(dp));
        return dp[n];
    }


    // 17、 树形动态规划  记录两个状态   递归太耗时
    public int rob(TreeNode root) {
        int[] max = rob_dfs(root);
        return Math.max(max[0], max[1]);
    }

    public int[] rob_dfs(TreeNode root){
        if (root == null){
            return new int[2];
        }

        int[] res = new int[2];

        int[] left =  rob_dfs(root.left);
        int[] right =  rob_dfs(root.right);

        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        res[1] = left[0] + right[0] + root.val;

        return res;
    }


    // 18、
    public int integerBreak(int n) {

        int[] dp = new int[n + 1];

        for (int i = 2; i <= n; i++) {
            int ans = 0;
            for (int j = 1; j < i; j++) {
                ans = Math.max(ans, Math.max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = ans;
        }
        return dp[n];
    }

    // 19、
    public int countNumbersWithUniqueDigits(int n) {
        if (n == 0) return 1;

        int res = 10;
        for (int i = 2, last = 9; i <= n; i++) {
            int ans = last * (10 - i + 1); //   last   9   8    7
            res += ans;
            last = ans;
        }

        return res;
    }

    // 20、
    public int combinationSum4(int[] nums, int target) {

        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int v: nums) {
                if (i >= v){
                    dp[i] += dp[i - v];
                }
            }
        }

        return dp[target];
    }

    // 21、最长回文子串   回文子串个数 就是dp数组里 true 个数
    public int longestPalindromeSubseq1(String s) {
        if (s.length() == 1) return 1;

        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        int res = 1;
        for (int i = n - 1; i >= 0; i--) {  // 开始索引   从小到上
            int ans = 1;
            for (int j = i; j < n; j++) {  // 结束索引   从左到右
                if (s.charAt(i) == s.charAt(j)){
                    if (j - i < 3){
                        dp[i][j] = true;
                    }else if (dp[i+1][j-1]){
                        dp[i][j] = true;
                    }
                }
                if (dp[i][j]){
                    ans = Math.max(ans, j - i + 1);
                }
            }
            res = Math.max(res, ans);
        }
        return res;
    }

    // 22、最长回文子序列
    public int longestPalindromeSubseq(String s) {
        if (s.length() == 1) return 1;

        int n = s.length();
        int[][] dp = new int[n][n]; // 表示第 i 个 索引到 第 j 个索引的最长回文子序列的长度
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        for (int i = n - 1; i >= 0; i--) {  //
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)){
                    dp[i][j] = dp[i + 1][j - 1] + 2;  // 体现非连续性
                    // 可以计数统计回文子序列 个数
                }else {
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }

        return dp[0][n-1];
    }


    // 23、
    public boolean isSubsequence(String s, String t) {
        if (s.length() == 0) return true;

        if (s.length() > t.length()) return false;

        int n = t.length();

        int i_s = 0;
        int j_t = 0;

        while (j_t < n){
            if (s.charAt(i_s) == t.charAt(j_t)){
                i_s++;
            }
            j_t++;
        }
        return i_s == s.length();
    }

    // 24、分割等和子集
    public boolean canPartition(int[] nums) {
        if (nums.length < 2) return false;

        int target = 0;
        for (int v: nums) {
            target += v;
        }

        if (target % 2 != 0) return false;
        target /= 2;  // 背包
        int n = nums.length;
        boolean[][] dp = new boolean[n][target + 1]; // dp[i][j]表示判断从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。
        if (nums[0] <= target){
            dp[0][nums[0]] = true;
        }
        for (int i = 1; i < n; i++) {  // 物品 索引
            for (int j = 0; j <= target; j++) { // 背包容量
                dp[i][j] = dp[i - 1][j];
                if (nums[i] == j){
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j){
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]; // 不选  与  选
                }
            }
        }

        return dp[n-1][target];
    }



    // 25、目标和
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // 绝对值范围超过了sum的绝对值范围则无法得到
        if (Math.abs(target) > Math.abs(sum)) return 0;

        int len = nums.length;
        // - 0 +
        int t = sum * 2 + 1;
        int[][] dp = new int[len][t];

        // 初始化
        if (nums[0] == 0) {
            dp[0][sum] = 2;
        } else {
            dp[0][sum + nums[0]] = 1;
            dp[0][sum - nums[0]] = 1;
        }

        for (int i = 1; i < len; i++) {
            for (int j = 0; j < t; j++) {
                // 边界
                int l = Math.max((j - nums[i]), 0);
                int r = (j + nums[i]) < t ? j + nums[i] : 0;
                dp[i][j] = dp[i - 1][l] + dp[i - 1][r];
            }
        }
        return dp[len - 1][sum + target];
    }

    // 26、回文子串个数
    public int countSubstrings(String s) {

        if (s.length() == 1) return 1;

        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        int res = 0;
        for (int i = n - 1; i >= 0; i--) {  // 开始索引   从小到上
            int ans = 1;
            for (int j = i; j < n; j++) {  // 结束索引   从左到右
                if (s.charAt(i) == s.charAt(j)){
                    if (j - i < 3){
                        dp[i][j] = true;
                    }else if (dp[i+1][j-1]){
                        dp[i][j] = true;
                    }
                }
                if (dp[i][j]){
                    ans = Math.max(ans, j - i + 1);
                    res ++;
                }
            }
        }

        return res;
    }

}


package com.xu;

import com.beust.ah.A;
import junit.framework.TestCase;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

public class App2Test {

    @Test
    public void testMaxSubArray() {
        App2 app2 = new App2();
        System.out.println(app2.MaxSubArray(new int[]{-2,1,-3,4,-1,2,1,-5,4}));
    }


    @Test
    public void testCanJump() {
        App2 app2 = new App2();
        System.out.println(app2.canJump(new int[]{2,3,1,1,4}));
        System.out.println(app2.canJump(new int[]{3,2,1,0,4}));
    }

    @Test
    public void testUniquePaths() {
        App2 app2 = new App2();
//        System.out.println(app2.uniquePaths(3, 7));
//        System.out.println(app2.uniquePaths(23, 12));
        System.out.println(app2.uniquePaths2(23, 12));
    }

    @Test
    public void testUniquePathsWithObstacles() {
        App2 app2 = new App2();
        System.out.println(app2.uniquePathsWithObstacles(new int[][]{{1, 0}}));
    }

    @Test
    public void testMinPathSum() {
        App2 app2 = new App2();
        System.out.println(app2.minPathSum(new int[][]{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}}));
    }

    @Test
    public void testClimbStairs() {
        App2 app2 = new App2();
        System.out.println(app2.climbStairs(3));
    }

    @Test
    public void testGenerate() {
        App2 app2 = new App2();
        System.out.println(app2.generate(5));
    }

    @Test
    public void testPartition() {
        App2 app2 = new App2();
        System.out.println(app2.partition("aab"));
    }

    @Test
    public void testPartition_test() {
        App2 app2 = new App2();
        System.out.println(app2.partition_test("aab"));
    }

    @Test
    public void testMaxProduct() {
        App2 app2 = new App2();
//        System.out.println(app2.maxProduct(new int[]{2, 3, -2, 4}));
        System.out.println(app2.maxProduct(new int[]{-2, 0, -1}));
    }

    @Test
    public void testRob() {
        App2 app2 = new App2();
//        System.out.println(app2.rob(new int[]{2, 7, 9, 3, 1}));
//        System.out.println(app2.rob(new int[]{1,2,3,1}));
        System.out.println(app2.rob(new int[]{2,1,1,2}));
    }

    @Test
    public void testRob2() {
        App2 app2 = new App2();
        System.out.println(app2.rob2(new int[]{1, 2, 3, 1}));
    }

    @Test
    public void testNthUglyNumber() {
        App2 app2 = new App2();
        System.out.println(app2.nthUglyNumber(10));
    }

    @Test
    public void testNumSquares() {
        App2 app2 = new App2();
        System.out.println(app2.numSquares(8));
    }

    @Test
    public void testLongestPalindromeSubseq1() {
        App2 app2 = new App2();
        System.out.println(app2.longestPalindromeSubseq1("abcdaba"));
    }

    @Test
    public void testIsSubsequence() {
        App2 app2 = new App2();
        System.out.println(app2.isSubsequence("acb", "ahbgdc"));
    }

    @Test
    public void testCanPartition() {
        App2 app2 = new App2();
        System.out.println(app2.canPartition(new int[]{1, 5, 11, 5}));
    }

    @Test
    public void testCountSubstrings() {
        App2 app2 = new App2();
        System.out.println(app2.countSubstrings("abc"));
    }


}

package com.xu;

import java.util.*;

// greed
public class App3 {
    public static void main(String[] args) {

    }

    //1、
    public String removeKdigits(String num, int k) {
        //贪心算法+栈
        if(k >= num.length()||num.length()==0)
            return "0";
        //栈顶始终是最大值
        Stack<Integer>stack=new Stack<>();
        stack.push(num.charAt(0)-'0');
        for(int i=1;i<num.length();i++)
        {
            int now=num.charAt(i)-'0';
            //可能好几个值都比当前值大，那么我们就在k允许的情况下，去去除它。
            while(!stack.isEmpty()&&k>0&&now<stack.peek()){
                stack.pop();
                k--;
            }
            //不等于0可以添加进去,
            //等于0，栈不为空可以填进去，
            if(now!=0||!stack.isEmpty())
            {
                stack.push(now);
            }
        }
        //56789这种情况，前面一直比后面小，那就去除栈顶，谁让栈顶最大
        while(k>0 && !stack.isEmpty())
        {
            k--;
            stack.pop();
        }
        //10，1(当now=0时，满足条件，去掉1，但now为0，且为空。)
        if(stack.isEmpty())
            return "0";
        StringBuilder sb=new StringBuilder();
        while(!stack.isEmpty())
            sb.append(stack.pop());
        //从后往前添加所以我们要逆序
        return sb.reverse().toString();
    }

    //2、
    public String removeDuplicateLetters(String s) {

        // 计数
        int[] counter = new int[256];
        for (char c: s.toCharArray()) {
            counter[c] ++;
        }

        Stack<Character> stack = new Stack<>();
        boolean[] used = new boolean[256];

        // 去重
        for (char c: s.toCharArray()) {
            counter[c]--;
            if (used[c]){  // 去重
                continue;
            }
            while (!stack.isEmpty() && c < stack.peek()){ // 保证字典序最小

                if (counter[stack.peek()] == 0){
                    break;
                }

                used[stack.pop()] = false;
            }
            stack.push(c);
            used[c] = true;
        }

        StringBuilder res = new StringBuilder();
        while (!stack.isEmpty()){
            res.append(stack.peek());
            stack.pop();
        }
        return res.reverse().toString();
    }


    // 3、
    public String smallestSubsequence(String s) {
        // 计数
        int[] counter = new int[256];
        for (char c: s.toCharArray()) {
            counter[c] ++;
        }

        Stack<Character> stack = new Stack<>();
        boolean[] used = new boolean[256];

        // 去重
        for (char c: s.toCharArray()) {
            counter[c]--;
            if (used[c]){  // 去重
                continue;
            }
            while (!stack.isEmpty() && c < stack.peek()){ // 保证字典序最小

                if (counter[stack.peek()] == 0){
                    break;
                }

                used[stack.pop()] = false;
            }
            stack.push(c);
            used[c] = true;
        }

        StringBuilder res = new StringBuilder();
        while (!stack.isEmpty()){
            res.append(stack.peek());
            stack.pop();
        }
        return res.reverse().toString();
    }

    // 4、分治思想  贪心局部最优
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {

        int[] res = new int[k];
        Arrays.fill(res, -1);
        for (int i = 0; i < k + 1; i++) {
            if (i <= nums1.length && k - i <= nums2.length){
                int[] cur = merge(pick_max(nums1, i), pick_max(nums2, k - i));
                for (int j = 0; j < k; j++) {
                    if (res[j] > cur[j]){
                        break;
                    }else if (res[j] < cur[j]){
                        res = cur;
                        break;
                    }
                }
            }
        }
        return res;
    }

    public int[] pick_max(int[] nums, int k){
        int[] res = new int[k];
        Stack<Integer> stack = new Stack<>();

        int m = nums.length - k;
        for (int num : nums) {
            while (!stack.isEmpty() && m > 0 && stack.peek() < num) {
                stack.pop();
                m--;
            }
            stack.push(num);
        }

        while (m > 0){
            stack.pop();
            m --;
        }

        int i = k-1;
        while (i >= 0) {
            res[i--] = stack.pop();
        }

        System.out.println(Arrays.toString(res));
        System.out.println("========pick_max=========");
        return res;
    }

    public String str(int[] nums, int i){
        // return  ''.join(nums[i:])
        if(i>=nums.length) return "";
        StringBuilder sb = new StringBuilder();
        for(; i<nums.length; i++){
            sb.append((char)(nums[i]+'a'));
        }
        return sb.toString();
    }

    public int[] merge(int[] A, int[] B){ // 可以出一道题: 给定两个字符串，在不改变其相对位置的情况下，组合成最大的数
        int n=A.length, m=B.length, l=n+m;
        int[] res = new int[l];
        int i=0, j=0;
        for(int k=0; k<l; k++){
            int a = i>=n ? -1 : A[i];
            int b = j>=m ? -1 : B[j];
            if(a>b){
                res[k] = a;
                i++;
            }else if (b>a){
                res[k] = b;
                j++;
            }else{
                // 如果相等，则比较后序字符大小
                String s1 = str(A, i);
                String s2 = str(B, j);
                if((s1+s2).compareTo(s2+s1)>0){
                    res[k] = a;
                    i++;
                }else{
                    res[k] = b;
                    j++;
                }
            }
        }
        return res;
    }

    //5、
    public int[][] reconstructQueue(int[][] people) {
        // 原地该变
        Arrays.sort(people, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1[0] != o2[0]){
                    return o2[0] - o1[0];
                }else {
                    return o1[1] - o2[1];
                }
            }
        });

        List<int[]> list = new LinkedList<>();

        for (int[] person : people) {

            list.add(Math.min(list.size(), person[1]), person);
        }

        return list.toArray(new int[list.size()][]);
    }

    // 6、
    public int longestPalindrome(String s) {
        char[] occurs = new char[128];

        int ans = 0;
        for (int i = 0; i < s.length(); ++i) {
            char c = s.charAt(i);
            occurs[c]++;
            if (occurs[c] == 2) {
                ans += 2;
                occurs[c] = 0;
            }
        }

        if (ans < s.length()) ans++;
        return ans;
    }

    // 7、
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length < 2) return 0;

        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);

        int res = 1;
        int right = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= right){
                res++;
                right = intervals[i][1];
            }

        }
        return intervals.length - res;
    }

    // 8、
    public int findContentChildren(int[] g, int[] s) {
        int i = 0;
        int j = 0;

        Arrays.sort(g);
        Arrays.sort(s);
        while (i < s.length && j < g.length){
            if (g[j] <= s[i++]){
                j++;
            }
        }

        return j;
    }

    // 9、
    public int arrayPairSum(int[] nums) {
        if (nums.length == 2){
            return Arrays.stream(nums).min().getAsInt();
        }

        Arrays.sort(nums);

        int i = 0;
        int j = 1;

        int res = 0;
        while (j < nums.length){
            res += Math.min(nums[i], nums[j]);
            i+=2;
            j+=2;
        }

        return res;
    }

    // 10、
    public boolean canPlaceFlowers(int[] flowerbed, int n) {

        for (int i = 0; i < flowerbed.length && n > 0;) {
            if (flowerbed[i] == 1){
                i+=2;
            }else if (i == flowerbed.length - 1 || flowerbed[i+1] == 0){
                n--;
                i+=2;
            }else {
                i+=3;
            }
        }

        return n == 0;
    }

    // 11、
    public boolean validPalindrome(String s) {

        int left = 0;
        int right = s.length()- 1;
        while (left < right){
            if (s.charAt(left) != s.charAt(right)){
                return judge(s, left+1, right) || judge(s, left, right-1);
            }else {
                left++;
                right--;
            }
        }

        return true;
    }

    public boolean judge(String s, int left, int right){
        while (left < right){
            if (s.charAt(left++) != s.charAt(right--)){
                return false;
            }
        }
        return true;
    }

    // 12、
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;


        for (int bill : bills) {
            if (bill == 5) {
                five++;
            } else if (bill == 10) {
                if (five > 0) {
                    five--;
                    ten++;
                } else {
                    return false;
                }
            } else {
                if (five > 0 && ten > 0) { // 贪心  优先使用 10 和 5 留着 5 5
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }

    // 13、
    public int[] diStringMatch(String s) {
        if (s.length() == 1){
            if (s.charAt(0) == 'I'){
                return new int[]{0, 1};
            }
            return new int[]{1, 0};
        }

        int n = s.length() + 1;

        int[] res = new int[n];

        int min = 0;
        int max = n - 1;
        for (int i = 0; i < s.length(); i++) {  // 贪心  遇到 D 优先使用最大值， 遇到 I 优先使用最小值
            if (s.charAt(i) == 'I'){
                res[i] = min;
                min++;
            }else {
                res[i] = max;
                max--;
            }
        }
        System.out.println(max);
        res[n - 1] = min; // or  max
        return res;
    }

    // 14、
    public int largestPerimeter(int[] nums) {

        int[] ints = new int[nums.length];
        Arrays.sort(nums);
        int index = nums.length - 1;
        for (int v: nums) {
            ints[index--] = v;
        }

        int res = 0;
        for (int i = 0; i < ints.length - 2; i++) {
            if (judge(ints[i], ints[i+1], ints[i+2])){
                res = Math.max(res,ints[i] + ints[i+1] + ints[i+2]);
            }
        }

        return res;
    }

    public boolean judge(int a, int b, int c){
        return a + b > c && a + c > b && b + c > a;
    }

    // 15、
    public int largestSumAfterKNegations(int[] nums, int k) {
        
        int res = 0;
        Arrays.sort(nums);
        
        int fCount = 0; // 负数个数
        boolean zeroValue = false; // 是否有零

        for (int v: nums) {
            if (v < 0){
                fCount++;
            }
            if (v == 0){
                zeroValue = true;
            }
        }

        int index_absMin = 0;  // 绝对值最小的值 所在索引
        int min_absValue = Math.abs(nums[0]);
        for (int i = 1; i < nums.length; i++) {
            if (min_absValue > Math.abs(nums[i])){
                index_absMin = i;
                min_absValue = Math.abs(nums[i]);
            }
        }
        
        int k2 = k;
        if (k <= fCount){
            for (int v: nums) {
                if (v < 0 && k2 > 0){
                    res += (-v);
                    k2--;
                }else {
                    res += v;
                }
            }
            return res;
        }else {
            // 计算出剩余取反次数
            for (int i = 0; i < fCount; i++) {
                res += (-nums[i]);
            }
            if ((k - fCount) % 2 == 0 || zeroValue){
                // 偶数
                for (int i = fCount; i < nums.length; i++) {
                    res+=nums[i];
                }
                return res;
            }else {
                for (int i = fCount; i < nums.length; i++) {
                    res += nums[i];
                }
                System.out.println("=====");
                System.out.println(Arrays.toString(nums));
                System.out.println(index_absMin);

                return res - 2*Math.abs(nums[index_absMin]);
            }
        }
    }
}

package com.xu;

import junit.framework.TestCase;

import java.util.Arrays;

public class App3Test extends TestCase {

    public void testRemoveKdigits() {
        App3 app3 = new App3();
//        System.out.println(app3.removeKdigits("1432219", 3));
        System.out.println(app3.removeKdigits("10001", 4));
    }

    public void testRemoveDuplicateLetters() {
        App3 app3 = new App3();
        System.out.println(app3.removeDuplicateLetters("bcabc"));
    }

    public void testMaxNumber() {
        App3 app3 = new App3();
        System.out.println(Arrays.toString(app3.maxNumber(new int[]{6,7}, new int[]{6,0,4}, 5)));
    }

    public void testPick_max() {
        App3 app3 = new App3();
        System.out.println(Arrays.toString(app3.pick_max(new int[]{9, 1, 2, 5, 8, 3}, 3)));
    }

    public void testMerge() {
        App3 app3 = new App3();
        System.out.println(Arrays.toString(app3.merge(new int[]{2,5,6,4,4,0}, new int[]{7,3,8,0,6,5,7,6,2})));
    }

    public void testReconstructQueue() {
        App3 app3 = new App3();
        System.out.println(Arrays.deepToString(app3.reconstructQueue(new int[][]{{7, 0}, {4, 4}, {7, 1}, {5, 0}, {6, 1}, {5, 2}})));
    }

    public void testDiStringMatch() {
        App3 app3 = new App3();
        System.out.println(Arrays.toString(app3.diStringMatch("IDID")));
    }

    public void testLargestPerimeter() {
        App3 app3 = new App3();
        System.out.println(app3.largestPerimeter(new int[]{2, 1, 2}));
    }

    public void testLargestSumAfterKNegations() {
        App3 app3 = new App3();
//        System.out.println(app3.largestSumAfterKNegations(new int[]{2, 3, -3, -2}, 3));
        System.out.println(app3.largestSumAfterKNegations(new int[]{2, 3, 4, 5}, 3));
    }

    public void testTestLargestSumAfterKNegations() {
        App3 app3 = new App3();
        System.out.println(app3.largestSumAfterKNegations(new int[]{8,-7,-3,-9,1,9,-6,-9,3}, 8));
    }
}

package com.xu;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class App4 {

    // BitCal
    public static void main(String[] args) {

    }


    // 1、
    public int singleNumber(int[] nums) {
        int[] cnt = new int[32];
        for (int v: nums) {
            for (int i = 0; i < 32; i++) {
                if (((v>>i) & 1) == 1){
                    cnt[i]++;
                }
            }
        }

        int res = 0;

//        for (int i = 0; i < 32; i++) {
//            res += (cnt[i] % 3) * Math.pow(2, i);
//        }
        System.out.println(Arrays.toString(cnt));
        for (int i = 0; i < 32; i++) {
            if ((cnt[i] % 3 & 1) == 1){  // 只需要计算 1 就行  因为 余数 为 2
                res += (1<<i); // 考虑进位
            }
        }

        return res;
    }

    // 2、
    public List<String> findRepeatedDnaSequences(String s) {
        ArrayList<String> res = new ArrayList<>();
        HashMap<String, Integer> map = new HashMap<>();

        for (int i = 0; i + 10 <= s.length(); i++) {
            String s1 = s.substring(i, i+10);
            int count = map.getOrDefault(s1, 0);
            if (count == 1){
                res.add(s1);
            }
            map.put(s1, count+1);
        }

        return res;
    }

    // 3、
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            res<<=1;
            res += ((n>>i) & 1);
        }

        return res;
    }

    // 4、
    public int hammingWeight(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            if (((n>>i) & 1) == 1){
                res++;
            }
        }

        return res;
    }

    // 5、
    public boolean isPowerOfTwo(int n) {
        return n > 0 && ((n & (n-1)) == 0);
    }

    // 6、
    public int missingNumber(int[] nums) {
        // 异或
        int ans = 0;
        for (int i = 0; i <= nums.length; i++) {
            ans ^= i;
        }

        for (int v: nums) {
            ans ^= v;
        }

        return ans;
    }

    // 7、
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;

        slow = nums[slow];
        fast = nums[nums[fast]];

        while (slow != fast){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }

        int p1 = 0;
        int p2 = slow;

        while (p1 != p2){
            p1 = nums[p1];
            p2 = nums[p2];
        }
        return p1;
    }
}

package com.xu;

import com.xu.App4;
import junit.framework.TestCase;

public class App4Test extends TestCase {

    public void testSingleNumber() {
        App4 app4 = new App4();
        System.out.println(app4.singleNumber(new int[]{0, 1, 2, 1, 0, 1, 2, 0, 2, 99}));
    }
}



package com.xu;

import java.util.*;

// graph
public class App5 {
    public static void main(String[] args) {

    }

    // 1、
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int c = image[sr][sc];
        if (c != color){
            floodFill_dfs(image, sr, sc, color, c);
        }
        return image;
    }

    public void floodFill_dfs(int[][] image, int i, int j, int color, int c){
        if (i < 0 || i >= image.length || j < 0 || j >= image[0].length || image[i][j] != c){ // 相同并且相连
            return;
        }

        image[i][j] = color;

        // 上下左右
        floodFill_dfs(image, i-1, j, color, c);
        floodFill_dfs(image, i+1, j, color, c);
        floodFill_dfs(image, i, j-1, color, c);
        floodFill_dfs(image, i, j+1, color, c);
    }

    // 2、
    private int res = 0;
    public int numIslands(char[][] grid) {

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1'){
                    res++;
                    numIslands_dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    public void numIslands_dfs(char[][] grid, int i, int j){
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '#' || grid[i][j] == '0'){
            return;
        }

        grid[i][j] = '#';


        numIslands_dfs(grid, i-1, j);
        numIslands_dfs(grid, i+1, j);
        numIslands_dfs(grid, i, j-1);
        numIslands_dfs(grid, i, j+1);

    }

    // 3、
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1){
                    // 一个岛屿
                    res = Math.max(res, maxAreaOfIsland_dfs(grid, i, j, 0));
                }
            }
        }
        return res;
    }


    public int maxAreaOfIsland_dfs(int[][] grid, int i, int j, int count_one){
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1 || grid[i][j] == 0){
            return 0;
        }

        grid[i][j] = -1;

        int up = maxAreaOfIsland_dfs(grid, i-1, j, count_one);
        int down = maxAreaOfIsland_dfs(grid, i+1, j, count_one);
        int left = maxAreaOfIsland_dfs(grid, i, j-1, count_one);
        int right = maxAreaOfIsland_dfs(grid, i, j+1, count_one);

        return 1 + up + down + left + right;
    }

    // 4、
    private int allDao = 0;
    private int waiDao = 0;
    public int closedIsland(int[][] grid) {
        int[][] grid2 = new int[grid.length][grid[0].length];

        for (int i = 0; i < grid.length; i++) {
            grid2[i] = Arrays.copyOf(grid[i], grid[i].length);
        }

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 0){
                    // 一个岛屿
                    allDao++;
                    closedIsland_countOfDao(grid, i, j);
                }
            }
        }

        for (int j = 0; j < grid2[0].length; j++) {
            if (grid2[0][j] == 0){ // 上边界
                waiDao++;
                closedIsland_countOfDao(grid2, 0, j);
            }
        }

        for (int j = 0; j < grid2[0].length; j++) {
            if (grid2[grid2.length-1][j] == 0){ // 下边界
                waiDao++;
                closedIsland_countOfDao(grid2, grid2.length - 1, j);
            }
        }

        for (int i = 1; i < grid2.length - 1; i++) {
            if (grid2[i][0] == 0){ // 左边界
                waiDao++;
                closedIsland_countOfDao(grid2, i, 0);
            }
        }

        for (int i = 1; i < grid2.length - 1; i++) {
            if (grid2[i][grid2[0].length - 1] == 0){ // 右边界
                waiDao++;
                closedIsland_countOfDao(grid2, i, grid2[0].length - 1);
            }
        }

        return allDao - waiDao;
    }


    public void closedIsland_countOfDao(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == -1 || grid[i][j] == 1){
            return;
        }

        grid[i][j] = -1;

        closedIsland_countOfDao(grid, i-1, j);
        closedIsland_countOfDao(grid, i+1, j);
        closedIsland_countOfDao(grid, i, j-1);
        closedIsland_countOfDao(grid, i, j+1);
    }

    private HashMap<Node, Node> map = new HashMap<>();
    public Node cloneGraph(Node node) { // dfs
        if (node == null){
            return null;
        }

        if (map.containsKey(node)){
            return map.get(node);
        }

        Node newNode = new Node(node.val, new ArrayList<>());
        map.put(node, newNode);

        for (Node node1: node.neighbors) {
            newNode.neighbors.add(cloneGraph(node1)); // 处理所有的邻居
        }

        return newNode;
    }

    public Node cloneGraph2(Node node) { // bfs
        if (node == null) {
            return node;
        }

        HashMap<Node, Node> visited = new HashMap();

        // 将题目给定的节点添加到队列
        LinkedList<Node> queue = new LinkedList<Node> ();
        queue.add(node);
        // 克隆第一个节点并存储到哈希表中
        visited.put(node, new Node(node.val, new ArrayList()));

        // 广度优先搜索
        while (!queue.isEmpty()) {
            // 取出队列的头节点
            Node n = queue.remove();
            // 遍历该节点的邻居
            for (Node neighbor: n.neighbors) {
                if (!visited.containsKey(neighbor)) {
                    // 如果没有被访问过，就克隆并存储在哈希表中
                    visited.put(neighbor, new Node(neighbor.val, new ArrayList()));
                    // 将邻居节点加入队列中
                    queue.add(neighbor);
                }
                // 更新当前节点的邻居列表
                visited.get(n).neighbors.add(visited.get(neighbor));
            }
        }

        return visited.get(node);
    }


}

class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}


package com.xu;

import junit.framework.TestCase;

import java.util.Arrays;

public class App5Test extends TestCase {

    public void testFloodFill() {
        App5 app5 = new App5();
//        System.out.println(Arrays.deepToString(app5.floodFill(new int[][]{{1, 1, 1}, {1, 1, 0}, {1, 0, 1}}, 1, 1, 2)));
        System.out.println(Arrays.deepToString(app5.floodFill(new int[][]{{0, 0, 0}, {0, 0, 0}}, 0, 0, 0)));
    }

    public void testNumIslands() {
        App5 app5 = new App5();
//        System.out.println(app5.numIslands(new char[][]{{'1','1','1','1','0'}, {'1','1','0','1','0'}, {'1','1','0','0','0'}, {'0','0','0','0','0'}}));
        System.out.println(app5.numIslands(new char[][]{{'1','1','0','0','0'}, {'1','1','0','0','0'}, {'0','0','1','0','0'}, {'0','0','0','1','1'}}));
    }

    public void testMaxAreaOfIsland() {
        App5 app5 = new App5();
        System.out.println(app5.maxAreaOfIsland(new int[][]{{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0}, {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0}, {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}}));
    }

    public void testClosedIsland() {
        App5 app5 = new App5();
        System.out.println(app5.closedIsland(new int[][]{{1, 1, 1, 1, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1, 1, 0}, {1, 0, 1, 0, 1, 1, 1, 0}, {1, 0, 0, 0, 0, 1, 0, 1}, {1, 1, 1, 1, 1, 1, 1, 0}}));
    }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Metrics;
using System.Globalization;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using System.Threading.Tasks;

namespace leetcode
{
    /*
        剑指offer II
     */
    internal class Class1
    {
        /*
         1、三数之和
         */
        public IList<IList<int>> ThreeSum(int[] nums)
        {
            IList<IList<int>> res = new List<IList<int>>();

            Array.Sort(nums);

            for (int i = 0; i < nums.Length - 2 && nums[i] <= 0; i++)
            {
                if (i > 0 && nums[i] == nums[i - 1]) continue;

                int m = i + 1;
                int n = nums.Length - 1;

                while (m < n)
                {
                    if (nums[m] + nums[n] + nums[i] < 0)
                    {
                        m++;
                        while (m < n && nums[m] == nums[m - 1])
                        {
                            m++;
                        }
                    }
                    else if (nums[m] + nums[n] + nums[i] > 0)
                    {
                        n--;
                        while (m < n && nums[n] == nums[n + 1])
                        {
                            n--;
                        }
                    }
                    else
                    {
                        List<int> temp = new List<int>() { nums[i], nums[m], nums[n] };
                        res.Add(temp);
                        m++;
                        n--;
                        while (m < n && nums[m] == nums[m - 1])
                        {
                            m++;
                        }
                        while (m < n && nums[n] == nums[n + 1])
                        {
                            n--;
                        }
                    }
                }

            }

            return res;
        }


        /*
            2、和大于等于target的最小连续子数组
         */

        public int MinSubArrayLen(int target, int[] nums)
        {
            if (nums.Length == 0) return 0;

            int left = 0;
            int right = 0;

            int temp_sum = 0;
            List<int> temp = new List<int>();

            int res = Int32.MaxValue;
            while (right < nums.Length)
            {
                if (temp_sum < target)
                {
                    temp_sum += nums[right];
                    temp.Add(nums[right]);
                }

                if (temp_sum >= target)
                {
                    res = Math.Min(res, temp.Count);
                    while (temp_sum > target)
                    {
                        temp.RemoveAt(0);
                        temp_sum -= nums[left++];
                    }
                    if (temp_sum == target)
                    {
                        res = Math.Min(res, temp.Count);
                        temp.RemoveAt(0);
                        temp_sum -= nums[left];
                        left++;
                    }
                    else
                    {
                        res = Math.Min(res, temp.Count + 1);
                    }

                }
                right++;

            }
            return res == Int32.MaxValue ? 0 : res;
        }


        /*
          3、乘积小于 k 的子数组
            滑动窗口
        */
        public int NumSubarrayProductLessThanK(int[] nums, int k)
        {

            int res = 0;
            int prod = 1;

            int i = 0;
            for (int j = 0; j < nums.Length; j++)
            {
                prod *= nums[j];

                while (i <= j && prod >= k)
                {
                    prod /= nums[i];
                    i++;
                }

                res += j - i + 1;
            }
            return res;
        }

        /*
            4、0和1个数相同的子数组       “具有相同个数 0 和 1的最长连续子数组”
            哈希表   前缀和
         */
        public int findMaxLength(int[] nums)
        {


            int resLen = 0;

            // 保存前缀后   key：数组下标  value：前缀和(其实就是1的个数）
            Dictionary<int, int> map = new Dictionary<int, int>();

            int sum = 0;
            map.Add(0, -1);

            for (int i = 0; i < nums.Length; i++)
            {
                int num = nums[i];
                if (num == 1)
                {
                    sum++;
                }
                else
                {
                    sum--;
                }
                if (map.ContainsKey(sum))
                {
                    int prevIndex = map[sum];
                    resLen = Math.Max(resLen, i - prevIndex);
                }
                else
                {
                    map.Add(sum, i);
                }
            }

            return resLen;
        }


        /*
            5、左右两边子数组的和相等
            数组   前缀和
         */
        public int PivotIndex(int[] nums)
        {

            int sum = 0;
            int sumAll = 0;
            foreach (int item in nums)
            {
                sumAll += item;
            }

            for (int i = 0; i < nums.Length; i++)
            {


                if (sum == (sumAll - nums[i]) / 2.0)
                {
                    return i;
                }
                sum += nums[i];
            }

            return -1;
        }

        public bool ValidPalindrome(string s)
        {

            return ValidPalindrome_backTracking(s, 0, s.Length - 1, true);
        }


        public bool ValidPalindrome_backTracking(string s, int i, int j, bool flag)
        {

            while (i < j)
            {
                if (s[i] != s[j])
                {
                    if (!flag)
                    {
                        return false;  // 第二次修改还不是回文，则返回 false
                    }

                    return ValidPalindrome_backTracking(s, i, j - 1, false) || ValidPalindrome_backTracking(
                        s, i + 1, j, false);
                }

                i++;
                j--;
            }

            return true;
        }

        /**
         *
         * 6、反转链表     双指针做法和递归做法
         */
        public ListNode ReverseList(ListNode head)
        {
            if (head == null) return null;

            ListNode pre = null;
            ListNode cur = head;

            while(cur.next != null)
            {
                ListNode temp = cur.next;
                cur.next = pre;
                pre = cur;
                cur = temp;
            }
            cur.next = pre;

            return cur;
        }


        /**
         *
         * 7、链表中的两数相加
         */
        public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
        {
            if (l1 == null) return l2;
            if (l2 == null) return l1;

            ListNode l1_reverse = ReverseNode(l1);
            ListNode l2_reverse = ReverseNode(l2);

            ListNode temp1 = l1_reverse;
            ListNode temp2 = l2_reverse;


        
            int diff = CountOfListNode(l1_reverse) - CountOfListNode(l2_reverse);

            if (diff > 0)
            {
                int fa = 0;
                ListNode pr = null;
                while (temp2 != null)
                {
                    int tt = temp1.val + temp2.val + fa;
                    temp1.val =  tt >= 10? tt - 10: tt;
                    fa = tt >= 10?1:0;
                    pr = temp1;
                    temp1 = temp1.next; 
                    temp2 = temp2.next; 
                }
                
                while(temp1 != null)
                {
                    int tt = temp1.val + fa;
                    temp1.val = tt >= 10 ? tt - 10 : tt;
                    fa = tt >= 10 ? 1 : 0;
                    pr = temp1;
                    temp1 = temp1.next;
                }

                if (fa > 0)
                {
                    pr.next = new ListNode(fa);
                }

                return ReverseNode(l1_reverse);

            }
            else if(diff < 0)
            {

                int fa = 0;
                ListNode pr = null;
                while (temp1 != null)
                {
                    int tt = temp1.val + temp2.val + fa;
                    temp2.val = tt >= 10? tt - 10: tt;
                    fa = tt >= 10 ? 1 : 0;
                    pr = temp2;
                    temp1 = temp1.next; 
                    temp2 = temp2.next;
                }
                while (temp2 != null)
                {
                    int tt = temp2.val + fa;
                    temp2.val = tt >= 10 ? tt - 10 : tt;
                    fa = tt >= 10 ? 1 : 0;
                    pr = temp2;
                    temp2 = temp2.next;
                }

                if (fa > 0)
                {
                    pr.next = new ListNode(fa);
                }

                return ReverseNode(l2_reverse);
            }
            else
            {
                int fa = 0;
                ListNode pr = null;
                while (temp2 != null)
                {
                    int tt = temp1.val + temp2.val + fa;
                    temp1.val = tt >= 10 ? tt - 10 : tt;
                    fa = tt >= 10 ? 1 : 0;

                    pr = temp1;

                    temp1 = temp1.next;
                    temp2 = temp2.next;
                }

                if(fa > 0)
                {
                    pr.next = new ListNode(fa);
                }


                return ReverseNode(l1_reverse);
            }

        }

        public ListNode ReverseNode(ListNode head)
        {
            if (head == null) return null;

            ListNode pre = null;
            ListNode cur = head;

            while (cur.next != null)
            {
                ListNode temp = cur.next;
                cur.next = pre;
                pre = cur;
                cur = temp;
            }
            cur.next = pre;

            return cur;

        }


        public int CountOfListNode(ListNode head)
        {
            int count = 0;
            ListNode te = head;
            while(te != null)
            {
                count++;
                te = te.next;
            }
            return count;

        }

        /**
         *
         * 8、重排链表
         */
        public void ReorderList(ListNode head)
        {
            if(head == null) return;


            List<ListNode> list = new List<ListNode>();

            ListNode temp = head;
            while(temp != null)
            {
                list.Add(temp);
                temp = temp.next;
            }

            int i = 0, j = list.Count - 1;

            while(i < j)
            {
                list[i].next = list[j];
                i++;
                if(i == j)
                {
                    break;
                }

                list[j].next = list[i];
                j--;
            }
            list[i].next = null;


            while(head != null)
            {
                Console.WriteLine(head.val);
                head = head.next;  
            }

        }


        public bool IsPalindrome(ListNode head)
        {
            if(head.next== null) return true;
            ListNode newHead = new ListNode(-1);

            ListNode temp = head;
            ListNode temp2 = newHead;
            while(temp != null)
            {
                temp2.next = new ListNode(temp.val);
                temp2 = temp2.next;
                temp = temp.next;
            }


            ListNode reverse_head = ReverseNode(newHead.next);
            return backTracking_IsPalindrome(head, reverse_head);
        }


        public bool backTracking_IsPalindrome(ListNode head, ListNode head_reverse)
        {
            
            if(head == null) return true;

            return head.val == head_reverse.val && backTracking_IsPalindrome(head.next, head_reverse.next);
            
        }


        private Node preNode;
        public Node Flatten(Node head)
        {
            backTracking_Flatten(head);
            return head;
        }

        public void backTracking_Flatten(Node head)
        {
            if (head == null) return;

            Node nextNode = head.next; // 保存右子树

            if(preNode != null)
            {
                preNode.next = head;
            }

            head.prev = preNode;
            preNode = head;
            backTracking_Flatten(head.child);  // 相当于树的前序遍历   左子树
            head.child = null;

            backTracking_Flatten(nextNode); // 右子树
            

        }

        // 以下为 动规题
        // 1、
        public int CountSubstrings(string s)
        {
            // 这道题和最长回文子串思路一样
            if (s.Length == 1) return 1;

            bool[,] isTree = new bool[s.Length+1, s.Length+1]; // dp 表示以 i 到 j 之间的字符串是否为回文串
            int[] dp = new int[s.Length + 1]; // dp 表示以 j 结尾的字符串的回文子串个数
                                          // 初始化
            dp[0] = 0;
            dp[1] = 1;

            isTree[0, 0] = true;
            isTree[0, 1] = true;


            int Len = s.Length;

            for (int i = 2; i <= Len; i++)
            {
                for (int start = 0; start < Len; start++)
                {
                    // 结尾
                    int end = start + i - 1;

                    if(end < s.Length)
                    {
                        if (s[start] == s[end])
                        {
                            
                            if (isTree[start + 1, end - 1])
                            {
                                isTree[start, end] = true;
                                dp[i] = dp[i - 1] + 1;
                            }
                            
                        }
                        else
                        {
                            isTree[start, end] = false;

                        }

                    }
                    
                }
            }
            return dp[s.Length];

        }

        // 2、
        public int NumDecodings(string s)
        {

            int[] dp = new int[s.Length];
            s = " " + s;

            for (int i = 1; i < s.Length; i++)
            {

                int a = s[i] - '0';
                int b = (s[i - 1] - '0') * 10 + (s[i] - '0');

                if (1 <= a && a <= 9)
                {
                    dp[i] = dp[i - 1] + dp[i - 2];
                }
                if (10 <= b && b <= 26)
                {
                    dp[i] += dp[i - 2];
                }


            }
            return dp[s.Length - 1];

        }


        /**
         * 3、不同的二叉搜索树II
         */
        public IList<TreeNode> GenerateTrees(int n)
        {
            List<TreeNode> res = new List<TreeNode>();

            return res;
        }


        /**
         * 4、单词拆分
         */
        public bool WordBreak(string s, IList<string> wordDict)
        {
            int n = s.Length;
            // 思路： dp[i] 表示 s 的前 i 位是否可以用 wordDict 表示
            // 那么，如果 dp[i] == true  && dp[i:j] 也存在wordDict 里，则 dp[j] == true
            bool[] dp = new bool[n+1];
            dp[0] = true;

            for (int i = 0; i < n; i++) // 开始索引
            {
                for (int j = i+1; j < n+1; j++)  // 结束索引
                {
                    if (dp[i] && wordDict.Contains(s.Substring(i, j - i)))
                    {
                        dp[j] = true;
                    }
                }

            }

            return dp[s.Length];
        }



        /**
         * 5、最长递增子序列
         */
        public int LengthOfLIS(int[] nums)
        {
            if (nums.Length == 0)
            {
                return 0;
            }


            int[] dp = new int[nums.Length];  // 表示 以 i 结尾的最长递增子序列长度
            int res = 0;
            Array.Fill(dp, 1);

            for (int i = 0; i < nums.Length; i++) // 以 i 结尾的序列
            {
                for (int j = 0; j < i; j++) // 以 j 开头的序列
                {
                    if (nums[j] < nums[i])
                    {
                        dp[i] = Math.Max(dp[i], dp[j] + 1); 
                    }
                }
                res = Math.Max(res, dp[i]);

            }
            return res;
        }



        /**
         * 6、最佳买卖股票时机含冷冻期
         */
        public int MaxProfit(int[] prices)
        {
            // 存在三种状态   持有状态 0  不持有状态且处于冷冻期 1   不持有状态且不处于冷冻期状态 2    因为卖出以后才会产生冷冻期，所以冷冻期只存在于不持有状态
            if (prices.Length == 1) // 我们用 dp[i] 表示第 i 天结束之后的「累计最大收益」
            {
                return 0;
            }

            int[, ] dp = new int[prices.Length, 3];
            

            dp[0, 0] = -prices[0];
            for (int i = 1; i < prices.Length; i++)
            {
                dp[i, 0] = Math.Max(dp[i - 1, 0], dp[i - 1, 2] - prices[i]);
                dp[i, 1] = dp[i - 1, 0] + prices[i];
                dp[i, 2] = Math.Max(dp[i - 1, 2], dp[i - 1, 1]);
            }


            return Math.Max(dp[prices.Length - 1, 1], dp[prices.Length - 1, 2]);
        }

        /**
         * 7、超级丑数     这道题和丑数II思路一致
         */
        public int NthSuperUglyNumber(int n, int[] primes)
        {
            if(n == 1) { return 1; }

            int count = primes.Length;

            int[] dp = new int[n];
            dp[0] = 1;

            int[] pointers = new int[count];

            for (int i = 0; i < count; i++)
            {
                pointers[i] = 1;
            }

            int[] tt = new int[count];
            for (int i = 1; i < n; i++)
            {
                int minValue = int.MaxValue;
                for (int j = 0; j < count; j++)
                {
                    int value = dp[pointers[j] - 1] * primes[j];
                    if (minValue > value)
                    {
                        minValue = value;
                    }
                    tt[j] = value;
                }
                dp[i] = minValue;

                for (int k = 0; k < count; k++)
                {
                    if (tt[k] == dp[i])
                    {
                        pointers[k]++;
                    }
                }
            }

            return dp[n - 1];
        }

        /**
         * 8、零钱兑换
         */
        public int coinChange(int[] coins, int amount)
        {
            if (coins.Length == 0)
            {
                return -1;
            }

            int [] dp = new int[amount + 1]; // dp 表示总额为 i 时所需的最小面值个数
            dp[0] = 0;

            for (int i = 1; i <= amount; i++) // 总额
            {   
                int min = int.MaxValue;
                for (int j = 0; j < coins.Length; j++) // 面值
                {
                    if (coins[j] <= i && dp[i - coins[j]] < min)
                    {
                        min = dp[i - coins[j]] + 1;
                    }
                }
                dp[i] = min;
            }

            return dp[amount] == int.MaxValue?-1:dp[amount];
        }

        // 以下为 贪心 算法
        // 1、盛最多水的容器
        // 方法一：双指针
        public int MaxArea(int[] height)
        {
            // 思路就是只有向内移动短板，容量才会增多（短板决定容量大小）
            int left = 0;
            int right = height.Length - 1;

            int res = 0;
            while (left < right)
            {
                res = Math.Max(res, (right - left) * Math.Min(height[left], height[right]));
                if (height[left] <= height[right])
                {
                    left++;
                }
                else
                {
                    right--;
                }
            }

            return res;
        }

        // 2、加油站
        public int CanCompleteCircuit(int[] gas, int[] cost)
        {   
            int n = gas.Length; // 长度
            int sum = 0; // 累计剩余油量   
            int minSum = 0; // 最低点
            int start = 0; // 起点

            for (int i = 0; i < n; i++)
            {
                sum += gas[i] - cost[i];
                if (sum < minSum)
                {
                    minSum = sum;
                    start = i + 1;
                }

            }
            if (sum < 0)
            {
                return -1; 
            }

            return start == n?0:start;
        }

        // 3、最大数
        public string LargestNumber(int[] nums)
        {


            string[] nums_string = new string[nums.Length];
            for (int i = 0; i < nums.Length; i++)
            {
                nums_string[i] = nums[i] + "";
            }

            Array.Sort(nums_string, (a, b) => {

                string ab = a + b;
                string ba = b + a;

                return ba.CompareTo(ab);
      
            });

            Console.WriteLine(nums_string.ToString());

            StringBuilder res = new StringBuilder();
            foreach(string v in nums_string)
            {
                res.Append(v);
            }

            int k = 0;
            while(k < res.Length - 1 && res[k] == '0')
            {
                k++;
            }

            return res.ToString(k, res.Length - k);

        }
        // 以下为 位运算
        // 1、两数相除    不使用 乘法 除法 和取余
        public int Divide(int dividend, int divisor)
        {
            return 0;
        }


        // 2、二进制求和
        public string AddBinary(string a, string b)
        {
            Stack<int> stack1 = new Stack<int>();
            Stack<int> stack2 = new Stack<int>();

            for (int i = 0; i < a.Length; i++)
            {
                stack1.Push(a[i] - '0');
            }

            for (int j = 0; j < b.Length; j++)
            {
                stack2.Push(b[j] - '0');
            }

            StringBuilder res = new StringBuilder();
            int flag = 0;
            while (stack1.Count > 0 && stack2.Count > 0)
            {   
                int v1 = stack1.Pop();
                int v2 = stack2.Pop();
                
                int value = v1 + v2 + flag;
                if (value >= 2)
                {
                    value -= 2;
                    res.Append(value);
                    flag = 1;
                }
                else
                {
                    flag = 0;
                    res.Append(value);
                }
            }
            while (stack1.Count > 0)
            {   
                int value = stack1.Pop() + flag;

                if (value >= 2)
                {
                    value -= 2;
                    res.Append(value);
                    flag = 1;
                }
                else
                {
                    flag = 0;
                    res.Append(value);
                }
            }

            while (stack2.Count > 0)
            {
                int value = stack2.Pop() + flag;

                if (value >= 2)
                {
                    value -= 2;
                    res.Append(value);
                    flag = 1;
                }
                else
                {
                    flag = 0;
                    res.Append(value);
                }
            }

            if (flag != 0)
            {
                res.Append(flag);
            }
            
            string result = "";
            for (int i = res.Length - 1; i >= 0; i--)
            {
                result += res[i];
            }

            return result;
        }

        // 3、子集
        public IList<IList<int>> Subsets(int[] nums)
        {
            List <IList<int>> res = new List <IList<int>>();
            res.Add(new List<int>());

            for (int i = 0; i < nums.Length; i++)
            {
                int size = res.Count;
                
                for (int j = 0; j < size; j++)
                {
                    IList<int> list = res[j];
                    IList<int> temp = new List<int>(list);
                    temp.Add(nums[i]);
                    res.Add(temp);
                }

            }
            return res;
        }

        // 3、只出现一次的数字  如何才能做到线性时间复杂度和常数空间复杂度呢？  ----->  位运算
        public int SingleNumber(int[] nums)
        {
            // 异或位运算    任何数和 0 做异或 都为任何数本身
            int res = 0;
            foreach (var item in nums)
            {
                res ^= item;

            }
            return res;
        }


    }


    /*
        二叉树结点
     */
    class TreeNode
    {
      public int val;
      public TreeNode left;
      public TreeNode right;
      public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)
        {
            this.val = val;
            this.left = left;
            this.right = right;
        }

    }

        /*
            单链表结点
         */
    class ListNode
    {
        public int val;
        public ListNode next;
        public ListNode(int val = 0, ListNode next = null)
        {
            this.val = val;
            this.next = next;
        }
    }
    

    /*
        多级双向链表结点
     */
    class Node
    {
        public int val;
        public Node prev;
        public Node next;
        public Node child;

    }

}


// See https://aka.ms/new-console-template for more information


using leetcode;

Class1 class1 = new Class1();

//int res = class1.PivotIndex(new int[] { -1, -1, -1, -1, -1, -1 });
//Console.WriteLine(res);




//bool res = class1.ValidPalindrome("");
//Console.WriteLine(res);


/*int res = class1.CountSubstrings("abc");
Console.WriteLine(res);*/


//ListNode l1 = new ListNode(1);
//l1.next = new ListNode(4);
//l1.next.next = new ListNode(3);



/*ListNode l2 = new ListNode(9);
l2.next = new ListNode(9);
//l2.next.next = new ListNode(4);


var res = class1.AddTwoNumbers(l1, l2);

while(res != null)
{
    Console.WriteLine(res.val);
    res = res.next;
}*/

/*ListNode l1 = new ListNode(1);
l1.next = new ListNode(2);
l1.next.next = new ListNode(3);
l1.next.next.next = new ListNode(4);
l1.next.next.next.next = new ListNode(5);
class1.ReorderList(l1);*/



/*ListNode l1 = new ListNode(1);
l1.next = new ListNode(2);
l1.next.next = new ListNode(2);
l1.next.next.next = new ListNode(1);
Console.WriteLine(class1.IsPalindrome(l1));*/



/*int res = class1.CountSubstrings("aaa");
Console.WriteLine(res);*/


//int res = class1.NumDecodings("226");
//Console.WriteLine(res);


//bool res = class1.WordBreak("leetcode", new List<string>() { "leet", "code"});
//System.Console.WriteLine(res);



string res = class1.AddBinary("1010", "1011");
Console.WriteLine(res);




/*var res = class1.ThreeSum(new int[] { -1,0,1,2,-1,4});
foreach (var item in res)
{
    foreach(var item2 in item)
    {
        Console.Write(item2.ToString() + "  ");
    }
    Console.WriteLine();
}

Person Person1 = new Person();
Console.WriteLine(Person1.Name);
Person1.Age = -3;
Console.WriteLine(Person1.Age);*/

/*var res2 = class1.MinSubArrayLen(11, new int[] {1, 2, 3, 4, 5});
Console.WriteLine(res2);*/


/*var res = class1.NumSubarrayProductLessThanK(new int[] { 10, 5, 2, 6 }, 100);
Console.WriteLine(res);*/


// ======== End 专题 动态规划、贪心、位运算、图 java + c# ========
